#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case, non_upper_case_globals, unused_assignments, unused_mut)]
#![register_tool(c2rust)]
#![feature(c_variadic, core_intrinsics, extern_types, register_tool, rustc_private, untagged_unions)]
use ::c2rust_out::*;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn exit(_: libc::c_int) -> !;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
    fn fileno(__stream: *mut FILE) -> libc::c_int;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memchr(
        _: *const libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: Option::<
            unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
    fn epoll_create(__size: libc::c_int) -> libc::c_int;
    fn epoll_ctl(
        __epfd: libc::c_int,
        __op: libc::c_int,
        __fd: libc::c_int,
        __event: *mut epoll_event,
    ) -> libc::c_int;
    fn epoll_wait(
        __epfd: libc::c_int,
        __events: *mut epoll_event,
        __maxevents: libc::c_int,
        __timeout: libc::c_int,
    ) -> libc::c_int;
    fn writev(__fd: libc::c_int, __iovec: *const iovec, __count: libc::c_int) -> ssize_t;
    fn shutdown(__fd: libc::c_int, __how: libc::c_int) -> libc::c_int;
    fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;
    fn mmap(
        __addr: *mut libc::c_void,
        __len: size_t,
        __prot: libc::c_int,
        __flags: libc::c_int,
        __fd: libc::c_int,
        __offset: __off_t,
    ) -> *mut libc::c_void;
    fn munmap(__addr: *mut libc::c_void, __len: size_t) -> libc::c_int;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn sqrt(_: libc::c_double) -> libc::c_double;
    fn fabs(_: libc::c_double) -> libc::c_double;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn time(__timer: *mut time_t) -> time_t;
    fn difftime(__time1: time_t, __time0: time_t) -> libc::c_double;
    fn mktime(__tp: *mut tm) -> time_t;
    fn strftime(
        __s: *mut libc::c_char,
        __maxsize: size_t,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> size_t;
    fn strptime(
        __s: *const libc::c_char,
        __fmt: *const libc::c_char,
        __tp: *mut tm,
    ) -> *mut libc::c_char;
    fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    fn gettimeofday(__tv: *mut timeval, __tz: *mut libc::c_void) -> libc::c_int;
    fn log10(_: libc::c_double) -> libc::c_double;
    fn pow(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn ceil(_: libc::c_double) -> libc::c_double;
    fn floor(_: libc::c_double) -> libc::c_double;
    fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
    fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn sched_yield() -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn perror(__s: *const libc::c_char);
    fn acos(_: libc::c_double) -> libc::c_double;
    fn asin(_: libc::c_double) -> libc::c_double;
    fn atan(_: libc::c_double) -> libc::c_double;
    fn cos(_: libc::c_double) -> libc::c_double;
    fn sin(_: libc::c_double) -> libc::c_double;
    fn tan(_: libc::c_double) -> libc::c_double;
    fn cosh(_: libc::c_double) -> libc::c_double;
    fn sinh(_: libc::c_double) -> libc::c_double;
    fn tanh(_: libc::c_double) -> libc::c_double;
    fn acosh(_: libc::c_double) -> libc::c_double;
    fn asinh(_: libc::c_double) -> libc::c_double;
    fn atanh(_: libc::c_double) -> libc::c_double;
    fn exp(_: libc::c_double) -> libc::c_double;
    fn frexp(_: libc::c_double, _: *mut libc::c_int) -> libc::c_double;
    fn ldexp(_: libc::c_double, _: libc::c_int) -> libc::c_double;
    fn log(_: libc::c_double) -> libc::c_double;
    fn log2(_: libc::c_double) -> libc::c_double;
    fn hypot(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn cbrt(_: libc::c_double) -> libc::c_double;
    fn erfc(_: libc::c_double) -> libc::c_double;
    fn round(_: libc::c_double) -> libc::c_double;
    fn trunc(_: libc::c_double) -> libc::c_double;
    fn abs(_: libc::c_int) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn ioctl(__fd: libc::c_int, __request: libc::c_ulong, _: ...) -> libc::c_int;
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: Option::<
            unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
        >,
    );
    fn qsort_r(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: Option::<
            unsafe extern "C" fn(
                *const libc::c_void,
                *const libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        __arg: *mut libc::c_void,
    );
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    static mut stdin: *mut FILE;
    fn putchar(__c: libc::c_int) -> libc::c_int;
    fn puts(__s: *const libc::c_char) -> libc::c_int;
    fn sysconf(__name: libc::c_int) -> libc::c_long;
    fn fmod(_: libc::c_double, _: libc::c_double) -> libc::c_double;
    fn signal(
        __sig: libc::c_int,
        __handler: Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
    ) -> __sighandler_t;
    fn socket(
        __domain: libc::c_int,
        __type: libc::c_int,
        __protocol: libc::c_int,
    ) -> libc::c_int;
    fn bind(__fd: libc::c_int, __addr: *const sockaddr, __len: socklen_t) -> libc::c_int;
    fn connect(
        __fd: libc::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> libc::c_int;
    fn listen(__fd: libc::c_int, __n: libc::c_int) -> libc::c_int;
    fn accept(
        __fd: libc::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> libc::c_int;
    fn getaddrinfo(
        __name: *const libc::c_char,
        __service: *const libc::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> libc::c_int;
    fn freeaddrinfo(__ai: *mut addrinfo);
    fn gai_strerror(__ecode: libc::c_int) -> *const libc::c_char;
    static mut _etext: [libc::c_char; 0];
    static mut __init_array_start: [libc::c_char; 0];
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn getc(__stream: *mut FILE) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn clearerr(__stream: *mut FILE);
    fn ferror(__stream: *mut FILE) -> libc::c_int;
    fn atol(__nptr: *const libc::c_char) -> libc::c_long;
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn __errno_location() -> *mut libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __uint64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __intptr_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type int32_t = __int32_t;
pub type intptr_t = __intptr_t;
pub type uint32_t = __uint32_t;
pub type uint64_t = __uint64_t;
pub type strm_value = uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_state {
    pub env: *mut libc::c_void,
    pub prev: *mut strm_state,
    pub flags: uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_stream {
    pub type_0: strm_ptr_type,
    pub flags: libc::c_uint,
    pub mode: strm_stream_mode,
    pub start_func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    >,
    pub close_func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    >,
    pub data: *mut libc::c_void,
    pub dst: *mut strm_stream,
    pub rest: *mut *mut strm_stream,
    pub rsize: size_t,
    pub rcapa: size_t,
    pub exc: *mut node_error,
    pub refcnt: strm_int,
    pub queue: *mut strm_queue,
    pub excl: strm_int,
}
pub type strm_int = int32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_queue {
    pub head: *mut strm_queue_node,
    pub tail: *mut strm_queue_node,
    pub mutex: pthread_mutex_t,
}
pub type pthread_mutex_t = __anonunion_pthread_mutex_t_335460617;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutex_t_335460617 {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
pub type __pthread_list_t = __pthread_internal_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_queue_node {
    pub next: *mut strm_queue_node,
    pub n: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct node_error {
    pub type_0: libc::c_int,
    pub arg: strm_value,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
}
pub type strm_stream_mode = __anonenum_strm_stream_mode_726947345;
pub type __anonenum_strm_stream_mode_726947345 = libc::c_uint;
pub const strm_killed: __anonenum_strm_stream_mode_726947345 = 4;
pub const strm_dying: __anonenum_strm_stream_mode_726947345 = 3;
pub const strm_consumer: __anonenum_strm_stream_mode_726947345 = 2;
pub const strm_filter: __anonenum_strm_stream_mode_726947345 = 1;
pub const strm_producer: __anonenum_strm_stream_mode_726947345 = 0;
pub type strm_ptr_type = libc::c_uint;
pub const STRM_PTR_AUX: strm_ptr_type = 4;
pub const STRM_PTR_IO: strm_ptr_type = 3;
pub const STRM_PTR_GENFUNC: strm_ptr_type = 2;
pub const STRM_PTR_LAMBDA: strm_ptr_type = 1;
pub const STRM_PTR_STREAM: strm_ptr_type = 0;
pub type strm_cfunc = Option::<
    unsafe extern "C" fn(
        *mut strm_stream,
        libc::c_int,
        *mut strm_value,
        *mut strm_value,
    ) -> libc::c_int,
>;
pub type strm_string = uint64_t;
pub type strm_array = uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_array_0 {
    pub len: strm_int,
    pub ptr: *mut strm_value,
    pub headers: strm_array,
    pub ns: *mut strm_state,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct node_lambda {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub args: *mut node,
    pub body: *mut node,
    pub block: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct node {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
}
pub type node_type = __anonenum_node_type_987017113;
pub type __anonenum_node_type_987017113 = libc::c_uint;
pub const NODE_IMPORT: __anonenum_node_type_987017113 = 30;
pub const NODE_NS: __anonenum_node_type_987017113 = 29;
pub const NODE_NODES: __anonenum_node_type_987017113 = 28;
pub const NODE_ARRAY: __anonenum_node_type_987017113 = 27;
pub const NODE_GENFUNC: __anonenum_node_type_987017113 = 26;
pub const NODE_FCALL: __anonenum_node_type_987017113 = 25;
pub const NODE_CALL: __anonenum_node_type_987017113 = 24;
pub const NODE_OP: __anonenum_node_type_987017113 = 23;
pub const NODE_CONST: __anonenum_node_type_987017113 = 22;
pub const NODE_VAR: __anonenum_node_type_987017113 = 21;
pub const NODE_RETURN: __anonenum_node_type_987017113 = 20;
pub const NODE_SKIP: __anonenum_node_type_987017113 = 19;
pub const NODE_EMIT: __anonenum_node_type_987017113 = 18;
pub const NODE_IF: __anonenum_node_type_987017113 = 17;
pub const NODE_LET: __anonenum_node_type_987017113 = 16;
pub const NODE_IDENT: __anonenum_node_type_987017113 = 15;
pub const NODE_SPLAT: __anonenum_node_type_987017113 = 14;
pub const NODE_PSPLAT: __anonenum_node_type_987017113 = 13;
pub const NODE_PSTRUCT: __anonenum_node_type_987017113 = 12;
pub const NODE_PARRAY: __anonenum_node_type_987017113 = 11;
pub const NODE_PLAMBDA: __anonenum_node_type_987017113 = 10;
pub const NODE_LAMBDA: __anonenum_node_type_987017113 = 9;
pub const NODE_CFUNC: __anonenum_node_type_987017113 = 8;
pub const NODE_PAIR: __anonenum_node_type_987017113 = 7;
pub const NODE_ARGS: __anonenum_node_type_987017113 = 6;
pub const NODE_BOOL: __anonenum_node_type_987017113 = 5;
pub const NODE_NIL: __anonenum_node_type_987017113 = 4;
pub const NODE_STR: __anonenum_node_type_987017113 = 3;
pub const NODE_TIME: __anonenum_node_type_987017113 = 2;
pub const NODE_FLOAT: __anonenum_node_type_987017113 = 1;
pub const NODE_INT: __anonenum_node_type_987017113 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_lambda {
    pub type_0: strm_ptr_type,
    pub body: *mut node_lambda,
    pub state: *mut strm_state,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_genfunc {
    pub type_0: strm_ptr_type,
    pub state: *mut strm_state,
    pub id: strm_string,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct node_string {
    pub len: strm_int,
    pub buf: [libc::c_char; 0],
}
pub type node_string_0 = *mut node_string;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct parser_state {
    pub nerr: libc::c_int,
    pub lval: *mut libc::c_void,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub tline: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_int_587342743 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub value: int32_t,
}
pub type node_int = __anonstruct_node_int_587342743;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_float_504457063 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub value: libc::c_double,
}
pub type node_float = __anonstruct_node_float_504457063;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_time_256132641 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub sec: libc::c_long,
    pub usec: libc::c_long,
    pub utc_offset: libc::c_int,
}
pub type node_time = __anonstruct_node_time_256132641;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_str_335716169 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub value: node_string_0,
}
pub type node_str = __anonstruct_node_str_335716169;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_bool_164879216 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub value: libc::c_int,
}
pub type node_bool = __anonstruct_node_bool_164879216;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_pair_758919965 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub key: node_string_0,
    pub value: *mut node,
}
pub type node_pair = __anonstruct_node_pair_758919965;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_args_340137494 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub len: libc::c_int,
    pub max: libc::c_int,
    pub data: *mut node_string_0,
}
pub type node_args = __anonstruct_node_args_340137494;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_nodes_446254667 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub len: libc::c_int,
    pub max: libc::c_int,
    pub data: *mut *mut node,
}
pub type node_nodes = __anonstruct_node_nodes_446254667;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_array_907279779 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub len: libc::c_int,
    pub max: libc::c_int,
    pub data: *mut *mut node,
    pub headers: *mut node_string_0,
    pub ns: node_string_0,
}
pub type node_array = __anonstruct_node_array_907279779;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_psplat_44597470 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub head: *mut node,
    pub mid: *mut node,
    pub tail: *mut node,
}
pub type node_psplat = __anonstruct_node_psplat_44597470;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_splat_38903079 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub node: *mut node,
}
pub type node_splat = __anonstruct_node_splat_38903079;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_if_44597471 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub cond: *mut node,
    pub then: *mut node,
    pub opt_else: *mut node,
}
pub type node_if = __anonstruct_node_if_44597471;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_emit_44597472 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub emit: *mut node,
}
pub type node_emit = __anonstruct_node_emit_44597472;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_let_907279780 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub lhs: node_string_0,
    pub rhs: *mut node,
}
pub type node_let = __anonstruct_node_let_907279780;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_ident_907279781 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub name: node_string_0,
}
pub type node_ident = __anonstruct_node_ident_907279781;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_op_536440336 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub op: node_string_0,
    pub lhs: *mut node,
    pub rhs: *mut node,
}
pub type node_op = __anonstruct_node_op_536440336;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct node_plambda {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub pat: *mut node,
    pub cond: *mut node,
    pub body: *mut node,
    pub next: *mut node,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_call_907279782 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub ident: node_string_0,
    pub args: *mut node,
}
pub type node_call = __anonstruct_node_call_907279782;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_fcall_1043203960 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub func: *mut node,
    pub args: *mut node,
}
pub type node_fcall = __anonstruct_node_fcall_1043203960;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_genfunc_1043203961 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub id: node_string_0,
}
pub type node_genfunc = __anonstruct_node_genfunc_1043203961;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_return_1043203962 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub rv: *mut node,
}
pub type node_return = __anonstruct_node_return_1043203962;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_ns_1043203963 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub name: node_string_0,
    pub body: *mut node,
}
pub type node_ns = __anonstruct_node_ns_1043203963;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __anonstruct_node_import_1043203964 {
    pub type_0: node_type,
    pub fname: *const libc::c_char,
    pub lineno: libc::c_int,
    pub name: node_string_0,
}
pub type node_import = __anonstruct_node_import_1043203964;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct array_data {
    pub n: libc::c_int,
    pub arr: strm_array,
}
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type ssize_t = __ssize_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type pthread_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56],
    pub __align: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_task {
    pub func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    >,
    pub data: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_io {
    pub type_0: strm_ptr_type,
    pub fd: libc::c_int,
    pub mode: libc::c_int,
    pub read_stream: *mut strm_stream,
    pub write_stream: *mut strm_stream,
}
pub type strm_io_0 = *mut strm_io;
#[derive(Copy, Clone)]
#[repr(C)]
pub union epoll_data {
    pub ptr: *mut libc::c_void,
    pub fd: libc::c_int,
    pub u32_0: uint32_t,
    pub u64_0: uint64_t,
}
pub type epoll_data_t = epoll_data;
#[derive(Copy, Clone)]
#[repr(C, packed)]
pub struct epoll_event {
    pub events: uint32_t,
    pub data: epoll_data_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct iovec {
    pub iov_base: *mut libc::c_void,
    pub iov_len: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fd_read_buffer {
    pub fd: libc::c_int,
    pub beg: *mut libc::c_char,
    pub end: *mut libc::c_char,
    pub io: strm_io_0,
    pub buf: *mut libc::c_char,
    pub fixed: [libc::c_char; 8192],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct write_data {
    pub f: *mut FILE,
    pub io: strm_io_0,
}
pub type khint32_t = libc::c_uint;
pub type khint64_t = libc::c_ulong;
pub type khint_t = khint32_t;
pub type khiter_t = khint_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct seq_data {
    pub n: libc::c_double,
    pub end: libc::c_double,
    pub inc: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct repeat_data {
    pub v: strm_value,
    pub count: strm_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct cycle_data {
    pub ary: strm_array,
    pub count: strm_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct map_data {
    pub func: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct count_data {
    pub count: strm_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct minmax_data {
    pub start: libc::c_int,
    pub min: libc::c_int,
    pub data: strm_value,
    pub num: libc::c_double,
    pub func: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct reduce_data {
    pub init: strm_int,
    pub acc: strm_value,
    pub func: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct kh_rbk_s {
    pub n_buckets: khint_t,
    pub size: khint_t,
    pub n_occupied: khint_t,
    pub upper_bound: khint_t,
    pub flags: *mut khint32_t,
    pub keys: *mut khint64_t,
    pub vals: *mut strm_value,
}
pub type kh_rbk_t = kh_rbk_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rbk_data {
    pub tbl: *mut kh_rbk_t,
    pub func: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct slice_data {
    pub n: strm_int,
    pub i: strm_int,
    pub buf: *mut strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct take_data {
    pub n: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct uniq_data {
    pub last: strm_value,
    pub v: strm_value,
    pub func: strm_value,
    pub init: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sum_data {
    pub sum: libc::c_double,
    pub c: libc::c_double,
    pub num: strm_int,
    pub func: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mvavg_data {
    pub num: strm_int,
    pub i: strm_int,
    pub filled: strm_int,
    pub func: strm_value,
    pub func_p: strm_int,
    pub data: [libc::c_double; 0],
}
pub type stdev_mode = libc::c_uint;
pub const mode_mean_variance: stdev_mode = 3;
pub const mode_mean_stdev: stdev_mode = 2;
pub const mode_variance: stdev_mode = 1;
pub const mode_stdev: stdev_mode = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stdev_data {
    pub num: strm_int,
    pub s1: libc::c_double,
    pub s2: libc::c_double,
    pub func: strm_value,
    pub mode: stdev_mode,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct correl_data {
    pub n: strm_int,
    pub sx: libc::c_double,
    pub sy: libc::c_double,
    pub sxx: libc::c_double,
    pub syy: libc::c_double,
    pub sxy: libc::c_double,
}
pub type __suseconds_t = libc::c_long;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub __tm_gmtoff: libc::c_long,
    pub __tm_zone: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_time {
    pub type_0: strm_ptr_type,
    pub ns: *mut strm_state,
    pub tv: timeval,
    pub utc_offset: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_misc {
    pub type_0: strm_ptr_type,
    pub ns: *mut strm_state,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_pthread_mutexattr_t_488594144 {
    pub __size: [libc::c_char; 4],
    pub __align: libc::c_int,
}
pub type pthread_mutexattr_t = __anonunion_pthread_mutexattr_t_488594144;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u_274369385 {
    pub f: libc::c_double,
    pub i: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct object {
    pub type_0: strm_ptr_type,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union __anonunion_u_274369386 {
    pub f: libc::c_double,
    pub i: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct recv_data {
    pub strm: *mut strm_stream,
    pub func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct latch_data {
    pub dq: *mut strm_queue,
    pub rq: *mut strm_queue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct zip_data {
    pub a: strm_array,
    pub i: strm_int,
    pub len: strm_int,
    pub latch: [*mut strm_stream; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct concat_data {
    pub i: strm_int,
    pub len: strm_int,
    pub latch: [*mut strm_stream; 0],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct kh_env_s {
    pub n_buckets: khint_t,
    pub size: khint_t,
    pub n_occupied: khint_t,
    pub upper_bound: khint_t,
    pub flags: *mut khint32_t,
    pub keys: *mut khint64_t,
    pub vals: *mut strm_value,
}
pub type kh_env_t = kh_env_s;
pub type strm_env = kh_env_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_worker {
    pub th: pthread_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct kh_kvs_s {
    pub n_buckets: khint_t,
    pub size: khint_t,
    pub n_occupied: khint_t,
    pub upper_bound: khint_t,
    pub flags: *mut khint32_t,
    pub keys: *mut strm_string,
    pub vals: *mut strm_value,
}
pub type kh_kvs_t = kh_kvs_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct kh_txn_s {
    pub n_buckets: khint_t,
    pub size: khint_t,
    pub n_occupied: khint_t,
    pub upper_bound: khint_t,
    pub flags: *mut khint32_t,
    pub keys: *mut strm_string,
    pub vals: *mut strm_value,
}
pub type kh_txn_t = kh_txn_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_kvs {
    pub type_0: strm_ptr_type,
    pub ns: *mut strm_state,
    pub kv: *mut kh_kvs_t,
    pub serial: uint64_t,
    pub lock: pthread_mutex_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_txn {
    pub type_0: strm_ptr_type,
    pub ns: *mut strm_state,
    pub tv: *mut kh_txn_t,
    pub kvs: *mut strm_kvs,
    pub serial: uint64_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yy_buffer_state {
    pub yy_input_file: *mut FILE,
    pub yy_ch_buf: *mut libc::c_char,
    pub yy_buf_pos: *mut libc::c_char,
    pub yy_buf_size: libc::c_int,
    pub yy_n_chars: libc::c_int,
    pub yy_is_our_buffer: libc::c_int,
    pub yy_is_interactive: libc::c_int,
    pub yy_at_bol: libc::c_int,
    pub yy_bs_lineno: libc::c_int,
    pub yy_bs_column: libc::c_int,
    pub yy_fill_buffer: libc::c_int,
    pub yy_buffer_status: libc::c_int,
}
pub type YY_BUFFER_STATE = *mut yy_buffer_state;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct kh_ns_s {
    pub n_buckets: khint_t,
    pub size: khint_t,
    pub n_occupied: khint_t,
    pub upper_bound: khint_t,
    pub flags: *mut khint32_t,
    pub keys: *mut khint64_t,
    pub vals: *mut *mut strm_state,
}
pub type kh_ns_t = kh_ns_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct winsize {
    pub ws_row: libc::c_ushort,
    pub ws_col: libc::c_ushort,
    pub ws_xpixel: libc::c_ushort,
    pub ws_ypixel: libc::c_ushort,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bar_data {
    pub title: *const libc::c_char,
    pub tlen: strm_int,
    pub col: strm_int,
    pub row: strm_int,
    pub dlen: strm_int,
    pub llen: strm_int,
    pub offset: strm_int,
    pub max: strm_int,
    pub data: *mut libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sort_arg {
    pub strm: *mut strm_stream,
    pub func: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sort_data {
    pub len: strm_int,
    pub capa: strm_int,
    pub buf: *mut strm_value,
    pub func: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sortby_value {
    pub v: strm_value,
    pub o: strm_value,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sortby_data {
    pub len: strm_int,
    pub capa: strm_int,
    pub buf: *mut sortby_value,
    pub strm: *mut strm_stream,
    pub func: strm_value,
}
pub type csv_type = libc::c_uint;
pub const TYPE_FLOAT: csv_type = 6;
pub const TYPE_INT: csv_type = 5;
pub const TYPE_ESC: csv_type = 4;
pub const TYPE_TIME: csv_type = 3;
pub const TYPE_NUM: csv_type = 2;
pub const TYPE_STR: csv_type = 1;
pub const TYPE_UNSPC: csv_type = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct csv_data {
    pub headers: strm_array,
    pub types: *mut csv_type,
    pub prev: strm_string,
    pub sep: libc::c_char,
    pub n: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rand_data {
    pub seed: [uint32_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rnorm_data {
    pub seed: [uint32_t; 4],
    pub has_spare: libc::c_int,
    pub spare: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sample_data {
    pub seed: [uint32_t; 4],
    pub i: strm_int,
    pub len: strm_int,
    pub samples: [strm_value; 0],
}
pub type __sighandler_t = Option::<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sig_list {
    pub sig: libc::c_int,
    pub func: Option::<unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> ()>,
    pub arg: *mut libc::c_void,
    pub next: *mut sig_list,
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list___0 = __gnuc_va_list;
pub type __uint16_t = libc::c_ushort;
pub type __socklen_t = libc::c_uint;
pub type socklen_t = __socklen_t;
pub type sa_family_t = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [libc::c_char; 14],
}
pub type uint16_t = __uint16_t;
pub type in_addr_t = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_port_t = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [libc::c_uchar; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct addrinfo {
    pub ai_flags: libc::c_int,
    pub ai_family: libc::c_int,
    pub ai_socktype: libc::c_int,
    pub ai_protocol: libc::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut libc::c_char,
    pub ai_next: *mut addrinfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct socket_data {
    pub sock: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct strm_string_0 {
    pub ptr: *const libc::c_char,
    pub len: strm_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sym_key {
    pub ptr: *const libc::c_char,
    pub len: strm_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct kh_sym_s {
    pub n_buckets: khint_t,
    pub size: khint_t,
    pub n_occupied: khint_t,
    pub upper_bound: khint_t,
    pub flags: *mut khint32_t,
    pub keys: *mut sym_key,
    pub vals: *mut strm_string,
}
pub type kh_sym_t = kh_sym_s;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type int16_t = __int16_t;
pub type uint8_t = __uint8_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub union YYSTYPE {
    pub nd: *mut node,
    pub id: node_string_0,
}
pub type yytype_int8 = libc::c_schar;
pub type yytype_int16 = libc::c_short;
pub type yytype_uint8 = libc::c_uchar;
pub type yy_state_t = yytype_uint8;
pub type yy_state_fast_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub union yyalloc {
    pub yyss_alloc: yy_state_t,
    pub yyvs_alloc: YYSTYPE,
}
pub type flex_uint8_t = uint8_t;
pub type flex_int16_t = int16_t;
pub type flex_int32_t = int32_t;
pub type yy_size_t = size_t;
pub type YY_CHAR = flex_uint8_t;
pub type yy_state_type = libc::c_int;
unsafe extern "C" fn strm_clear_exc(mut strm: *mut strm_stream) {
    if !((*strm).exc).is_null() {
        free((*strm).exc as *mut libc::c_void);
    }
    (*strm).exc = 0 as *mut libc::c_void as *mut node_error;
}
unsafe extern "C" fn strm_set_exc(
    mut strm: *mut strm_stream,
    mut type_0: libc::c_int,
    mut arg: strm_value,
) -> *mut node_error {
    let mut exc: *mut node_error = 0 as *mut node_error;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_error>() as libc::c_ulong);
    exc = tmp as *mut node_error;
    if exc.is_null() {
        return 0 as *mut libc::c_void as *mut node_error;
    }
    (*exc).type_0 = type_0;
    (*exc).arg = arg;
    (*exc).fname = 0 as *const libc::c_char;
    (*exc).lineno = 0 as libc::c_int;
    strm_clear_exc(strm);
    (*strm).exc = exc;
    return exc;
}
unsafe extern "C" fn node_to_sym(mut s: node_string_0) -> strm_string {
    let mut tmp: strm_string = 0;
    tmp = strm_str_intern(((*s).buf).as_mut_ptr() as *const libc::c_char, (*s).len);
    return tmp;
}
unsafe extern "C" fn node_to_str(mut s: node_string_0) -> strm_string {
    let mut tmp: strm_string = 0;
    tmp = strm_str_new(((*s).buf).as_mut_ptr() as *const libc::c_char, (*s).len);
    return tmp;
}
unsafe extern "C" fn exec_eq(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"vv\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_value_eq(x, y);
    *ret = strm_bool_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_neq(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"vv\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_value_eq(x, y);
    if tmp___0 != 0 {
        tmp___1 = 0 as libc::c_int;
    } else {
        tmp___1 = 1 as libc::c_int;
    }
    *ret = strm_bool_value(tmp___1);
    return 0 as libc::c_int;
}
unsafe extern "C" fn cfunc_closer(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_connect(
    mut strm: *mut strm_stream,
    mut src: strm_value,
    mut dst: strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: *mut strm_stream = 0 as *mut strm_stream;
    let mut lmbd: *mut strm_lambda = 0 as *mut strm_lambda;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    let mut arrd: *mut array_data = 0 as *mut array_data;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: *mut strm_stream = 0 as *mut strm_stream;
    let mut lmbd___0: *mut strm_lambda = 0 as *mut strm_lambda;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: *mut strm_stream = 0 as *mut strm_stream;
    let mut func: Option::<
        unsafe extern "C" fn(
            *mut strm_stream,
            libc::c_int,
            *mut strm_value,
            *mut strm_value,
        ) -> libc::c_int,
    > = None;
    let mut tmp___10: strm_cfunc = None;
    let mut tmp___11: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut lstrm: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp___15: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut rstrm: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp___16: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___17: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___18: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: libc::c_int = 0;
    tmp___6 = strm_ptr_tag_p(src, STRM_PTR_IO);
    if tmp___6 != 0 {
        tmp = strm_io_stream(src, 1 as libc::c_int);
        src = strm_ptr_value(tmp as *mut libc::c_void);
    } else {
        tmp___5 = strm_ptr_tag_p(src, STRM_PTR_LAMBDA);
        if tmp___5 != 0 {
            tmp___0 = strm_value_ptr(src, STRM_PTR_LAMBDA);
            lmbd = tmp___0 as *mut strm_lambda;
            tmp___1 = strm_stream_new(
                strm_filter,
                Some(
                    blk_exec
                        as unsafe extern "C" fn(
                            *mut strm_stream,
                            strm_value,
                        ) -> libc::c_int,
                ),
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
                lmbd as *mut libc::c_void,
            );
            src = strm_ptr_value(tmp___1 as *mut libc::c_void);
        } else {
            tmp___4 = strm_array_p(src);
            if tmp___4 != 0 {
                tmp___2 = malloc(::std::mem::size_of::<array_data>() as libc::c_ulong);
                arrd = tmp___2 as *mut array_data;
                (*arrd).arr = src;
                (*arrd).n = 0 as libc::c_int;
                tmp___3 = strm_stream_new(
                    strm_producer,
                    Some(
                        arr_exec
                            as unsafe extern "C" fn(
                                *mut strm_stream,
                                strm_value,
                            ) -> libc::c_int,
                    ),
                    ::std::mem::transmute::<
                        *mut libc::c_void,
                        Option::<
                            unsafe extern "C" fn(
                                *mut strm_stream,
                                strm_value,
                            ) -> libc::c_int,
                        >,
                    >(0 as *mut libc::c_void),
                    arrd as *mut libc::c_void,
                );
                src = strm_ptr_value(tmp___3 as *mut libc::c_void);
            }
        }
    }
    tmp___14 = strm_ptr_tag_p(dst, STRM_PTR_IO);
    if tmp___14 != 0 {
        tmp___7 = strm_io_stream(dst, 2 as libc::c_int);
        dst = strm_ptr_value(tmp___7 as *mut libc::c_void);
    } else {
        tmp___13 = strm_ptr_tag_p(dst, STRM_PTR_LAMBDA);
        if tmp___13 != 0 {
            tmp___8 = strm_value_ptr(dst, STRM_PTR_LAMBDA);
            lmbd___0 = tmp___8 as *mut strm_lambda;
            tmp___9 = strm_stream_new(
                strm_filter,
                Some(
                    blk_exec
                        as unsafe extern "C" fn(
                            *mut strm_stream,
                            strm_value,
                        ) -> libc::c_int,
                ),
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
                lmbd___0 as *mut libc::c_void,
            );
            dst = strm_ptr_value(tmp___9 as *mut libc::c_void);
        } else {
            tmp___12 = strm_cfunc_p(dst);
            if tmp___12 != 0 {
                tmp___10 = strm_value_cfunc(dst);
                func = tmp___10;
                tmp___11 = strm_stream_new(
                    strm_filter,
                    Some(
                        cfunc_exec
                            as unsafe extern "C" fn(
                                *mut strm_stream,
                                strm_value,
                            ) -> libc::c_int,
                    ),
                    Some(
                        cfunc_closer
                            as unsafe extern "C" fn(
                                *mut strm_stream,
                                strm_value,
                            ) -> libc::c_int,
                    ),
                    ::std::mem::transmute::<
                        Option::<
                            unsafe extern "C" fn(
                                *mut strm_stream,
                                libc::c_int,
                                *mut strm_value,
                                *mut strm_value,
                            ) -> libc::c_int,
                        >,
                        *mut libc::c_void,
                    >(func),
                );
                dst = strm_ptr_value(tmp___11 as *mut libc::c_void);
            }
        }
    }
    tmp___19 = strm_ptr_tag_p(src, STRM_PTR_STREAM);
    if tmp___19 != 0 {
        tmp___20 = strm_ptr_tag_p(dst, STRM_PTR_STREAM);
        if tmp___20 != 0 {
            tmp___15 = strm_value_ptr(src, STRM_PTR_STREAM);
            lstrm = tmp___15 as *mut strm_stream;
            tmp___16 = strm_value_ptr(dst, STRM_PTR_STREAM);
            rstrm = tmp___16 as *mut strm_stream;
            if lstrm as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                strm_raise(strm, b"stream error\0" as *const u8 as *const libc::c_char);
                return 1 as libc::c_int;
            } else {
                if rstrm as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                    strm_raise(
                        strm,
                        b"stream error\0" as *const u8 as *const libc::c_char,
                    );
                    return 1 as libc::c_int;
                } else {
                    if (*lstrm).mode as libc::c_uint == 2 as libc::c_uint {
                        strm_raise(
                            strm,
                            b"stream error\0" as *const u8 as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    } else {
                        if (*rstrm).mode as libc::c_uint == 0 as libc::c_uint {
                            strm_raise(
                                strm,
                                b"stream error\0" as *const u8 as *const libc::c_char,
                            );
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
            tmp___17 = strm_value_ptr(dst, STRM_PTR_STREAM);
            tmp___18 = strm_value_ptr(src, STRM_PTR_STREAM);
            strm_stream_connect(
                tmp___18 as *mut strm_stream,
                tmp___17 as *mut strm_stream,
            );
            *ret = dst;
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn exec_bar(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"vv\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_connect(strm, x, y, ret);
    return tmp___0;
}
unsafe extern "C" fn ary_get(
    mut strm: *mut strm_stream,
    mut ary: strm_value,
    mut argc: libc::c_int,
    mut argv: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut a: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut idx: strm_value = 0;
    let mut i: strm_int = 0;
    let mut tmp: strm_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut i___0: strm_int = 0;
    let mut len: strm_int = 0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    if argc != 1 as libc::c_int {
        strm_raise(
            strm,
            b"wrong number of arguments\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    a = strm_ary_struct(ary);
    idx = *argv.offset(0 as libc::c_int as isize);
    tmp___0 = strm_number_p(idx);
    if tmp___0 != 0 {
        tmp = strm_value_int(idx);
        i = tmp;
        if i >= (*a).len {
            return 1 as libc::c_int;
        }
        *ret = *((*a).ptr).offset(i as isize);
        return 0 as libc::c_int;
    }
    tmp___3 = strm_string_p(idx);
    if tmp___3 != 0 {
        if (*a).headers != 0 {
            len = (*a).len;
            i___0 = 0 as libc::c_int;
            while i___0 < len {
                tmp___1 = strm_ary_struct((*a).headers);
                tmp___2 = strm_str_eq(idx, *((*tmp___1).ptr).offset(i___0 as isize));
                if tmp___2 != 0 {
                    *ret = *((*a).ptr).offset(i___0 as isize);
                    return 0 as libc::c_int;
                }
                i___0 += 1;
            }
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn pattern_placeholder_p(mut name: node_string_0) -> libc::c_int {
    if (*name).len == 1 as libc::c_int {
        if *((*name).buf).as_mut_ptr().offset(0 as libc::c_int as isize) as libc::c_int
            == 95 as libc::c_int
        {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn pmatch_struct(
    mut strm: *mut strm_stream,
    mut state: *mut strm_state,
    mut pat: *mut node,
    mut val: strm_value,
    mut tbl: *mut uint64_t,
    mut len: *mut strm_int,
) -> libc::c_int {
    let mut pstr: *mut node_nodes = 0 as *mut node_nodes;
    let mut ary: strm_array = 0;
    let mut a: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut headers: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i: libc::c_int = 0;
    let mut npair: *mut node_pair = 0 as *mut node_pair;
    let mut key: strm_string = 0;
    let mut j: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut n: uint64_t = 0;
    pstr = pat as *mut node_nodes;
    ary = val;
    tmp = strm_ary_struct(ary);
    a = tmp;
    if (*a).headers == 0 {
        return 1 as libc::c_int;
    }
    if (*pstr).len > (*a).len {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_ary_struct((*a).headers);
    headers = (*tmp___0).ptr;
    i = 0 as libc::c_int;
    while i < (*pstr).len {
        npair = *((*pstr).data).offset(i as isize) as *mut node_pair;
        if !((*npair).type_0 as libc::c_uint == 7 as libc::c_uint) {
            __assert_fail(
                b"npair->type == NODE_PAIR\0" as *const u8 as *const libc::c_char,
                b"exec.c\0" as *const u8 as *const libc::c_char,
                203 as libc::c_uint,
                b"pmatch_struct\0" as *const u8 as *const libc::c_char,
            );
        }
        key = node_to_sym((*npair).key);
        j = 0 as libc::c_int;
        while i < (*a).len {
            if *headers.offset(j as isize) == key {
                tmp___2 = pmatch(
                    strm,
                    state,
                    (*npair).value,
                    *((*a).ptr).offset(j as isize),
                );
                if tmp___2 == 1 as libc::c_int {
                    return 1 as libc::c_int;
                }
                if !tbl.is_null() {
                    n = ((1 as libc::c_int) << j % 64 as libc::c_int) as uint64_t;
                    if *tbl.offset((j / 64 as libc::c_int) as isize) & n != 0 {
                        *len -= 1;
                    }
                    let ref mut fresh0 = *tbl.offset((j / 64 as libc::c_int) as isize);
                    *fresh0 |= n;
                }
                break;
            } else {
                j += 1;
            }
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn pmatch(
    mut strm: *mut strm_stream,
    mut state: *mut strm_state,
    mut pat: *mut node,
    mut val: strm_value,
) -> libc::c_int {
    let mut ni: *mut node_ident = 0 as *mut node_ident;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: strm_string = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut n: strm_int = 0;
    let mut tmp___5: strm_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_double = 0.;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: libc::c_double = 0.;
    let mut tmp___12: libc::c_int = 0;
    let mut ns: *mut node_ns = 0 as *mut node_ns;
    let mut s1: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___13: strm_string = 0;
    let mut tmp___14: *mut strm_state = 0 as *mut strm_state;
    let mut s2: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___15: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___16: libc::c_int = 0;
    let mut ary: strm_array = 0;
    let mut tmp___17: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___18: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: libc::c_int = 0;
    let mut ary___0: strm_array = 0;
    let mut psp: *mut node_psplat = 0 as *mut node_psplat;
    let mut pstr: *mut node_nodes = 0 as *mut node_nodes;
    let mut len: strm_int = 0;
    let mut buf: uint64_t = 0;
    let mut tbl: *mut uint64_t = 0 as *mut uint64_t;
    let mut tmp___21: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___22: libc::c_int = 0;
    let mut a: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___24: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut hdr: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___25: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut splat: strm_array = 0;
    let mut tmp___26: strm_array = 0;
    let mut nhdr: strm_array = 0;
    let mut tmp___27: strm_array = 0;
    let mut n___0: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut tmp___28: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___29: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___30: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___33: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___34: libc::c_int = 0;
    let mut tmp___35: libc::c_int = 0;
    let mut tmp___36: libc::c_int = 0;
    let mut tmp___37: libc::c_int = 0;
    match (*pat).type_0 as libc::c_uint {
        15 => {
            ni = pat as *mut node_ident;
            tmp = pattern_placeholder_p((*ni).name);
            if tmp != 0 {
                return 0 as libc::c_int;
            }
            tmp___0 = node_to_sym((*ni).name);
            tmp___1 = strm_var_match(state, tmp___0, val);
            return tmp___1;
        }
        3 => {
            tmp___4 = strm_string_p(val);
            if tmp___4 != 0 {
                tmp___2 = node_to_str((*(pat as *mut node_str)).value);
                tmp___3 = strm_str_eq(val, tmp___2);
                if tmp___3 != 0 {
                    return 0 as libc::c_int;
                }
            }
        }
        0 => {
            n = (*(pat as *mut node_int)).value;
            tmp___6 = strm_int_p(val);
            if tmp___6 != 0 {
                tmp___5 = strm_value_int(val);
                if n == tmp___5 {
                    return 0 as libc::c_int;
                }
                return 1 as libc::c_int;
            }
            tmp___8 = strm_float_p(val);
            if tmp___8 != 0 {
                tmp___7 = strm_value_float(val);
                if n as libc::c_double == tmp___7 {
                    return 0 as libc::c_int;
                }
                return 1 as libc::c_int;
            }
        }
        4 => {
            tmp___9 = strm_nil_p(val);
            if tmp___9 != 0 {
                return 0 as libc::c_int;
            }
            return 1 as libc::c_int;
        }
        5 => {
            tmp___10 = strm_value_bool(val);
            if tmp___10 == (*(pat as *mut node_bool)).value {
                return 0 as libc::c_int;
            }
            return 1 as libc::c_int;
        }
        1 => {
            tmp___12 = strm_number_p(val);
            if tmp___12 != 0 {
                tmp___11 = strm_value_float(val);
                if (*(pat as *mut node_float)).value == tmp___11 {
                    return 0 as libc::c_int;
                }
                return 1 as libc::c_int;
            }
        }
        29 => {
            ns = pat as *mut node_ns;
            tmp___13 = node_to_sym((*ns).name);
            tmp___14 = strm_ns_get(tmp___13);
            s1 = tmp___14;
            tmp___15 = strm_value_ns(val);
            s2 = tmp___15;
            if s1 as libc::c_ulong != s2 as libc::c_ulong {
                return 1 as libc::c_int;
            }
            tmp___16 = pmatch(strm, state, (*ns).body, val);
            return tmp___16;
        }
        11 => {
            tmp___20 = strm_array_p(val);
            if tmp___20 != 0 {
                ary = val;
                tmp___17 = strm_ary_struct(ary);
                tmp___18 = strm_ary_struct(ary);
                tmp___19 = pattern_match(
                    strm,
                    state,
                    pat,
                    (*tmp___18).len,
                    (*tmp___17).ptr,
                );
                return tmp___19;
            }
        }
        13 => {
            tmp___35 = strm_array_p(val);
            if tmp___35 != 0 {
                ary___0 = val;
                psp = pat as *mut node_psplat;
                if !((*psp).head).is_null() {
                    if (*(*psp).head).type_0 as libc::c_uint == 12 as libc::c_uint {
                        pstr = (*psp).head as *mut node_nodes;
                        len = (*pstr).len;
                        buf = 0 as libc::c_int as uint64_t;
                        tbl = &mut buf;
                        if len > 64 as libc::c_int {
                            tmp___21 = malloc(
                                (len / 64 as libc::c_int + 1 as libc::c_int) as size_t,
                            );
                            tbl = tmp___21 as *mut uint64_t;
                            memset(
                                tbl as *mut libc::c_void,
                                0 as libc::c_int,
                                (len / 64 as libc::c_int + 1 as libc::c_int) as size_t,
                            );
                        }
                        tmp___22 = pmatch_struct(
                            strm,
                            state,
                            (*psp).head,
                            val,
                            tbl,
                            &mut len,
                        );
                        if tmp___22 == 1 as libc::c_int {
                            return 1 as libc::c_int;
                        }
                        if !((*psp).tail as libc::c_ulong
                            == 0 as *mut libc::c_void as libc::c_ulong)
                        {
                            __assert_fail(
                                b"psp->tail == NULL\0" as *const u8 as *const libc::c_char,
                                b"exec.c\0" as *const u8 as *const libc::c_char,
                                302 as libc::c_uint,
                                b"pmatch\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        tmp___24 = strm_ary_struct(ary___0);
                        a = tmp___24;
                        tmp___25 = strm_ary_struct((*a).headers);
                        hdr = (*tmp___25).ptr;
                        tmp___26 = strm_ary_new(
                            0 as *mut libc::c_void as *const strm_value,
                            (*a).len - len,
                        );
                        splat = tmp___26;
                        tmp___27 = strm_ary_new(
                            0 as *mut libc::c_void as *const strm_value,
                            (*a).len - len,
                        );
                        nhdr = tmp___27;
                        n___0 = 0 as libc::c_int;
                        i = 0 as libc::c_int;
                        while i < (*a).len {
                            if !(*tbl.offset((i / 64 as libc::c_int) as isize)
                                & ((1 as libc::c_int) << i % 64 as libc::c_int)
                                    as libc::c_ulong != 0)
                            {
                                tmp___28 = strm_ary_struct(nhdr);
                                *((*tmp___28).ptr)
                                    .offset(n___0 as isize) = *hdr.offset(i as isize);
                                tmp___29 = strm_ary_struct(splat);
                                *((*tmp___29).ptr)
                                    .offset(n___0 as isize) = *((*a).ptr).offset(i as isize);
                                n___0 += 1;
                            }
                            i += 1;
                        }
                        tmp___30 = strm_ary_struct(splat);
                        (*tmp___30).headers = nhdr;
                        tmp___31 = pmatch(strm, state, (*psp).mid, splat);
                        return tmp___31;
                    }
                }
                tmp___32 = strm_ary_struct(ary___0);
                tmp___33 = strm_ary_struct(ary___0);
                tmp___34 = pattern_match(
                    strm,
                    state,
                    pat,
                    (*tmp___33).len,
                    (*tmp___32).ptr,
                );
                return tmp___34;
            }
        }
        12 => {
            tmp___36 = strm_array_p(val);
            if tmp___36 == 0 {
                return 1 as libc::c_int;
            }
            tmp___37 = pmatch_struct(
                strm,
                state,
                pat,
                val,
                0 as *mut libc::c_void as *mut uint64_t,
                0 as *mut libc::c_void as *mut strm_int,
            );
            return tmp___37;
        }
        _ => {}
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn pattern_match(
    mut strm: *mut strm_stream,
    mut state: *mut strm_state,
    mut npat: *mut node,
    mut argc: libc::c_int,
    mut argv: *mut strm_value,
) -> libc::c_int {
    let mut pat: *mut node_nodes = 0 as *mut node_nodes;
    let mut i: libc::c_int = 0;
    let mut psp: *mut node_psplat = 0 as *mut node_psplat;
    let mut head: *mut node_nodes = 0 as *mut node_nodes;
    let mut tail: *mut node_nodes = 0 as *mut node_nodes;
    let mut rest: *mut node = 0 as *mut node;
    let mut hlen: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: strm_array = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    pat = npat as *mut node_nodes;
    if pat as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int;
    }
    if (*npat).type_0 as libc::c_uint == 13 as libc::c_uint {
        psp = pat as *mut node_psplat;
        head = (*psp).head as *mut node_nodes;
        tail = (*psp).tail as *mut node_nodes;
        rest = (*psp).mid;
        if !head.is_null() {
            tmp = (*head).len;
        } else {
            tmp = 0 as libc::c_int;
        }
        hlen = tmp;
        if argc < hlen {
            return 1 as libc::c_int;
        }
        if !head.is_null() {
            tmp___0 = pattern_match(strm, state, head as *mut node, hlen, argv);
            if tmp___0 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
        }
        if tail as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            tmp___1 = strm_ary_new(
                argv.offset(hlen as isize) as *const strm_value,
                argc - hlen,
            );
            tmp___2 = pmatch(strm, state, rest, tmp___1);
            if tmp___2 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
        } else {
            if argc < hlen + (*tail).len {
                return 1 as libc::c_int;
            }
            tmp___3 = pattern_match(
                strm,
                state,
                rest,
                argc - hlen - (*tail).len,
                argv.offset(hlen as isize),
            );
            if tmp___3 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
            tmp___4 = pattern_match(
                strm,
                state,
                tail as *mut node,
                (*tail).len,
                argv.offset(argc as isize).offset(-((*tail).len as isize)),
            );
            if tmp___4 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
        }
        return 0 as libc::c_int;
    }
    if (*pat).len != argc {
        return 1 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*pat).len {
        tmp___5 = pmatch(
            strm,
            state,
            *((*pat).data).offset(i as isize),
            *argv.offset(i as isize),
        );
        if tmp___5 == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn lambda_call(
    mut strm: *mut strm_stream,
    mut func: strm_value,
    mut argc: libc::c_int,
    mut argv: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut current_block: u64;
    let mut lambda: *mut strm_lambda = 0 as *mut strm_lambda;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut c: strm_state = strm_state {
        env: 0 as *mut libc::c_void,
        prev: 0 as *mut strm_state,
        flags: 0,
    };
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut exc: *mut node_error = 0 as *mut node_error;
    let mut nlmbd: *mut node_lambda = 0 as *mut node_lambda;
    let mut args: *mut node_args = 0 as *mut node_args;
    let mut tmp___0: strm_string = 0;
    let mut plmbd: *mut node_plambda = 0 as *mut node_plambda;
    let mut nexec: libc::c_int = 0;
    let mut cond: strm_value = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = strm_value_ptr(func, STRM_PTR_LAMBDA);
    lambda = tmp as *mut strm_lambda;
    c.env = 0 as *mut libc::c_void;
    c.prev = 0 as *mut strm_state;
    c.flags = 0 as libc::c_uint;
    c.prev = (*lambda).state;
    if (*(*lambda).body).type_0 as libc::c_uint == 9 as libc::c_uint {
        nlmbd = (*lambda).body;
        args = (*nlmbd).args as *mut node_args;
        if args as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            if argc > 0 as libc::c_int {
                current_block = 8297532334798141330;
            } else {
                current_block = 7149356873433890176;
            }
        } else if (*args).len != argc {
            current_block = 8297532334798141330;
        } else {
            current_block = 7149356873433890176;
        }
        match current_block {
            7149356873433890176 => {
                i = 0 as libc::c_int;
                while i < argc {
                    tmp___0 = node_to_sym(*((*args).data).offset(i as isize));
                    n = strm_var_set(&mut c, tmp___0, *argv.offset(i as isize));
                    if n != 0 {
                        return n;
                    }
                    i += 1;
                }
                n = exec_expr(strm, &mut c, (*nlmbd).body, ret);
                current_block = 721385680381463314;
            }
            _ => {
                strm_raise(
                    strm,
                    b"wrong number of arguments\0" as *const u8 as *const libc::c_char,
                );
                current_block = 10681933697602260671;
            }
        }
    } else if (*(*lambda).body).type_0 as libc::c_uint == 10 as libc::c_uint {
        plmbd = (*lambda).body as *mut node_plambda;
        nexec = 0 as libc::c_int;
        while !plmbd.is_null() {
            tmp___2 = pattern_match(strm, &mut c, (*plmbd).pat, argc, argv);
            if tmp___2 == 0 as libc::c_int {
                if !((*plmbd).cond).is_null() {
                    n = exec_expr(strm, &mut c, (*plmbd).cond, &mut cond);
                    if n == 0 as libc::c_int {
                        tmp___1 = strm_value_bool(cond);
                        if tmp___1 != 0 {
                            nexec += 1;
                            n = exec_expr(strm, &mut c, (*plmbd).body, ret);
                            break;
                        }
                    }
                } else {
                    nexec += 1;
                    n = exec_expr(strm, &mut c, (*plmbd).body, ret);
                    break;
                }
            }
            c.env = 0 as *mut libc::c_void;
            plmbd = (*plmbd).next as *mut node_plambda;
        }
        if nexec == 0 as libc::c_int {
            strm_raise(strm, b"match failure\0" as *const u8 as *const libc::c_char);
            current_block = 10681933697602260671;
        } else {
            current_block = 721385680381463314;
        }
    } else {
        return 1 as libc::c_int
    }
    match current_block {
        10681933697602260671 => {
            if !strm.is_null() {
                if !((*strm).exc).is_null() {
                    (*(*strm).exc).fname = (*(*lambda).body).fname;
                    (*(*strm).exc).lineno = (*(*lambda).body).lineno;
                }
            }
            return 1 as libc::c_int;
        }
        _ => {
            if n == 1 as libc::c_int {
                if !strm.is_null() {
                    exc = (*strm).exc;
                    if !exc.is_null() {
                        if (*exc).type_0 == 1 as libc::c_int {
                            *ret = (*exc).arg;
                            return 0 as libc::c_int;
                        }
                    }
                }
            }
            return n;
        }
    };
}
unsafe extern "C" fn genfunc_new(
    mut state: *mut strm_state,
    mut id: strm_string,
) -> *mut strm_genfunc {
    let mut gf: *mut strm_genfunc = 0 as *mut strm_genfunc;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<strm_genfunc>() as libc::c_ulong);
    gf = tmp as *mut strm_genfunc;
    if gf.is_null() {
        return 0 as *mut libc::c_void as *mut strm_genfunc;
    }
    (*gf).type_0 = STRM_PTR_GENFUNC;
    (*gf).state = state;
    (*gf).id = id;
    return gf;
}
pub unsafe extern "C" fn strm_funcall(
    mut strm: *mut strm_stream,
    mut func: strm_value,
    mut argc: libc::c_int,
    mut argv: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: strm_cfunc = None;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut gf: *mut strm_genfunc = 0 as *mut strm_genfunc;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    match func & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18445336698825998336 => {
            tmp = strm_value_cfunc(func);
            tmp___0 = (Some(tmp.expect("non-null function pointer")))
                .expect("non-null function pointer")(strm, argc, argv, ret);
            return tmp___0;
        }
        18443366373989023744 => {
            tmp___1 = ary_get(strm, func, argc, argv, ret);
            return tmp___1;
        }
        18445899648779419648 => {
            tmp___5 = strm_ptr_tag_p(func, STRM_PTR_GENFUNC);
            if tmp___5 != 0 {
                gf = (func & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                    as intptr_t as *mut libc::c_void as *mut strm_genfunc;
                tmp___2 = exec_call(strm, (*gf).state, (*gf).id, argc, argv, ret);
                return tmp___2;
            } else {
                tmp___4 = strm_ptr_tag_p(func, STRM_PTR_LAMBDA);
                if tmp___4 != 0 {
                    tmp___3 = lambda_call(strm, func, argc, argv, ret);
                    return tmp___3;
                }
            }
        }
        _ => {}
    }
    strm_raise(strm, b"not a function\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
unsafe extern "C" fn exec_call(
    mut strm: *mut strm_stream,
    mut state: *mut strm_state,
    mut name: strm_string,
    mut argc: libc::c_int,
    mut argv: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    let mut m: strm_value = 0;
    let mut ns: *mut strm_state = 0 as *mut strm_state;
    let mut tmp: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    n = 1 as libc::c_int;
    if argc > 0 as libc::c_int {
        tmp = strm_value_ns(*argv.offset(0 as libc::c_int as isize));
        ns = tmp;
        if !ns.is_null() {
            n = strm_var_get(ns, name, &mut m);
            if n == 1 as libc::c_int {
                if argc > 0 as libc::c_int {
                    tmp___0 = strm_array_p(*argv.offset(0 as libc::c_int as isize));
                    if tmp___0 != 0 {
                        m = name;
                        n = ary_get(
                            strm,
                            *argv.offset(0 as libc::c_int as isize),
                            1 as libc::c_int,
                            &mut m,
                            ret,
                        );
                        if n == 0 as libc::c_int {
                            if argc == 1 as libc::c_int {
                                return 0 as libc::c_int;
                            }
                        }
                        m = *ret;
                    }
                }
            }
        }
    }
    if n == 1 as libc::c_int {
        n = strm_var_get(state, name, &mut m);
    }
    if n == 0 as libc::c_int {
        tmp___1 = strm_funcall(strm, m, argc, argv, ret);
        return tmp___1;
    }
    strm_raise(strm, b"function not found\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
unsafe extern "C" fn ary_headers(
    mut headers: *mut node_string_0,
    mut len: strm_int,
) -> strm_array {
    let mut ary: strm_array = 0;
    let mut tmp: strm_array = 0;
    let mut p: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i: strm_int = 0;
    tmp = strm_ary_new(0 as *mut libc::c_void as *const strm_value, len);
    ary = tmp;
    tmp___0 = strm_ary_struct(ary);
    p = (*tmp___0).ptr;
    i = 0 as libc::c_int;
    while i < len {
        *p.offset(i as isize) = node_to_sym(*headers.offset(i as isize));
        i += 1;
    }
    return ary;
}
unsafe extern "C" fn exec_expr(
    mut strm: *mut strm_stream,
    mut state: *mut strm_state,
    mut np: *mut node,
    mut val: *mut strm_value,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    let mut ns: *mut node_ns = 0 as *mut node_ns;
    let mut name: strm_string = 0;
    let mut tmp: strm_string = 0;
    let mut s: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___0: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___1: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___2: libc::c_int = 0;
    let mut ns___0: *mut node_import = 0 as *mut node_import;
    let mut s___0: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___3: strm_string = 0;
    let mut tmp___4: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___5: strm_value = 0;
    let mut i: libc::c_int = 0;
    let mut n___0: libc::c_int = 0;
    let mut v0: *mut node_array = 0 as *mut node_array;
    let mut tmp___6: strm_value = 0;
    let mut nlet: *mut node_let = 0 as *mut node_let;
    let mut tmp___7: strm_string = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut v0___0: *mut node_array = 0 as *mut node_array;
    let mut arr: strm_array = 0;
    let mut tmp___9: strm_array = 0;
    let mut ptr: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___10: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut splat: libc::c_int = 0;
    let mut i___0: libc::c_int = 0;
    let mut s___1: *mut node_splat = 0 as *mut node_splat;
    let mut tmp___11: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut i___1: libc::c_int = 0;
    let mut a: strm_array = 0;
    let mut tmp___12: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut nptr: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___13: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i___2: libc::c_int = 0;
    let mut a___0: strm_array = 0;
    let mut alen: libc::c_int = 0;
    let mut tmp___14: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut aptr: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___15: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut j: libc::c_int = 0;
    let mut tmp___16: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___17: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___18: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut ns___1: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___19: strm_string = 0;
    let mut tmp___20: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___21: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___22: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut ni: *mut node_ident = 0 as *mut node_ident;
    let mut tmp___23: strm_string = 0;
    let mut v: strm_value = 0;
    let mut nif: *mut node_if = 0 as *mut node_if;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: libc::c_int = 0;
    let mut tmp___26: libc::c_int = 0;
    let mut tmp___27: libc::c_int = 0;
    let mut nop: *mut node_op = 0 as *mut node_op;
    let mut args: [strm_value; 2] = [0; 2];
    let mut i___3: libc::c_int = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut tmp___29: libc::c_int = 0;
    let mut tmp___30: strm_string = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut lambda: *mut strm_lambda = 0 as *mut strm_lambda;
    let mut tmp___32: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___33: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ncall: *mut node_call = 0 as *mut node_call;
    let mut i___4: libc::c_int = 0;
    let mut v0___1: *mut node_nodes = 0 as *mut node_nodes;
    let mut args___0: *mut strm_value = 0 as *mut strm_value;
    let mut splat___0: libc::c_int = 0;
    let mut aary: strm_value = 0;
    let mut tmp___34: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___35: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___36: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___37: strm_string = 0;
    let mut ncall___0: *mut node_fcall = 0 as *mut node_fcall;
    let mut i___5: libc::c_int = 0;
    let mut func: strm_value = 0;
    let mut v0___2: *mut node_nodes = 0 as *mut node_nodes;
    let mut args___1: *mut strm_value = 0 as *mut strm_value;
    let mut splat___1: libc::c_int = 0;
    let mut tmp___38: libc::c_int = 0;
    let mut aary___0: strm_value = 0;
    let mut tmp___39: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___40: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___41: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ngf: *mut node_genfunc = 0 as *mut node_genfunc;
    let mut gf: *mut strm_genfunc = 0 as *mut strm_genfunc;
    let mut tmp___42: strm_string = 0;
    let mut nreturn: *mut node_return = 0 as *mut node_return;
    let mut args___2: *mut node_nodes = 0 as *mut node_nodes;
    let mut arg: strm_value = 0;
    let mut ary: strm_array = 0;
    let mut tmp___43: strm_array = 0;
    let mut i___6: strm_int = 0;
    let mut tmp___44: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i___7: libc::c_int = 0;
    let mut v___0: *mut node_nodes = 0 as *mut node_nodes;
    let mut exc: *mut node_error = 0 as *mut node_error;
    let mut n___1: *mut node = 0 as *mut node;
    let mut nt: *mut node_time = 0 as *mut node_time;
    let mut tmp___45: libc::c_int = 0;
    let mut tmp___46: strm_string = 0;
    if np as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 1 as libc::c_int;
    }
    match (*np).type_0 as libc::c_uint {
        29 => {
            ns = np as *mut node_ns;
            tmp = node_to_sym((*ns).name);
            name = tmp;
            tmp___0 = strm_ns_create(state, name);
            s = tmp___0;
            if s.is_null() {
                tmp___1 = strm_ns_get(name);
                if !tmp___1.is_null() {
                    strm_raise(
                        strm,
                        b"namespace already exists\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    strm_raise(
                        strm,
                        b"failed to create namespace\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                return 1 as libc::c_int;
            }
            (*s).flags |= 1 as libc::c_uint;
            if !((*ns).body).is_null() {
                tmp___2 = exec_expr(strm, s, (*ns).body, val);
                return tmp___2;
            }
            return 0 as libc::c_int;
        }
        30 => {
            ns___0 = np as *mut node_import;
            tmp___3 = node_to_sym((*ns___0).name);
            tmp___4 = strm_ns_get(tmp___3);
            s___0 = tmp___4;
            if s___0.is_null() {
                strm_raise(
                    strm,
                    b"no such namespace\0" as *const u8 as *const libc::c_char,
                );
                return 1 as libc::c_int;
            }
            n = strm_env_copy(state, s___0);
            if n != 0 {
                strm_raise(
                    strm,
                    b"failed to import\0" as *const u8 as *const libc::c_char,
                );
                return n;
            }
            return 0 as libc::c_int;
        }
        19 => {
            tmp___5 = strm_nil_value();
            strm_set_exc(strm, 2 as libc::c_int, tmp___5);
            return 1 as libc::c_int;
        }
        18 => {
            v0 = (*(np as *mut node_emit)).emit as *mut node_array;
            if v0.is_null() {
                tmp___6 = strm_nil_value();
                strm_emit(
                    strm,
                    tmp___6,
                    ::std::mem::transmute::<
                        *mut libc::c_void,
                        Option::<
                            unsafe extern "C" fn(
                                *mut strm_stream,
                                strm_value,
                            ) -> libc::c_int,
                        >,
                    >(0 as *mut libc::c_void),
                );
            } else {
                i = 0 as libc::c_int;
                while i < (*v0).len {
                    n___0 = exec_expr(
                        strm,
                        state,
                        *((*v0).data).offset(i as isize),
                        val,
                    );
                    if n___0 != 0 {
                        return n___0;
                    }
                    strm_emit(
                        strm,
                        *val,
                        ::std::mem::transmute::<
                            *mut libc::c_void,
                            Option::<
                                unsafe extern "C" fn(
                                    *mut strm_stream,
                                    strm_value,
                                ) -> libc::c_int,
                            >,
                        >(0 as *mut libc::c_void),
                    );
                    i += 1;
                }
            }
            return 0 as libc::c_int;
        }
        16 => {
            nlet = np as *mut node_let;
            n = exec_expr(strm, state, (*nlet).rhs, val);
            if n != 0 {
                strm_raise(
                    strm,
                    b"failed to assign\0" as *const u8 as *const libc::c_char,
                );
                return n;
            }
            tmp___7 = node_to_sym((*nlet).lhs);
            tmp___8 = strm_var_set(state, tmp___7, *val);
            return tmp___8;
        }
        27 => {
            v0___0 = np as *mut node_array;
            tmp___9 = strm_ary_new(
                0 as *mut libc::c_void as *const strm_value,
                (*v0___0).len,
            );
            arr = tmp___9;
            tmp___10 = strm_ary_struct(arr);
            ptr = (*tmp___10).ptr;
            splat = 0 as libc::c_int;
            i___0 = 0 as libc::c_int;
            while i___0 < (*v0___0).len {
                if (**((*v0___0).data).offset(i___0 as isize)).type_0 as libc::c_uint
                    == 14 as libc::c_uint
                {
                    s___1 = *((*v0___0).data).offset(i___0 as isize) as *mut node_splat;
                    n = exec_expr(
                        strm,
                        state,
                        (*s___1).node,
                        ptr.offset(i___0 as isize),
                    );
                    if n != 0 {
                        return n;
                    }
                    tmp___11 = strm_array_p(*ptr.offset(i___0 as isize));
                    if tmp___11 == 0 {
                        strm_raise(
                            strm,
                            b"splat requires array\0" as *const u8 as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                    splat = 1 as libc::c_int;
                } else {
                    n = exec_expr(
                        strm,
                        state,
                        *((*v0___0).data).offset(i___0 as isize),
                        ptr.offset(i___0 as isize),
                    );
                    if n != 0 {
                        return n;
                    }
                }
                i___0 += 1;
            }
            if splat != 0 {
                len = (*v0___0).len;
                if !((*v0___0).headers).is_null() {
                    strm_raise(
                        strm,
                        b"label(s) and splat(s) in an array\0" as *const u8
                            as *const libc::c_char,
                    );
                    return 1 as libc::c_int;
                }
                i___1 = 0 as libc::c_int;
                while i___1 < (*v0___0).len {
                    if (**((*v0___0).data).offset(i___1 as isize)).type_0 as libc::c_uint
                        == 14 as libc::c_uint
                    {
                        a = *ptr.offset(i___1 as isize);
                        tmp___12 = strm_ary_struct(a);
                        len += (*tmp___12).len - 1 as libc::c_int;
                    }
                    i___1 += 1;
                }
                if len > (*v0___0).len {
                    arr = strm_ary_new(0 as *mut libc::c_void as *const strm_value, len);
                    tmp___13 = strm_ary_struct(arr);
                    nptr = (*tmp___13).ptr;
                    i___2 = 0 as libc::c_int;
                    while i___2 < (*v0___0).len {
                        if (**((*v0___0).data).offset(i___2 as isize)).type_0
                            as libc::c_uint == 14 as libc::c_uint
                        {
                            a___0 = *ptr.offset(i___2 as isize);
                            tmp___14 = strm_ary_struct(a___0);
                            alen = (*tmp___14).len;
                            tmp___15 = strm_ary_struct(a___0);
                            aptr = (*tmp___15).ptr;
                            j = 0 as libc::c_int;
                            while j < alen {
                                tmp___16 = nptr;
                                nptr = nptr.offset(1);
                                *tmp___16 = *aptr.offset(j as isize);
                                j += 1;
                            }
                        } else {
                            tmp___17 = nptr;
                            nptr = nptr.offset(1);
                            *tmp___17 = *ptr.offset(i___2 as isize);
                        }
                        i___2 += 1;
                    }
                }
            } else if !((*v0___0).headers).is_null() {
                tmp___18 = strm_ary_struct(arr);
                (*tmp___18).headers = ary_headers((*v0___0).headers, (*v0___0).len);
            }
            if !((*v0___0).ns).is_null() {
                tmp___19 = node_to_sym((*v0___0).ns);
                tmp___20 = strm_ns_get(tmp___19);
                ns___1 = tmp___20;
                if (*ns___1).flags & 1 as libc::c_uint == 0 {
                    strm_raise(
                        strm,
                        b"instantiating primitive class\0" as *const u8
                            as *const libc::c_char,
                    );
                    return 1 as libc::c_int;
                }
                tmp___21 = strm_ary_struct(arr);
                (*tmp___21).ns = ns___1;
            } else {
                tmp___22 = strm_ary_struct(arr);
                (*tmp___22).ns = 0 as *mut strm_state;
            }
            *val = arr;
            return 0 as libc::c_int;
        }
        15 => {
            ni = np as *mut node_ident;
            tmp___23 = node_to_sym((*ni).name);
            n = strm_var_get(state, tmp___23, val);
            if n != 0 {
                strm_raise(
                    strm,
                    b"failed to reference variable\0" as *const u8 as *const libc::c_char,
                );
            }
            return n;
        }
        17 => {
            nif = np as *mut node_if;
            n = exec_expr(strm, state, (*nif).cond, &mut v);
            if n != 0 {
                return n;
            }
            tmp___26 = strm_bool_p(v);
            if tmp___26 != 0 {
                tmp___27 = strm_value_bool(v);
                if tmp___27 != 0 {
                    tmp___24 = exec_expr(strm, state, (*nif).then, val);
                    return tmp___24;
                }
            }
            if (*nif).opt_else as libc::c_ulong
                != 0 as *mut libc::c_void as libc::c_ulong
            {
                tmp___25 = exec_expr(strm, state, (*nif).opt_else, val);
                return tmp___25;
            } else {
                *val = strm_nil_value();
                return 0 as libc::c_int;
            }
        }
        23 => {
            nop = np as *mut node_op;
            i___3 = 0 as libc::c_int;
            if !((*nop).lhs).is_null() {
                tmp___28 = i___3;
                i___3 += 1;
                n = exec_expr(
                    strm,
                    state,
                    (*nop).lhs,
                    &mut *args.as_mut_ptr().offset(tmp___28 as isize),
                );
                if n != 0 {
                    return n;
                }
            }
            if !((*nop).rhs).is_null() {
                tmp___29 = i___3;
                i___3 += 1;
                n = exec_expr(
                    strm,
                    state,
                    (*nop).rhs,
                    &mut *args.as_mut_ptr().offset(tmp___29 as isize),
                );
                if n != 0 {
                    return n;
                }
            }
            tmp___30 = node_to_sym((*nop).op);
            tmp___31 = exec_call(strm, state, tmp___30, i___3, args.as_mut_ptr(), val);
            return tmp___31;
        }
        10 | 9 => {
            tmp___32 = malloc(::std::mem::size_of::<strm_lambda>() as libc::c_ulong);
            lambda = tmp___32 as *mut strm_lambda;
            if lambda.is_null() {
                return 1 as libc::c_int;
            }
            tmp___33 = malloc(::std::mem::size_of::<strm_state>() as libc::c_ulong);
            (*lambda).state = tmp___33 as *mut strm_state;
            if ((*lambda).state).is_null() {
                return 1 as libc::c_int;
            }
            *(*lambda).state = *state;
            (*lambda).type_0 = STRM_PTR_LAMBDA;
            (*lambda).body = np as *mut node_lambda;
            *val = strm_ptr_value(lambda as *mut libc::c_void);
            return 0 as libc::c_int;
        }
        24 => {
            ncall = np as *mut node_call;
            v0___1 = (*ncall).args as *mut node_nodes;
            splat___0 = 0 as libc::c_int;
            i___4 = 0 as libc::c_int;
            while i___4 < (*v0___1).len {
                if (**((*v0___1).data).offset(i___4 as isize)).type_0 as libc::c_uint
                    == 14 as libc::c_uint
                {
                    splat___0 = 1 as libc::c_int;
                    break;
                } else {
                    i___4 += 1;
                }
            }
            if splat___0 != 0 {
                n = exec_expr(strm, state, (*ncall).args, &mut aary);
                tmp___34 = strm_ary_struct(aary);
                args___0 = (*tmp___34).ptr;
                tmp___35 = strm_ary_struct(aary);
                i___4 = (*tmp___35).len;
            } else {
                tmp___36 = malloc(
                    (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                        .wrapping_mul((*v0___1).len as libc::c_ulong),
                );
                args___0 = tmp___36 as *mut strm_value;
                i___4 = 0 as libc::c_int;
                while i___4 < (*v0___1).len {
                    n = exec_expr(
                        strm,
                        state,
                        *((*v0___1).data).offset(i___4 as isize),
                        args___0.offset(i___4 as isize),
                    );
                    if n == 1 as libc::c_int {
                        free(args___0 as *mut libc::c_void);
                        return n;
                    }
                    i___4 += 1;
                }
            }
            tmp___37 = node_to_sym((*ncall).ident);
            n = exec_call(strm, state, tmp___37, i___4, args___0, val);
            if splat___0 == 0 {
                free(args___0 as *mut libc::c_void);
            }
            return n;
        }
        25 => {
            ncall___0 = np as *mut node_fcall;
            v0___2 = (*ncall___0).args as *mut node_nodes;
            splat___1 = 0 as libc::c_int;
            tmp___38 = exec_expr(strm, state, (*ncall___0).func, &mut func);
            if tmp___38 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
            i___5 = 0 as libc::c_int;
            while i___5 < (*v0___2).len {
                if (**((*v0___2).data).offset(i___5 as isize)).type_0 as libc::c_uint
                    == 14 as libc::c_uint
                {
                    splat___1 = 1 as libc::c_int;
                    break;
                } else {
                    i___5 += 1;
                }
            }
            if splat___1 != 0 {
                n = exec_expr(strm, state, (*ncall___0).args, &mut aary___0);
                tmp___39 = strm_ary_struct(aary___0);
                args___1 = (*tmp___39).ptr;
                tmp___40 = strm_ary_struct(aary___0);
                i___5 = (*tmp___40).len;
            } else {
                tmp___41 = malloc(
                    (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                        .wrapping_mul((*v0___2).len as libc::c_ulong),
                );
                args___1 = tmp___41 as *mut strm_value;
                i___5 = 0 as libc::c_int;
                while i___5 < (*v0___2).len {
                    n = exec_expr(
                        strm,
                        state,
                        *((*v0___2).data).offset(i___5 as isize),
                        args___1.offset(i___5 as isize),
                    );
                    if n == 1 as libc::c_int {
                        free(args___1 as *mut libc::c_void);
                        return n;
                    }
                    i___5 += 1;
                }
            }
            n = strm_funcall(strm, func, i___5, args___1, val);
            if splat___1 == 0 {
                free(args___1 as *mut libc::c_void);
            }
            return n;
        }
        26 => {
            ngf = np as *mut node_genfunc;
            tmp___42 = node_to_str((*ngf).id);
            gf = genfunc_new(state, tmp___42);
            if gf.is_null() {
                return 1 as libc::c_int;
            }
            *val = strm_ptr_value(gf as *mut libc::c_void);
            return 0 as libc::c_int;
        }
        20 => {
            nreturn = np as *mut node_return;
            args___2 = (*nreturn).rv as *mut node_nodes;
            if args___2.is_null() {
                arg = strm_nil_value();
            } else {
                match (*args___2).len {
                    0 => {
                        arg = strm_nil_value();
                    }
                    1 => {
                        n = exec_expr(
                            strm,
                            state,
                            *((*args___2).data).offset(0 as libc::c_int as isize),
                            &mut arg,
                        );
                        if n != 0 {
                            return n;
                        }
                    }
                    _ => {
                        tmp___43 = strm_ary_new(
                            0 as *mut libc::c_void as *const strm_value,
                            (*args___2).len,
                        );
                        ary = tmp___43;
                        i___6 = 0 as libc::c_int;
                        while i___6 < (*args___2).len {
                            tmp___44 = strm_ary_struct(ary);
                            n = exec_expr(
                                strm,
                                state,
                                *((*args___2).data).offset(i___6 as isize),
                                ((*tmp___44).ptr).offset(i___6 as isize),
                            );
                            if n != 0 {
                                return n;
                            }
                            i___6 += 1;
                        }
                        arg = ary;
                    }
                }
            }
            strm_set_exc(strm, 1 as libc::c_int, arg);
            return 1 as libc::c_int;
        }
        28 => {
            v___0 = np as *mut node_nodes;
            i___7 = 0 as libc::c_int;
            while i___7 < (*v___0).len {
                n = exec_expr(strm, state, *((*v___0).data).offset(i___7 as isize), val);
                if n != 0 {
                    if !strm.is_null() {
                        exc = (*strm).exc;
                        if exc as libc::c_ulong
                            != 0 as *mut libc::c_void as libc::c_ulong
                        {
                            n___1 = *((*v___0).data).offset(i___7 as isize);
                            (*exc).fname = (*n___1).fname;
                            (*exc).lineno = (*n___1).lineno;
                        }
                    }
                    return n;
                }
                i___7 += 1;
            }
            return 0 as libc::c_int;
        }
        0 => {
            *val = strm_int_value((*(np as *mut node_int)).value);
            return 0 as libc::c_int;
        }
        1 => {
            *val = strm_float_value((*(np as *mut node_float)).value);
            return 0 as libc::c_int;
        }
        2 => {
            nt = np as *mut node_time;
            *val = strm_time_new((*nt).sec, (*nt).usec, (*nt).utc_offset);
            tmp___45 = strm_nil_p(*val);
            if tmp___45 != 0 {
                return 1 as libc::c_int;
            }
            return 0 as libc::c_int;
        }
        5 => {
            *val = strm_bool_value((*(np as *mut node_bool)).value);
            return 0 as libc::c_int;
        }
        4 => {
            *val = strm_nil_value();
            return 0 as libc::c_int;
        }
        3 => {
            tmp___46 = node_to_str((*(np as *mut node_str)).value);
            *val = tmp___46;
            return 0 as libc::c_int;
        }
        _ => {
            strm_raise(strm, b"unknown node\0" as *const u8 as *const libc::c_char);
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn exec_cputs(
    mut strm: *mut strm_stream,
    mut out: *mut FILE,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut s: strm_string = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    i = 0 as libc::c_int;
    while i < argc {
        if i != 0 as libc::c_int {
            tmp = strm_string_p(*args.offset((i - 1 as libc::c_int) as isize));
            if tmp == 0 {
                fputs(b" \0" as *const u8 as *const libc::c_char, out);
            }
        }
        s = strm_to_str(*args.offset(i as isize));
        tmp___0 = strm_str_len(s);
        tmp___1 = strm_strp_ptr(&mut s);
        fwrite(
            tmp___1 as *const libc::c_void,
            tmp___0 as size_t,
            1 as libc::c_int as size_t,
            out,
        );
        i += 1;
    }
    fputs(b"\n\0" as *const u8 as *const libc::c_char, out);
    *ret = strm_nil_value();
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_puts(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_cputs(strm, stdout, argc, args, ret);
    return tmp;
}
pub unsafe extern "C" fn strm_eprint(mut strm: *mut strm_stream) {
    let mut v: strm_value = 0;
    let mut exc: *mut node_error = 0 as *mut node_error;
    exc = (*strm).exc;
    if exc.is_null() {
        return;
    }
    if (*exc).type_0 == 2 as libc::c_int {
        return;
    }
    if !((*exc).fname).is_null() {
        fprintf(
            stderr,
            b"%s:%d:\0" as *const u8 as *const libc::c_char,
            (*exc).fname,
            (*exc).lineno,
        );
    }
    exec_cputs(strm, stderr, 1 as libc::c_int, &mut (*exc).arg, &mut v);
    strm_clear_exc(strm);
}
unsafe extern "C" fn exec_fread(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    let mut path: strm_string = 0;
    let mut buf: [libc::c_char; 7] = [0; 7];
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"S\0" as *const u8 as *const libc::c_char,
        &mut path as *mut strm_string,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_str_cstr(path, buf.as_mut_ptr());
    fd = open(tmp___0, 0 as libc::c_int);
    if fd < 0 as libc::c_int {
        strm_raise(strm, b"fread() failed\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    *ret = strm_io_new(fd, 1 as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_fwrite(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    let mut path: strm_string = 0;
    let mut buf: [libc::c_char; 7] = [0; 7];
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"S\0" as *const u8 as *const libc::c_char,
        &mut path as *mut strm_string,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_str_cstr(path, buf.as_mut_ptr());
    fd = open(tmp___0, 65 as libc::c_int, 420 as libc::c_int);
    if fd < 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = strm_io_new(fd, 2 as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_exit(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut estatus: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    estatus = 0 as libc::c_int;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"|i\0" as *const u8 as *const libc::c_char,
        &mut estatus as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    exit(estatus);
}
unsafe extern "C" fn exec_match(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut func: strm_value = 0;
    let mut lambda: *mut strm_lambda = 0 as *mut strm_lambda;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    if argc < 2 as libc::c_int {
        strm_raise(
            strm,
            b"wrong number of arguments\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    func = *args.offset((argc - 1 as libc::c_int) as isize);
    tmp___0 = strm_ptr_tag_p(func, STRM_PTR_LAMBDA);
    if tmp___0 != 0 {
        tmp = strm_value_ptr(func, STRM_PTR_LAMBDA);
        lambda = tmp as *mut strm_lambda;
        if (*(*lambda).body).type_0 as libc::c_uint == 9 as libc::c_uint {
            strm_raise(
                strm,
                b"not a case function\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    }
    tmp___1 = strm_funcall(strm, func, argc - 1 as libc::c_int, args, ret);
    return tmp___1;
}
pub unsafe extern "C" fn strm_raise(
    mut strm: *mut strm_stream,
    mut msg: *const libc::c_char,
) {
    let mut tmp: size_t = 0;
    let mut tmp___0: strm_string = 0;
    if strm.is_null() {
        return;
    }
    tmp = strlen(msg);
    tmp___0 = strm_str_new(msg, tmp as strm_int);
    strm_set_exc(strm, 0 as libc::c_int, tmp___0);
}
unsafe extern "C" fn node_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: strm_value = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: strm_value = 0;
    let mut tmp___7: strm_value = 0;
    let mut tmp___8: strm_value = 0;
    let mut tmp___9: strm_value = 0;
    let mut tmp___10: strm_value = 0;
    strm_init(state);
    tmp = strm_io_new(0 as libc::c_int, 1 as libc::c_int);
    strm_var_def(state, b"stdin\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_io_new(1 as libc::c_int, 2 as libc::c_int);
    strm_var_def(state, b"stdout\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_io_new(2 as libc::c_int, 2 as libc::c_int);
    strm_var_def(state, b"stderr\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            exec_puts
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"puts\0" as *const u8 as *const libc::c_char, tmp___2);
    tmp___3 = strm_cfunc_value(
        Some(
            exec_puts
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"print\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = strm_cfunc_value(
        Some(
            exec_eq
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"==\0" as *const u8 as *const libc::c_char, tmp___4);
    tmp___5 = strm_cfunc_value(
        Some(
            exec_neq
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"!=\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = strm_cfunc_value(
        Some(
            exec_bar
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"|\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = strm_cfunc_value(
        Some(
            exec_fread
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"fread\0" as *const u8 as *const libc::c_char, tmp___7);
    tmp___8 = strm_cfunc_value(
        Some(
            exec_fwrite
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"fwrite\0" as *const u8 as *const libc::c_char, tmp___8);
    tmp___9 = strm_cfunc_value(
        Some(
            exec_exit
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"exit\0" as *const u8 as *const libc::c_char, tmp___9);
    tmp___10 = strm_cfunc_value(
        Some(
            exec_match
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"match\0" as *const u8 as *const libc::c_char, tmp___10);
}
static mut top_state: strm_state = {
    let mut init = strm_state {
        env: 0 as *const libc::c_void as *mut libc::c_void,
        prev: 0 as *const strm_state as *mut strm_state,
        flags: 0 as libc::c_uint,
    };
    init
};
static mut top_strm: strm_stream = {
    let mut init = strm_stream {
        type_0: STRM_PTR_STREAM,
        flags: 0 as libc::c_uint,
        mode: strm_producer,
        start_func: None,
        close_func: None,
        data: 0 as *const libc::c_void as *mut libc::c_void,
        dst: 0 as *const strm_stream as *mut strm_stream,
        rest: 0 as *const *mut strm_stream as *mut *mut strm_stream,
        rsize: 0 as libc::c_ulong,
        rcapa: 0 as libc::c_ulong,
        exc: 0 as *const node_error as *mut node_error,
        refcnt: 0 as libc::c_int,
        queue: 0 as *const strm_queue as *mut strm_queue,
        excl: 0 as libc::c_int,
    };
    init
};
pub unsafe extern "C" fn node_run(mut p: *mut parser_state) -> libc::c_int {
    let mut v: strm_value = 0;
    let mut exc: *mut node_error = 0 as *mut node_error;
    node_init(&mut top_state);
    exec_expr(&mut top_strm, &mut top_state, (*p).lval as *mut node, &mut v);
    exc = top_strm.exc;
    if exc as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        if (*exc).type_0 != 1 as libc::c_int {
            strm_eprint(&mut top_strm);
        }
        strm_clear_exc(&mut top_strm);
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn node_stop() {}
unsafe extern "C" fn blk_exec(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut lambda: *mut strm_lambda = 0 as *mut strm_lambda;
    let mut ret: strm_value = 0;
    let mut tmp: strm_value = 0;
    let mut args: *mut node_args = 0 as *mut node_args;
    let mut exc: *mut node_error = 0 as *mut node_error;
    let mut n: libc::c_int = 0;
    let mut c: strm_state = strm_state {
        env: 0 as *mut libc::c_void,
        prev: 0 as *mut strm_state,
        flags: 0,
    };
    let mut tmp___1: strm_string = 0;
    lambda = (*strm).data as *mut strm_lambda;
    tmp = strm_nil_value();
    ret = tmp;
    args = (*(*lambda).body).args as *mut node_args;
    c.env = 0 as *mut libc::c_void;
    c.prev = 0 as *mut strm_state;
    c.flags = 0 as libc::c_uint;
    c.prev = (*lambda).state;
    if !args.is_null() {
        if !((*args).len == 1 as libc::c_int) {
            __assert_fail(
                b"args->len == 1\0" as *const u8 as *const libc::c_char,
                b"exec.c\0" as *const u8 as *const libc::c_char,
                1100 as libc::c_uint,
                b"blk_exec\0" as *const u8 as *const libc::c_char,
            );
        }
        tmp___1 = node_to_sym(*((*args).data).offset(0 as libc::c_int as isize));
        strm_var_set(&mut c, tmp___1, data);
    }
    n = exec_expr(strm, &mut c, (*(*lambda).body).body, &mut ret);
    exc = (*strm).exc;
    if !exc.is_null() {
        if (*exc).type_0 == 1 as libc::c_int {
            ret = (*exc).arg;
            strm_clear_exc(strm);
        } else {
            if strm_option_verbose != 0 {
                strm_eprint(strm);
            }
            return 1 as libc::c_int;
        }
    }
    if n != 0 {
        return 1 as libc::c_int;
    }
    strm_emit(
        strm,
        ret,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn arr_exec(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut arrd: *mut array_data = 0 as *mut array_data;
    let mut tmp: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___1: libc::c_int = 0;
    arrd = (*strm).data as *mut array_data;
    tmp = strm_ary_struct((*arrd).arr);
    if (*arrd).n == (*tmp).len {
        strm_stream_close(strm);
        return 0 as libc::c_int;
    }
    tmp___0 = strm_ary_struct((*arrd).arr);
    tmp___1 = (*arrd).n;
    (*arrd).n += 1;
    strm_emit(
        strm,
        *((*tmp___0).ptr).offset(tmp___1 as isize),
        Some(
            arr_exec as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn cfunc_exec(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut ret: strm_value = 0;
    let mut func: Option::<
        unsafe extern "C" fn(
            *mut strm_stream,
            libc::c_int,
            *mut strm_value,
            *mut strm_value,
        ) -> libc::c_int,
    > = None;
    let mut tmp: libc::c_int = 0;
    func = ::std::mem::transmute::<
        *mut libc::c_void,
        Option::<
            unsafe extern "C" fn(
                *mut strm_stream,
                libc::c_int,
                *mut strm_value,
                *mut strm_value,
            ) -> libc::c_int,
        >,
    >((*strm).data);
    tmp = (Some(func.expect("non-null function pointer")))
        .expect(
            "non-null function pointer",
        )(strm, 1 as libc::c_int, &mut data, &mut ret);
    if tmp == 0 as libc::c_int {
        strm_emit(
            strm,
            ret,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
static mut io_worker: pthread_t = 0;
static mut io_wait_num: libc::c_int = 0 as libc::c_int;
static mut epoll_fd: libc::c_int = 0;
unsafe extern "C" fn io_task(
    mut strm: *mut strm_stream,
    mut func: Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
) -> *mut strm_task {
    let mut tmp: strm_value = 0;
    let mut tmp___0: *mut strm_task = 0 as *mut strm_task;
    tmp = strm_foreign_value(strm as *mut libc::c_void);
    tmp___0 = strm_task_new(func, tmp);
    return tmp___0;
}
unsafe extern "C" fn io_task_add(mut task: *mut strm_task) {
    let mut strm: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strm_value_foreign((*task).data);
    strm = tmp as *mut strm_stream;
    (*task).data = strm_nil_value();
    strm_task_add(strm, task);
}
unsafe extern "C" fn io_push(
    mut fd: libc::c_int,
    mut strm: *mut strm_stream,
    mut cb: Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
) -> libc::c_int {
    let mut ev: epoll_event = epoll_event {
        events: 0,
        data: epoll_data {
            ptr: 0 as *mut libc::c_void,
        },
    };
    let mut tmp: *mut strm_task = 0 as *mut strm_task;
    let mut tmp___0: libc::c_int = 0;
    ev.events = 0 as libc::c_int as uint32_t;
    ev.data.ptr = 0 as *mut libc::c_void;
    ev.events = 1073741825 as libc::c_int as uint32_t;
    tmp = io_task(strm, cb);
    ev.data.ptr = tmp as *mut libc::c_void;
    tmp___0 = epoll_ctl(epoll_fd, 1 as libc::c_int, fd, &mut ev);
    return tmp___0;
}
unsafe extern "C" fn io_kick(
    mut fd: libc::c_int,
    mut strm: *mut strm_stream,
    mut cb: Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
) -> libc::c_int {
    let mut ev: epoll_event = epoll_event {
        events: 0,
        data: epoll_data {
            ptr: 0 as *mut libc::c_void,
        },
    };
    let mut tmp: *mut strm_task = 0 as *mut strm_task;
    let mut tmp___0: libc::c_int = 0;
    ev.events = 1073741825 as libc::c_int as uint32_t;
    tmp = io_task(strm, cb);
    ev.data.ptr = tmp as *mut libc::c_void;
    tmp___0 = epoll_ctl(epoll_fd, 3 as libc::c_int, fd, &mut ev);
    return tmp___0;
}
unsafe extern "C" fn io_pop(mut fd: libc::c_int) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = epoll_ctl(
        epoll_fd,
        2 as libc::c_int,
        fd,
        0 as *mut libc::c_void as *mut epoll_event,
    );
    return tmp;
}
unsafe extern "C" fn io_loop(mut d: *mut libc::c_void) -> *mut libc::c_void {
    let mut events: [epoll_event; 10] = [epoll_event {
        events: 0,
        data: epoll_data {
            ptr: 0 as *mut libc::c_void,
        },
    }; 10];
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    loop {
        n = epoll_wait(
            epoll_fd,
            events.as_mut_ptr(),
            10 as libc::c_int,
            -(1 as libc::c_int),
        );
        if n < 0 as libc::c_int {
            return 0 as *mut libc::c_void;
        }
        i = 0 as libc::c_int;
        while i < n {
            io_task_add(events[i as usize].data.ptr as *mut strm_task);
            i += 1;
        }
    };
}
pub unsafe extern "C" fn strm_init_io_loop() {
    epoll_fd = epoll_create(10 as libc::c_int);
    if !(epoll_fd >= 0 as libc::c_int) {
        __assert_fail(
            b"epoll_fd >= 0\0" as *const u8 as *const libc::c_char,
            b"io.c\0" as *const u8 as *const libc::c_char,
            106 as libc::c_uint,
            b"strm_init_io_loop\0" as *const u8 as *const libc::c_char,
        );
    }
    pthread_create(
        &mut io_worker as *mut pthread_t,
        0 as *mut libc::c_void as *const pthread_attr_t,
        Some(io_loop as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void),
        0 as *mut libc::c_void,
    );
}
pub unsafe extern "C" fn strm_io_start_read(
    mut strm: *mut strm_stream,
    mut fd: libc::c_int,
    mut cb: Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
) {
    let mut tmp: libc::c_int = 0;
    tmp = io_push(fd, strm, cb);
    if tmp == 0 as libc::c_int {
        io_wait_num += 1;
    }
}
unsafe extern "C" fn strm_io_stop(mut strm: *mut strm_stream, mut fd: libc::c_int) {
    if (*strm).flags & 1 as libc::c_uint == 0 as libc::c_uint {
        io_wait_num -= 1;
        io_pop(fd);
    }
    strm_stream_close(strm);
}
pub unsafe extern "C" fn strm_io_emit(
    mut strm: *mut strm_stream,
    mut data: strm_value,
    mut fd: libc::c_int,
    mut cb: Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
) {
    strm_emit(
        strm,
        data,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    io_kick(fd, strm, cb);
}
unsafe extern "C" fn read_str(
    mut beg: *const libc::c_char,
    mut len: strm_int,
) -> strm_value {
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: strm_string = 0;
    tmp = malloc(len as size_t);
    p = tmp as *mut libc::c_char;
    memcpy(p as *mut libc::c_void, beg as *const libc::c_void, len as size_t);
    tmp___0 = strm_str_new(p as *const libc::c_char, len);
    return tmp___0;
}
unsafe extern "C" fn read_cb(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut b: *mut fd_read_buffer = 0 as *mut fd_read_buffer;
    let mut count: strm_int = 0;
    let mut n: strm_int = 0;
    let mut tmp: ssize_t = 0;
    let mut s: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: strm_value = 0;
    b = (*strm).data as *mut fd_read_buffer;
    count = (8192 as libc::c_long - ((*b).end).offset_from((*b).buf) as libc::c_long)
        as strm_int;
    tmp = read((*b).fd, (*b).end as *mut libc::c_void, count as size_t);
    n = tmp as strm_int;
    if n <= 0 as libc::c_int {
        if ((*b).buf as libc::c_ulong) < (*b).end as libc::c_ulong {
            tmp___0 = read_str(
                (*b).beg as *const libc::c_char,
                ((*b).end).offset_from((*b).beg) as libc::c_long as strm_int,
            );
            s = tmp___0;
            tmp___1 = (*b).buf;
            (*b).end = tmp___1;
            (*b).beg = tmp___1;
            strm_io_emit(
                strm,
                s,
                (*b).fd,
                Some(
                    read_cb
                        as unsafe extern "C" fn(
                            *mut strm_stream,
                            strm_value,
                        ) -> libc::c_int,
                ),
            );
        } else {
            strm_io_stop(strm, (*b).fd);
        }
        return 0 as libc::c_int;
    }
    (*b).end = ((*b).end).offset(n as isize);
    tmp___2 = strm_nil_value();
    readline_cb(strm, tmp___2);
    return 0 as libc::c_int;
}
unsafe extern "C" fn readline_cb(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut b: *mut fd_read_buffer = 0 as *mut fd_read_buffer;
    let mut s: strm_value = 0;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: strm_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: strm_value = 0;
    b = (*strm).data as *mut fd_read_buffer;
    len = ((*b).end).offset_from((*b).beg) as libc::c_long as strm_int;
    tmp = memchr((*b).beg as *const libc::c_void, '\n' as i32, len as size_t);
    p = tmp as *mut libc::c_char;
    if !p.is_null() {
        len = p.offset_from((*b).beg) as libc::c_long as strm_int;
    } else if (*strm).flags & 2 as libc::c_uint != 0 {
        if len <= 0 as libc::c_int {
            if (*strm).flags & 4 as libc::c_uint != 0 {
                munmap(
                    (*b).buf as *mut libc::c_void,
                    ((*b).end).offset_from((*b).beg) as libc::c_long as size_t,
                );
            }
            strm_io_stop(strm, (*b).fd);
            return 0 as libc::c_int;
        }
    } else {
        if (len as libc::c_ulong)
            < ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
        {
            memmove(
                (*b).buf as *mut libc::c_void,
                (*b).beg as *const libc::c_void,
                len as size_t,
            );
            (*b).beg = (*b).buf;
            (*b).end = ((*b).beg).offset(len as isize);
        }
        if (*strm).flags & 1 as libc::c_uint != 0 {
            tmp___0 = strm_nil_value();
            strm_task_push(
                strm,
                Some(
                    read_cb
                        as unsafe extern "C" fn(
                            *mut strm_stream,
                            strm_value,
                        ) -> libc::c_int,
                ),
                tmp___0,
            );
        } else {
            io_kick(
                (*b).fd,
                strm,
                Some(
                    read_cb
                        as unsafe extern "C" fn(
                            *mut strm_stream,
                            strm_value,
                        ) -> libc::c_int,
                ),
            );
        }
        return 0 as libc::c_int;
    }
    s = read_str((*b).beg as *const libc::c_char, len);
    (*b).beg = ((*b).beg).offset((len + 1 as libc::c_int) as isize);
    strm_emit(
        strm,
        s,
        Some(
            readline_cb
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn stdio_read(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut b: *mut fd_read_buffer = 0 as *mut fd_read_buffer;
    b = (*strm).data as *mut fd_read_buffer;
    strm_io_start_read(
        strm,
        (*b).fd,
        Some(
            read_cb as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn read_close(
    mut strm: *mut strm_stream,
    mut d: strm_value,
) -> libc::c_int {
    let mut b: *mut fd_read_buffer = 0 as *mut fd_read_buffer;
    b = (*strm).data as *mut fd_read_buffer;
    close((*b).fd);
    free(b as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn strm_readio(mut io: strm_io_0) -> *mut strm_stream {
    let mut cb: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    > = None;
    let mut flags: libc::c_uint = 0;
    let mut buf: *mut fd_read_buffer = 0 as *mut fd_read_buffer;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut st: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut map: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: libc::c_int = 0;
    cb = Some(
        stdio_read as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    );
    flags = 0 as libc::c_uint;
    if (*io).read_stream as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp = malloc(::std::mem::size_of::<fd_read_buffer>() as libc::c_ulong);
        buf = tmp as *mut fd_read_buffer;
        (*io).mode |= 8 as libc::c_int;
        (*buf).fd = (*io).fd;
        (*buf).io = io;
        (*buf).buf = ((*buf).fixed).as_mut_ptr();
        tmp___4 = fstat((*io).fd, &mut st);
        if tmp___4 == 0 as libc::c_int {
            if st.st_mode & 61440 as libc::c_uint == 32768 as libc::c_uint {
                flags |= 1 as libc::c_uint;
                tmp___0 = mmap(
                    0 as *mut libc::c_void,
                    st.st_size as size_t,
                    1 as libc::c_int,
                    2 as libc::c_int,
                    (*buf).fd,
                    0 as libc::c_int as __off_t,
                );
                map = tmp___0;
                if map as libc::c_ulong
                    == -(1 as libc::c_int) as *mut libc::c_void as libc::c_ulong
                {
                    tmp___1 = (*buf).buf;
                    (*buf).end = tmp___1;
                    (*buf).beg = tmp___1;
                } else {
                    tmp___2 = map as *mut libc::c_char;
                    (*buf).beg = tmp___2;
                    (*buf).buf = tmp___2;
                    (*buf).end = map.offset(st.st_size as isize) as *mut libc::c_char;
                    flags |= 2 as libc::c_uint;
                    cb = Some(
                        readline_cb
                            as unsafe extern "C" fn(
                                *mut strm_stream,
                                strm_value,
                            ) -> libc::c_int,
                    );
                }
            } else {
                tmp___3 = (*buf).buf;
                (*buf).end = tmp___3;
                (*buf).beg = tmp___3;
            }
        } else {
            tmp___3 = (*buf).buf;
            (*buf).end = tmp___3;
            (*buf).beg = tmp___3;
        }
        (*io)
            .read_stream = strm_stream_new(
            strm_producer,
            cb,
            Some(
                read_close
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            buf as *mut libc::c_void,
        );
        (*(*io).read_stream).flags |= flags;
    }
    return (*io).read_stream;
}
unsafe extern "C" fn write_cb(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut write_data = 0 as *mut write_data;
    let mut p: strm_string = 0;
    let mut tmp: strm_string = 0;
    let mut buf: [iovec; 2] = [iovec {
        iov_base: 0 as *mut libc::c_void,
        iov_len: 0,
    }; 2];
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: strm_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: ssize_t = 0;
    d = (*strm).data as *mut write_data;
    tmp = strm_to_str(data);
    p = tmp;
    tmp___0 = strm_strp_ptr(&mut p);
    buf[0 as libc::c_int as usize].iov_base = tmp___0 as *mut libc::c_void;
    tmp___1 = strm_str_len(p);
    buf[0 as libc::c_int as usize].iov_len = tmp___1 as size_t;
    buf[1 as libc::c_int as usize]
        .iov_base = b"\n\0" as *const u8 as *const libc::c_char as *mut libc::c_void;
    buf[1 as libc::c_int as usize].iov_len = 1 as libc::c_int as size_t;
    tmp___2 = fileno((*d).f);
    tmp___3 = writev(tmp___2, buf.as_mut_ptr() as *const iovec, 2 as libc::c_int);
    if tmp___3 < 0 as libc::c_long {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn write_close(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut write_data = 0 as *mut write_data;
    let mut tmp: libc::c_int = 0;
    d = (*strm).data as *mut write_data;
    tmp = fileno((*d).f);
    shutdown(tmp, 1 as libc::c_int);
    if (*(*d).io).mode & 8 as libc::c_int == 0 as libc::c_int {
        fclose((*d).f);
    }
    free(d as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn strm_writeio(mut io: strm_io_0) -> *mut strm_stream {
    let mut d: *mut write_data = 0 as *mut write_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if ((*io).write_stream).is_null() {
        tmp = malloc(::std::mem::size_of::<write_data>() as libc::c_ulong);
        d = tmp as *mut write_data;
        (*d).f = fdopen((*io).fd, b"w\0" as *const u8 as *const libc::c_char);
        (*d).io = io;
        (*io)
            .write_stream = strm_stream_new(
            strm_consumer,
            Some(
                write_cb
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            Some(
                write_close
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            d as *mut libc::c_void,
        );
    }
    return (*io).write_stream;
}
pub unsafe extern "C" fn strm_io_new(
    mut fd: libc::c_int,
    mut mode: libc::c_int,
) -> strm_value {
    let mut io: strm_io_0 = 0 as *mut strm_io;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp___1: strm_value = 0;
    tmp = malloc(::std::mem::size_of::<strm_io>() as libc::c_ulong);
    io = tmp as strm_io_0;
    (*io).fd = fd;
    (*io).mode = mode;
    (*io).type_0 = STRM_PTR_IO;
    tmp___0 = 0 as *mut libc::c_void as *mut strm_stream;
    (*io).write_stream = tmp___0;
    (*io).read_stream = tmp___0;
    tmp___1 = strm_ptr_value(io as *mut libc::c_void);
    return tmp___1;
}
pub unsafe extern "C" fn strm_io_stream(
    mut iov: strm_value,
    mut mode: libc::c_int,
) -> *mut strm_stream {
    let mut io: strm_io_0 = 0 as *mut strm_io;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp___5: *mut strm_stream = 0 as *mut strm_stream;
    tmp___2 = strm_ptr_tag_p(iov, STRM_PTR_IO);
    if tmp___2 == 0 {
        __assert_fail(
            b"strm_io_p(iov)\0" as *const u8 as *const libc::c_char,
            b"io.c\0" as *const u8 as *const libc::c_char,
            380 as libc::c_uint,
            b"strm_io_stream\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___3 = strm_value_ptr(iov, STRM_PTR_IO);
    io = tmp___3 as strm_io_0;
    match mode {
        1 => {
            tmp___4 = strm_readio(io);
            return tmp___4;
        }
        2 => {
            tmp___5 = strm_writeio(io);
            return tmp___5;
        }
        _ => return 0 as *mut libc::c_void as *mut strm_stream,
    };
}
static mut khash_ac_HASH_UPPER: libc::c_double = 0.77f64;
unsafe extern "C" fn gen_seq(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut seq_data = 0 as *mut seq_data;
    let mut tmp: strm_value = 0;
    d = (*strm).data as *mut seq_data;
    if (*d).end > 0 as libc::c_int as libc::c_double {
        if (*d).n > (*d).end {
            strm_stream_close(strm);
            return 0 as libc::c_int;
        }
    }
    tmp = strm_float_value((*d).n);
    strm_emit(
        strm,
        tmp,
        Some(
            gen_seq as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
    );
    (*d).n += (*d).inc;
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_seq(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut start: libc::c_double = 0.;
    let mut end: libc::c_double = 0.;
    let mut inc: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    let mut d: *mut seq_data = 0 as *mut seq_data;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut strm_stream = 0 as *mut strm_stream;
    start = 1 as libc::c_int as libc::c_double;
    end = -(1 as libc::c_int) as libc::c_double;
    inc = 1 as libc::c_int as libc::c_double;
    tmp___0 = strm_parse_args(
        strm,
        argc,
        args,
        b"|fff\0" as *const u8 as *const libc::c_char,
        &mut start as *mut libc::c_double,
        &mut end as *mut libc::c_double,
        &mut tmp as *mut libc::c_double,
    );
    if tmp___0 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    match argc {
        1 => {
            end = start;
            start = 1 as libc::c_int as libc::c_double;
        }
        3 => {
            inc = end;
            end = tmp;
        }
        _ => {}
    }
    tmp___1 = malloc(::std::mem::size_of::<seq_data>() as libc::c_ulong);
    d = tmp___1 as *mut seq_data;
    (*d).n = start;
    (*d).inc = inc;
    (*d).end = end;
    tmp___2 = strm_stream_new(
        strm_producer,
        Some(
            gen_seq as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___2 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn gen_repeat(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut repeat_data = 0 as *mut repeat_data;
    d = (*strm).data as *mut repeat_data;
    (*d).count -= 1;
    if (*d).count == 0 as libc::c_int {
        strm_emit(
            strm,
            (*d).v,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        strm_stream_close(strm);
    } else {
        strm_emit(
            strm,
            (*d).v,
            Some(
                gen_repeat
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fin_repeat(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    free((*strm).data);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_repeat(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut v: strm_value = 0;
    let mut n: strm_int = 0;
    let mut d: *mut repeat_data = 0 as *mut repeat_data;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    n = -(1 as libc::c_int);
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v|i\0" as *const u8 as *const libc::c_char,
        &mut v as *mut strm_value,
        &mut n as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if argc == 2 as libc::c_int {
        if n <= 0 as libc::c_int {
            strm_raise(
                strm,
                b"invalid count number\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    }
    tmp___0 = malloc(::std::mem::size_of::<repeat_data>() as libc::c_ulong);
    d = tmp___0 as *mut repeat_data;
    (*d).v = v;
    (*d).count = n;
    tmp___1 = strm_stream_new(
        strm_producer,
        Some(
            gen_repeat
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            fin_repeat
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn gen_cycle(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut cycle_data = 0 as *mut cycle_data;
    let mut p: *mut strm_value = 0 as *mut strm_value;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    let mut tmp: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    d = (*strm).data as *mut cycle_data;
    (*d).count -= 1;
    tmp = strm_ary_struct((*d).ary);
    p = (*tmp).ptr;
    tmp___0 = strm_ary_struct((*d).ary);
    len = (*tmp___0).len;
    if (*d).count != 0 as libc::c_int {
        len -= 1;
    }
    i = 0 as libc::c_int;
    while i < len {
        strm_emit(
            strm,
            *p.offset(i as isize),
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        i += 1;
    }
    if (*d).count == 0 as libc::c_int {
        strm_stream_close(strm);
    } else {
        strm_emit(
            strm,
            *p.offset(i as isize),
            Some(
                gen_cycle
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fin_cycle(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    free((*strm).data);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_cycle(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut a: strm_array = 0;
    let mut n: strm_int = 0;
    let mut d: *mut cycle_data = 0 as *mut cycle_data;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    n = -(1 as libc::c_int);
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"A|i\0" as *const u8 as *const libc::c_char,
        &mut a as *mut strm_array,
        &mut n as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if argc == 2 as libc::c_int {
        if n <= 0 as libc::c_int {
            strm_raise(
                strm,
                b"invalid count number\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    }
    tmp___0 = malloc(::std::mem::size_of::<cycle_data>() as libc::c_ulong);
    d = tmp___0 as *mut cycle_data;
    (*d).ary = a;
    (*d).count = n;
    tmp___1 = strm_stream_new(
        strm_producer,
        Some(
            gen_cycle
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            fin_cycle
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_each(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut map_data = 0 as *mut map_data;
    let mut val: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    d = (*strm).data as *mut map_data;
    tmp = strm_funcall(strm, (*d).func, 1 as libc::c_int, &mut data, &mut val);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_each(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut map_data = 0 as *mut map_data;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<map_data>() as libc::c_ulong);
    d = tmp___0 as *mut map_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).func = func;
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_each
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_each(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut len: strm_int = 0;
    let mut func: strm_value = 0;
    let mut i: strm_int = 0;
    let mut r: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"av\0" as *const u8 as *const libc::c_char,
        &mut v as *mut *mut strm_value,
        &mut len as *mut strm_int,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < len {
        tmp___0 = strm_funcall(
            strm,
            func,
            1 as libc::c_int,
            v.offset(i as isize),
            &mut r,
        );
        if tmp___0 == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    *ret = *args.offset(0 as libc::c_int as isize);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_map(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut map_data = 0 as *mut map_data;
    let mut val: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    d = (*strm).data as *mut map_data;
    tmp = strm_funcall(strm, (*d).func, 1 as libc::c_int, &mut data, &mut val);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    strm_emit(
        strm,
        val,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_map(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut map_data = 0 as *mut map_data;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<map_data>() as libc::c_ulong);
    d = tmp___0 as *mut map_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).func = func;
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_map as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_map(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut len: strm_int = 0;
    let mut func: strm_value = 0;
    let mut i: strm_int = 0;
    let mut a2: strm_array = 0;
    let mut v2: *mut strm_value = 0 as *mut strm_value;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___1: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"av\0" as *const u8 as *const libc::c_char,
        &mut v as *mut *mut strm_value,
        &mut len as *mut strm_int,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    a2 = strm_ary_new(0 as *mut libc::c_void as *const strm_value, len);
    tmp___0 = strm_ary_struct(a2);
    v2 = (*tmp___0).ptr;
    i = 0 as libc::c_int;
    while i < len {
        tmp___1 = strm_funcall(
            strm,
            func,
            1 as libc::c_int,
            v.offset(i as isize),
            v2.offset(i as isize),
        );
        if tmp___1 == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    *ret = a2;
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_flatmap(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut map_data = 0 as *mut map_data;
    let mut val: strm_value = 0;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    let mut e: *mut strm_value = 0 as *mut strm_value;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: *mut strm_array_0 = 0 as *mut strm_array_0;
    d = (*strm).data as *mut map_data;
    tmp = strm_funcall(strm, (*d).func, 1 as libc::c_int, &mut data, &mut val);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_array_p(val);
    if tmp___0 == 0 {
        strm_raise(
            strm,
            b"no array given for flatmap\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    tmp___1 = strm_ary_struct(val);
    len = (*tmp___1).len;
    tmp___2 = strm_ary_struct(val);
    e = (*tmp___2).ptr;
    i = 0 as libc::c_int;
    while i < len {
        strm_emit(
            strm,
            *e.offset(i as isize),
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn flatmap_len(mut ary: strm_array) -> libc::c_int {
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut tmp: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    let mut n: strm_int = 0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = strm_ary_struct(ary);
    v = (*tmp).ptr;
    n = 0 as libc::c_int;
    tmp___0 = strm_ary_struct(ary);
    len = (*tmp___0).len;
    i = 0 as libc::c_int;
    while i < len {
        tmp___2 = strm_array_p(*v.offset(i as isize));
        if tmp___2 != 0 {
            tmp___1 = flatmap_len(*v.offset(i as isize));
            n += tmp___1;
        } else {
            n += 1;
        }
        i += 1;
    }
    return n;
}
unsafe extern "C" fn flatmap_push(
    mut strm: *mut strm_stream,
    mut ary: strm_array,
    mut func: strm_value,
    mut p: *mut *mut strm_value,
) -> libc::c_int {
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut tmp: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    tmp = strm_ary_struct(ary);
    v = (*tmp).ptr;
    tmp___0 = strm_ary_struct(ary);
    len = (*tmp___0).len;
    i = 0 as libc::c_int;
    while i < len {
        tmp___3 = strm_array_p(*v.offset(i as isize));
        if tmp___3 != 0 {
            tmp___1 = flatmap_push(strm, *v.offset(i as isize), func, p);
            if tmp___1 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
        } else {
            tmp___2 = strm_funcall(
                strm,
                func,
                1 as libc::c_int,
                v.offset(i as isize),
                *p,
            );
            if tmp___2 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
            *p = (*p).offset(1);
        }
        i += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_flatmap(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut map_data = 0 as *mut map_data;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<map_data>() as libc::c_ulong);
    d = tmp___0 as *mut map_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).func = func;
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_flatmap
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_flatmap(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut ary: strm_array = 0;
    let mut func: strm_value = 0;
    let mut a2: strm_array = 0;
    let mut v2: *mut strm_value = 0 as *mut strm_value;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"Av\0" as *const u8 as *const libc::c_char,
        &mut ary as *mut strm_array,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = flatmap_len(ary);
    a2 = strm_ary_new(0 as *mut libc::c_void as *const strm_value, tmp___0);
    tmp___1 = strm_ary_struct(a2);
    v2 = (*tmp___1).ptr;
    tmp___2 = flatmap_push(strm, ary, func, &mut v2);
    if tmp___2 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = a2;
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_filter(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut map_data = 0 as *mut map_data;
    let mut val: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    d = (*strm).data as *mut map_data;
    tmp = strm_funcall(strm, (*d).func, 1 as libc::c_int, &mut data, &mut val);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_value_bool(val);
    if tmp___0 != 0 {
        strm_emit(
            strm,
            data,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_filter(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut map_data = 0 as *mut map_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = malloc(::std::mem::size_of::<map_data>() as libc::c_ulong);
    d = tmp as *mut map_data;
    tmp___0 = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut (*d).func as *mut strm_value,
    );
    if tmp___0 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_filter
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_count(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut count_data = 0 as *mut count_data;
    d = (*strm).data as *mut count_data;
    (*d).count += 1;
    return 0 as libc::c_int;
}
unsafe extern "C" fn count_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut count_data = 0 as *mut count_data;
    let mut tmp: strm_value = 0;
    d = (*strm).data as *mut count_data;
    tmp = strm_int_value((*d).count);
    strm_emit(
        strm,
        tmp,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    free(d as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_count(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut count_data = 0 as *mut count_data;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(strm, argc, args, b"\0" as *const u8 as *const libc::c_char);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<count_data>() as libc::c_ulong);
    d = tmp___0 as *mut count_data;
    (*d).count = 0 as libc::c_int;
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_count
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            count_finish
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_minmax(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut minmax_data = 0 as *mut minmax_data;
    let mut e: strm_value = 0;
    let mut num: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    d = (*strm).data as *mut minmax_data;
    tmp___0 = strm_nil_p((*d).func);
    if tmp___0 != 0 {
        e = data;
    } else {
        tmp = strm_funcall(strm, (*d).func, 1 as libc::c_int, &mut data, &mut e);
        if tmp == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
    }
    num = strm_value_float(e);
    if (*d).start != 0 {
        (*d).start = 0 as libc::c_int;
        (*d).num = num;
        (*d).data = data;
    } else if (*d).min != 0 {
        if (*d).num > num {
            (*d).num = num;
            (*d).data = data;
        }
    } else if (*d).num < num {
        (*d).num = num;
        (*d).data = data;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn minmax_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut minmax_data = 0 as *mut minmax_data;
    d = (*strm).data as *mut minmax_data;
    strm_emit(
        strm,
        (*d).data,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_minmax(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
    mut min: libc::c_int,
) -> libc::c_int {
    let mut d: *mut minmax_data = 0 as *mut minmax_data;
    let mut func: strm_value = 0;
    let mut tmp: strm_value = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_nil_value();
    func = tmp;
    tmp___0 = strm_parse_args(
        strm,
        argc,
        args,
        b"|v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp___0 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___1 = malloc(::std::mem::size_of::<minmax_data>() as libc::c_ulong);
    d = tmp___1 as *mut minmax_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).start = 1 as libc::c_int;
    (*d).min = min;
    (*d).num = 0 as libc::c_int as libc::c_double;
    (*d).data = strm_nil_value();
    (*d).func = func;
    tmp___2 = strm_stream_new(
        strm_filter,
        Some(
            iter_minmax
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            minmax_finish
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___2 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_min(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_minmax(strm, argc, args, ret, 1 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn exec_max(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_minmax(strm, argc, args, ret, 0 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn iter_reduce(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut reduce_data = 0 as *mut reduce_data;
    let mut args: [strm_value; 2] = [0; 2];
    let mut tmp: libc::c_int = 0;
    d = (*strm).data as *mut reduce_data;
    if (*d).init == 0 {
        (*d).init = 1 as libc::c_int;
        (*d).acc = data;
        return 0 as libc::c_int;
    }
    args[0 as libc::c_int as usize] = (*d).acc;
    args[1 as libc::c_int as usize] = data;
    tmp = strm_funcall(strm, (*d).func, 2 as libc::c_int, args.as_mut_ptr(), &mut data);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    (*d).acc = data;
    return 0 as libc::c_int;
}
unsafe extern "C" fn reduce_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut reduce_data = 0 as *mut reduce_data;
    d = (*strm).data as *mut reduce_data;
    if (*d).init == 0 {
        return 1 as libc::c_int;
    }
    strm_emit(
        strm,
        (*d).acc,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_reduce(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut reduce_data = 0 as *mut reduce_data;
    let mut v1: strm_value = 0;
    let mut v2: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v|v\0" as *const u8 as *const libc::c_char,
        &mut v1 as *mut strm_value,
        &mut v2 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<reduce_data>() as libc::c_ulong);
    d = tmp___0 as *mut reduce_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    if argc == 2 as libc::c_int {
        (*d).init = 1 as libc::c_int;
        (*d).acc = v1;
        (*d).func = v2;
    } else {
        (*d).init = 0 as libc::c_int;
        (*d).acc = strm_nil_value();
        (*d).func = v1;
    }
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_reduce
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            reduce_finish
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn kh_init_rbk() -> *mut kh_rbk_t {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<kh_rbk_t>() as libc::c_ulong,
    );
    return tmp as *mut kh_rbk_t;
}
#[inline]
unsafe extern "C" fn kh_resize_rbk(
    mut h: *mut kh_rbk_t,
    mut new_n_buckets: khint_t,
) -> libc::c_int {
    let mut new_flags: *mut khint32_t = 0 as *mut khint32_t;
    let mut j: khint_t = 0;
    let mut tmp: khint_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: khint_t = 0;
    let mut new_keys: *mut khint64_t = 0 as *mut khint64_t;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut new_vals: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut key: khint64_t = 0;
    let mut val: strm_value = 0;
    let mut new_mask: khint_t = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp___4: khint64_t = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    new_flags = 0 as *mut khint32_t;
    j = 1 as libc::c_int as khint_t;
    new_n_buckets = new_n_buckets.wrapping_sub(1);
    new_n_buckets |= new_n_buckets >> 1 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 2 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 4 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 8 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 16 as libc::c_int;
    new_n_buckets = new_n_buckets.wrapping_add(1);
    if new_n_buckets < 4 as libc::c_uint {
        new_n_buckets = 4 as libc::c_int as khint_t;
    }
    if (*h).size
        >= (new_n_buckets as libc::c_double * khash_ac_HASH_UPPER + 0.5f64) as khint_t
    {
        j = 0 as libc::c_int as khint_t;
    } else {
        if new_n_buckets < 16 as libc::c_uint {
            tmp = 1 as libc::c_int as khint_t;
        } else {
            tmp = new_n_buckets >> 4 as libc::c_int;
        }
        tmp___0 = malloc(
            (tmp as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        new_flags = tmp___0 as *mut khint32_t;
        if new_flags.is_null() {
            return -(1 as libc::c_int);
        }
        if new_n_buckets < 16 as libc::c_uint {
            tmp___1 = 1 as libc::c_int as khint_t;
        } else {
            tmp___1 = new_n_buckets >> 4 as libc::c_int;
        }
        memset(
            new_flags as *mut libc::c_void,
            170 as libc::c_int,
            (tmp___1 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        if (*h).n_buckets < new_n_buckets {
            tmp___2 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<khint64_t>() as libc::c_ulong),
            );
            new_keys = tmp___2 as *mut khint64_t;
            if new_keys.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).keys = new_keys;
            tmp___3 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
            );
            new_vals = tmp___3 as *mut strm_value;
            if new_vals.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).vals = new_vals;
        }
    }
    if j != 0 {
        j = 0 as libc::c_int as khint_t;
        while j != (*h).n_buckets {
            if *((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                >> ((j & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint
                == 0 as libc::c_uint
            {
                key = *((*h).keys).offset(j as isize);
                new_mask = new_n_buckets.wrapping_sub(1 as libc::c_uint);
                val = *((*h).vals).offset(j as isize);
                *((*h).flags)
                    .offset(
                        (j >> 4 as libc::c_int) as isize,
                    ) = (*((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                    as libc::c_ulong
                    | (1 as libc::c_ulong)
                        << ((j & 15 as libc::c_uint) << 1 as libc::c_int)) as khint32_t;
                loop {
                    step = 0 as libc::c_int as khint_t;
                    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int)
                        as khint32_t;
                    i = k & new_mask;
                    while *new_flags.offset((i >> 4 as libc::c_int) as isize)
                        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                        & 2 as libc::c_uint == 0
                    {
                        step = step.wrapping_add(1);
                        i = i.wrapping_add(step) & new_mask;
                    }
                    *new_flags
                        .offset(
                            (i >> 4 as libc::c_int) as isize,
                        ) = (*new_flags.offset((i >> 4 as libc::c_int) as isize)
                        as libc::c_ulong
                        & !((2 as libc::c_ulong)
                            << ((i & 15 as libc::c_uint) << 1 as libc::c_int)))
                        as khint32_t;
                    if i < (*h).n_buckets {
                        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                            & 3 as libc::c_uint == 0 as libc::c_uint
                        {
                            tmp___4 = *((*h).keys).offset(i as isize);
                            *((*h).keys).offset(i as isize) = key;
                            key = tmp___4;
                            tmp___5 = *((*h).vals).offset(i as isize);
                            *((*h).vals).offset(i as isize) = val;
                            val = tmp___5;
                            *((*h).flags)
                                .offset(
                                    (i >> 4 as libc::c_int) as isize,
                                ) = (*((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                                as libc::c_ulong
                                | (1 as libc::c_ulong)
                                    << ((i & 15 as libc::c_uint) << 1 as libc::c_int))
                                as khint32_t;
                        } else {
                            *((*h).keys).offset(i as isize) = key;
                            *((*h).vals).offset(i as isize) = val;
                            break;
                        }
                    } else {
                        *((*h).keys).offset(i as isize) = key;
                        *((*h).vals).offset(i as isize) = val;
                        break;
                    }
                }
            }
            j = j.wrapping_add(1);
        }
        if (*h).n_buckets > new_n_buckets {
            tmp___6 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<khint64_t>() as libc::c_ulong),
            );
            (*h).keys = tmp___6 as *mut khint64_t;
            tmp___7 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
            );
            (*h).vals = tmp___7 as *mut strm_value;
        }
        free((*h).flags as *mut libc::c_void);
        (*h).flags = new_flags;
        (*h).n_buckets = new_n_buckets;
        (*h).n_occupied = (*h).size;
        (*h)
            .upper_bound = ((*h).n_buckets as libc::c_double * khash_ac_HASH_UPPER
            + 0.5f64) as khint_t;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn kh_put_rbk(
    mut h: *mut kh_rbk_t,
    mut key: khint64_t,
    mut ret: *mut libc::c_int,
) -> khint_t {
    let mut x: khint_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut site: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    if (*h).n_occupied >= (*h).upper_bound {
        if (*h).n_buckets > (*h).size << 1 as libc::c_int {
            tmp = kh_resize_rbk(h, ((*h).n_buckets).wrapping_sub(1 as libc::c_uint));
            if tmp < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        } else {
            tmp___0 = kh_resize_rbk(h, ((*h).n_buckets).wrapping_add(1 as libc::c_uint));
            if tmp___0 < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        }
    }
    mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
    step = 0 as libc::c_int as khint_t;
    site = (*h).n_buckets;
    x = site;
    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
    i = k & mask;
    if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        x = i;
    } else {
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                != 0
            {
                site = i;
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if !(i == last) {
                continue;
            }
            x = site;
            break;
        }
        if x == (*h).n_buckets {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint
                != 0
            {
                if site != (*h).n_buckets {
                    x = site;
                } else {
                    x = i;
                }
            } else {
                x = i;
            }
        }
    }
    if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
        >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        (*h).n_occupied = ((*h).n_occupied).wrapping_add(1);
        *ret = 1 as libc::c_int;
    } else if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
            >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint != 0
        {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        *ret = 2 as libc::c_int;
    } else {
        *ret = 0 as libc::c_int;
    }
    return x;
}
unsafe extern "C" fn iter_rbk(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut rbk_data = 0 as *mut rbk_data;
    let mut k: strm_value = 0;
    let mut v: strm_value = 0;
    let mut i: khiter_t = 0;
    let mut r: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut args: [strm_value; 3] = [0; 3];
    let mut tmp___3: libc::c_int = 0;
    d = (*strm).data as *mut rbk_data;
    tmp = strm_array_p(data);
    if tmp != 0 {
        tmp___0 = strm_ary_struct(data);
        if (*tmp___0).len != 2 as libc::c_int {
            strm_raise(
                strm,
                b"reduce_by_key element must be a key-value pair\0" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    } else {
        strm_raise(
            strm,
            b"reduce_by_key element must be a key-value pair\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    tmp___1 = strm_ary_struct(data);
    k = *((*tmp___1).ptr).offset(0 as libc::c_int as isize);
    tmp___2 = strm_ary_struct(data);
    v = *((*tmp___2).ptr).offset(1 as libc::c_int as isize);
    i = kh_put_rbk((*d).tbl, k, &mut r);
    if r < 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    if r != 0 as libc::c_int {
        *((*(*d).tbl).vals).offset(i as isize) = v;
    } else {
        args[0 as libc::c_int as usize] = k;
        args[1 as libc::c_int as usize] = *((*(*d).tbl).vals).offset(i as isize);
        args[2 as libc::c_int as usize] = v;
        tmp___3 = strm_funcall(
            strm,
            (*d).func,
            3 as libc::c_int,
            args.as_mut_ptr(),
            &mut v,
        );
        if tmp___3 == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
        *((*(*d).tbl).vals).offset(i as isize) = v;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn rbk_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut rbk_data = 0 as *mut rbk_data;
    let mut i: khiter_t = 0;
    let mut values: [strm_value; 2] = [0; 2];
    let mut tmp: strm_array = 0;
    d = (*strm).data as *mut rbk_data;
    i = 0 as libc::c_int as khint_t;
    while i != (*(*d).tbl).n_buckets {
        if *((*(*d).tbl).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint == 0
        {
            values[0 as libc::c_int as usize] = *((*(*d).tbl).keys).offset(i as isize);
            values[1 as libc::c_int as usize] = *((*(*d).tbl).vals).offset(i as isize);
            tmp = strm_ary_new(
                values.as_mut_ptr() as *const strm_value,
                2 as libc::c_int,
            );
            strm_emit(
                strm,
                tmp,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
            );
        }
        i = i.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_rbk(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut rbk_data = 0 as *mut rbk_data;
    let mut t: *mut kh_rbk_t = 0 as *mut kh_rbk_t;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = kh_init_rbk();
    if t.is_null() {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<rbk_data>() as libc::c_ulong);
    d = tmp___0 as *mut rbk_data;
    (*d).tbl = t;
    (*d).func = func;
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_rbk as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            rbk_finish
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_slice(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut slice_data = 0 as *mut slice_data;
    let mut n: strm_int = 0;
    let mut tmp: strm_int = 0;
    let mut ary: strm_array = 0;
    let mut tmp___0: strm_array = 0;
    d = (*strm).data as *mut slice_data;
    n = (*d).n;
    tmp = (*d).i;
    (*d).i += 1;
    *((*d).buf).offset(tmp as isize) = data;
    if (*d).i == n {
        tmp___0 = strm_ary_new((*d).buf as *const strm_value, n);
        ary = tmp___0;
        (*d).i = 0 as libc::c_int;
        strm_emit(
            strm,
            ary,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn finish_slice(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut slice_data = 0 as *mut slice_data;
    let mut ary: strm_array = 0;
    let mut tmp: strm_array = 0;
    d = (*strm).data as *mut slice_data;
    if (*d).i > 0 as libc::c_int {
        tmp = strm_ary_new((*d).buf as *const strm_value, (*d).i);
        ary = tmp;
        strm_emit(
            strm,
            ary,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
    }
    free((*d).buf as *mut libc::c_void);
    free(d as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_slice(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut slice_data = 0 as *mut slice_data;
    let mut n: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"i\0" as *const u8 as *const libc::c_char,
        &mut n as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<slice_data>() as libc::c_ulong);
    d = tmp___0 as *mut slice_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).n = n;
    (*d).i = 0 as libc::c_int;
    tmp___1 = malloc(
        (n as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
    );
    (*d).buf = tmp___1 as *mut strm_value;
    if ((*d).buf).is_null() {
        free(d as *mut libc::c_void);
        return 1 as libc::c_int;
    }
    tmp___2 = strm_stream_new(
        strm_filter,
        Some(
            iter_slice
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            finish_slice
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___2 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_consec(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut slice_data = 0 as *mut slice_data;
    let mut n: strm_int = 0;
    let mut tmp: strm_int = 0;
    let mut ary: strm_array = 0;
    let mut tmp___0: strm_array = 0;
    let mut ary___0: strm_array = 0;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    d = (*strm).data as *mut slice_data;
    n = (*d).n;
    if (*d).i < n {
        tmp = (*d).i;
        (*d).i += 1;
        *((*d).buf).offset(tmp as isize) = data;
        if (*d).i == n {
            tmp___0 = strm_ary_new((*d).buf as *const strm_value, n);
            ary = tmp___0;
            strm_emit(
                strm,
                ary,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
            );
        }
        return 0 as libc::c_int;
    } else {
        len = n - 1 as libc::c_int;
        i = 0 as libc::c_int;
        while i < len {
            *((*d).buf)
                .offset(
                    i as isize,
                ) = *((*d).buf).offset((i + 1 as libc::c_int) as isize);
            i += 1;
        }
        *((*d).buf).offset(len as isize) = data;
        ary___0 = strm_ary_new((*d).buf as *const strm_value, n);
        strm_emit(
            strm,
            ary___0,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn finish_consec(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut slice_data = 0 as *mut slice_data;
    d = (*strm).data as *mut slice_data;
    free((*d).buf as *mut libc::c_void);
    free(d as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_consec(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut slice_data = 0 as *mut slice_data;
    let mut n: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"i\0" as *const u8 as *const libc::c_char,
        &mut n as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<slice_data>() as libc::c_ulong);
    d = tmp___0 as *mut slice_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).n = n;
    (*d).i = 0 as libc::c_int;
    tmp___1 = malloc(
        (n as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
    );
    (*d).buf = tmp___1 as *mut strm_value;
    if ((*d).buf).is_null() {
        free(d as *mut libc::c_void);
        return 1 as libc::c_int;
    }
    tmp___2 = strm_stream_new(
        strm_filter,
        Some(
            iter_consec
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            finish_consec
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___2 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_take(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut take_data = 0 as *mut take_data;
    d = (*strm).data as *mut take_data;
    strm_emit(
        strm,
        data,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    (*d).n -= 1;
    if (*d).n == 0 as libc::c_int {
        strm_stream_close(strm);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_take(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut take_data = 0 as *mut take_data;
    let mut n: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"i\0" as *const u8 as *const libc::c_char,
        &mut n as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if n < 0 as libc::c_int {
        strm_raise(strm, b"negative iteration\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<take_data>() as libc::c_ulong);
    d = tmp___0 as *mut take_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).n = n;
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_take
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_drop(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut take_data = 0 as *mut take_data;
    d = (*strm).data as *mut take_data;
    if (*d).n > 0 as libc::c_int {
        (*d).n -= 1;
        return 0 as libc::c_int;
    }
    strm_emit(
        strm,
        data,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_drop(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut take_data = 0 as *mut take_data;
    let mut n: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"i\0" as *const u8 as *const libc::c_char,
        &mut n as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if n < 0 as libc::c_int {
        strm_raise(strm, b"negative iteration\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<take_data>() as libc::c_ulong);
    d = tmp___0 as *mut take_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).n = n;
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_drop
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_uniq(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut uniq_data = 0 as *mut uniq_data;
    let mut tmp: libc::c_int = 0;
    d = (*strm).data as *mut uniq_data;
    if (*d).init == 0 {
        (*d).init = 1 as libc::c_int;
        (*d).last = data;
        strm_emit(
            strm,
            data,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        return 0 as libc::c_int;
    }
    tmp = strm_value_eq(data, (*d).last);
    if tmp == 0 {
        (*d).last = data;
        strm_emit(
            strm,
            data,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_uniqf(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut uniq_data = 0 as *mut uniq_data;
    let mut val: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    d = (*strm).data as *mut uniq_data;
    tmp = strm_funcall(strm, (*d).func, 1 as libc::c_int, &mut data, &mut val);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if (*d).init == 0 {
        (*d).init = 1 as libc::c_int;
        (*d).last = data;
        (*d).v = val;
        strm_emit(
            strm,
            data,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        return 0 as libc::c_int;
    }
    tmp___0 = strm_value_eq(val, (*d).v);
    if tmp___0 == 0 {
        (*d).last = data;
        (*d).v = val;
        strm_emit(
            strm,
            data,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_uniq(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut uniq_data = 0 as *mut uniq_data;
    let mut func: strm_value = 0;
    let mut tmp: strm_value = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    > = None;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_nil_value();
    func = tmp;
    tmp___0 = strm_parse_args(
        strm,
        argc,
        args,
        b"|v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp___0 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___1 = malloc(::std::mem::size_of::<uniq_data>() as libc::c_ulong);
    d = tmp___1 as *mut uniq_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).last = strm_nil_value();
    (*d).func = func;
    (*d).init = 0 as libc::c_int;
    tmp___4 = strm_nil_p(func);
    if tmp___4 != 0 {
        tmp___3 = Some(
            iter_uniq
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        );
    } else {
        tmp___3 = Some(
            iter_uniqf
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        );
    }
    tmp___5 = strm_stream_new(
        strm_filter,
        tmp___3,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___5 as *mut libc::c_void);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_iter_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: strm_value = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: strm_value = 0;
    let mut tmp___7: strm_value = 0;
    let mut tmp___8: strm_value = 0;
    let mut tmp___9: strm_value = 0;
    let mut tmp___10: strm_value = 0;
    let mut tmp___11: strm_value = 0;
    let mut tmp___12: strm_value = 0;
    let mut tmp___13: strm_value = 0;
    let mut tmp___14: strm_value = 0;
    let mut tmp___15: strm_value = 0;
    let mut tmp___16: strm_value = 0;
    let mut tmp___17: strm_value = 0;
    let mut tmp___18: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            exec_seq
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"seq\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            exec_repeat
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"repeat\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_cfunc_value(
        Some(
            exec_cycle
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"cycle\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            exec_each
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"each\0" as *const u8 as *const libc::c_char, tmp___2);
    tmp___3 = strm_cfunc_value(
        Some(
            exec_map
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"map\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = strm_cfunc_value(
        Some(
            exec_flatmap
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"flatmap\0" as *const u8 as *const libc::c_char, tmp___4);
    tmp___5 = strm_cfunc_value(
        Some(
            exec_filter
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"filter\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = strm_cfunc_value(
        Some(
            exec_count
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"count\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = strm_cfunc_value(
        Some(
            exec_min
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"min\0" as *const u8 as *const libc::c_char, tmp___7);
    tmp___8 = strm_cfunc_value(
        Some(
            exec_max
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"max\0" as *const u8 as *const libc::c_char, tmp___8);
    tmp___9 = strm_cfunc_value(
        Some(
            exec_reduce
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"reduce\0" as *const u8 as *const libc::c_char, tmp___9);
    tmp___10 = strm_cfunc_value(
        Some(
            exec_rbk
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        state,
        b"reduce_by_key\0" as *const u8 as *const libc::c_char,
        tmp___10,
    );
    tmp___11 = strm_cfunc_value(
        Some(
            exec_slice
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"slice\0" as *const u8 as *const libc::c_char, tmp___11);
    tmp___12 = strm_cfunc_value(
        Some(
            exec_consec
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"consec\0" as *const u8 as *const libc::c_char, tmp___12);
    tmp___13 = strm_cfunc_value(
        Some(
            exec_take
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"take\0" as *const u8 as *const libc::c_char, tmp___13);
    tmp___14 = strm_cfunc_value(
        Some(
            exec_drop
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"drop\0" as *const u8 as *const libc::c_char, tmp___14);
    tmp___15 = strm_cfunc_value(
        Some(
            exec_uniq
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"uniq\0" as *const u8 as *const libc::c_char, tmp___15);
    tmp___16 = strm_cfunc_value(
        Some(
            ary_each
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_array, b"each\0" as *const u8 as *const libc::c_char, tmp___16);
    tmp___17 = strm_cfunc_value(
        Some(
            ary_map
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_array, b"map\0" as *const u8 as *const libc::c_char, tmp___17);
    tmp___18 = strm_cfunc_value(
        Some(
            ary_flatmap
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_array,
        b"flatmap\0" as *const u8 as *const libc::c_char,
        tmp___18,
    );
    strm_stat_init(state);
}
unsafe extern "C" fn iter_sum(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sum_data = 0 as *mut sum_data;
    let mut x: libc::c_double = 0.;
    let mut t: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    d = (*strm).data as *mut sum_data;
    tmp = strm_number_p(data);
    if tmp == 0 {
        return 1 as libc::c_int;
    }
    x = strm_value_float(data);
    t = (*d).sum + x;
    tmp___0 = fabs((*d).sum);
    tmp___1 = fabs(x);
    if tmp___0 >= tmp___1 {
        (*d).c += (*d).sum - t + x;
    } else {
        (*d).c += x - t + (*d).sum;
    }
    (*d).sum = t;
    (*d).num += 1;
    return 0 as libc::c_int;
}
unsafe extern "C" fn convert_number(
    mut strm: *mut strm_stream,
    mut data: strm_value,
    mut func: strm_value,
) -> strm_value {
    let mut val: strm_value = 0;
    let mut tmp: strm_value = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp___0 = strm_funcall(strm, func, 1 as libc::c_int, &mut data, &mut val);
    if tmp___0 == 1 as libc::c_int {
        tmp = strm_nil_value();
        return tmp;
    }
    tmp___2 = strm_number_p(val);
    if tmp___2 == 0 {
        strm_raise(strm, b"number required\0" as *const u8 as *const libc::c_char);
        tmp___1 = strm_nil_value();
        return tmp___1;
    }
    return val;
}
unsafe extern "C" fn iter_sumf(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sum_data = 0 as *mut sum_data;
    let mut x: libc::c_double = 0.;
    let mut t: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    d = (*strm).data as *mut sum_data;
    data = convert_number(strm, data, (*d).func);
    tmp = strm_number_p(data);
    if tmp == 0 {
        return 1 as libc::c_int;
    }
    x = strm_value_float(data);
    t = (*d).sum + x;
    tmp___0 = fabs((*d).sum);
    tmp___1 = fabs(x);
    if tmp___0 >= tmp___1 {
        (*d).c += (*d).sum - t + x;
    } else {
        (*d).c += x - t + (*d).sum;
    }
    (*d).sum = t;
    (*d).num += 1;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sum_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sum_data = 0 as *mut sum_data;
    let mut tmp: strm_value = 0;
    d = (*strm).data as *mut sum_data;
    tmp = strm_float_value((*d).sum + (*d).c);
    strm_emit(
        strm,
        tmp,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn avg_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sum_data = 0 as *mut sum_data;
    let mut tmp: strm_value = 0;
    d = (*strm).data as *mut sum_data;
    tmp = strm_float_value(((*d).sum + (*d).c) / (*d).num as libc::c_double);
    strm_emit(
        strm,
        tmp,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_sum_avg(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
    mut avg: libc::c_int,
) -> libc::c_int {
    let mut d: *mut sum_data = 0 as *mut sum_data;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    > = None;
    let mut tmp___2: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp___3: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    > = None;
    let mut tmp___4: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"|v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<sum_data>() as libc::c_ulong);
    d = tmp___0 as *mut sum_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).sum = 0 as libc::c_int as libc::c_double;
    (*d).c = 0 as libc::c_int as libc::c_double;
    (*d).num = 0 as libc::c_int;
    if argc == 0 as libc::c_int {
        (*d).func = strm_nil_value();
        if avg != 0 {
            tmp___1 = Some(
                avg_finish
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            );
        } else {
            tmp___1 = Some(
                sum_finish
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            );
        }
        tmp___2 = strm_stream_new(
            strm_filter,
            Some(
                iter_sum
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            tmp___1,
            d as *mut libc::c_void,
        );
        *ret = strm_ptr_value(tmp___2 as *mut libc::c_void);
    } else {
        (*d).func = func;
        if avg != 0 {
            tmp___3 = Some(
                avg_finish
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            );
        } else {
            tmp___3 = Some(
                sum_finish
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            );
        }
        tmp___4 = strm_stream_new(
            strm_filter,
            Some(
                iter_sumf
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            tmp___3,
            d as *mut libc::c_void,
        );
        *ret = strm_ptr_value(tmp___4 as *mut libc::c_void);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_sum(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_sum_avg(strm, argc, args, ret, 0 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn exec_avg(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_sum_avg(strm, argc, args, ret, 1 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn ary_sum_avg(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
    mut avg: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut sum: libc::c_double = 0.;
    let mut c: libc::c_double = 0.;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut x: libc::c_double = 0.;
    let mut t: libc::c_double = 0.;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut val: strm_value = 0;
    let mut x___0: libc::c_double = 0.;
    let mut t___0: libc::c_double = 0.;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: libc::c_double = 0.;
    sum = 0 as libc::c_int as libc::c_double;
    c = 0 as libc::c_int as libc::c_double;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"a|v\0" as *const u8 as *const libc::c_char,
        &mut v as *mut *mut strm_value,
        &mut len as *mut libc::c_int,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if argc == 1 as libc::c_int {
        i = 0 as libc::c_int;
        while i < len {
            tmp___0 = strm_number_p(*v.offset(i as isize));
            if tmp___0 == 0 {
                return 1 as libc::c_int;
            }
            x = strm_value_float(*v.offset(i as isize));
            t = sum + x;
            tmp___1 = fabs(sum);
            tmp___2 = fabs(x);
            if tmp___1 >= tmp___2 {
                c += sum - t + x;
            } else {
                c += x - t + sum;
            }
            sum = t;
            i += 1;
        }
    } else {
        i = 0 as libc::c_int;
        while i < len {
            val = convert_number(strm, *v.offset(i as isize), func);
            tmp___3 = strm_number_p(val);
            if tmp___3 == 0 {
                return 1 as libc::c_int;
            }
            x___0 = strm_value_float(val);
            t___0 = sum + x___0;
            tmp___4 = fabs(sum);
            tmp___5 = fabs(x___0);
            if tmp___4 >= tmp___5 {
                c += sum - t___0 + x___0;
            } else {
                c += x___0 - t___0 + sum;
            }
            sum = t___0;
            i += 1;
        }
    }
    sum += c;
    if avg != 0 {
        *ret = strm_float_value(sum / len as libc::c_double);
    } else {
        *ret = strm_float_value(sum);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_sum(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = ary_sum_avg(strm, argc, args, ret, 0 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn ary_avg(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = ary_sum_avg(strm, argc, args, ret, 1 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn iter_mvavg(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut mvavg_data = 0 as *mut mvavg_data;
    let mut sum: libc::c_double = 0.;
    let mut c: libc::c_double = 0.;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: strm_value = 0;
    let mut x: libc::c_double = 0.;
    let mut t: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: libc::c_double = 0.;
    let mut tmp___4: strm_value = 0;
    d = (*strm).data as *mut mvavg_data;
    sum = 0 as libc::c_int as libc::c_double;
    c = 0 as libc::c_int as libc::c_double;
    len = (*d).num;
    if (*d).func_p != 0 {
        data = convert_number(strm, data, (*d).func);
    }
    tmp = strm_number_p(data);
    if tmp == 0 {
        strm_raise(strm, b"number required\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = (*d).i;
    (*d).i += 1;
    *((*d).data).as_mut_ptr().offset(tmp___0 as isize) = strm_value_float(data);
    if (*d).i == (*d).num {
        (*d).filled = 1 as libc::c_int;
        (*d).i = 0 as libc::c_int;
    }
    if (*d).filled == 0 {
        tmp___1 = strm_nil_value();
        strm_emit(
            strm,
            tmp___1,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        return 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < len {
        x = *((*d).data).as_mut_ptr().offset(i as isize);
        t = sum + x;
        tmp___2 = fabs(sum);
        tmp___3 = fabs(x);
        if tmp___2 >= tmp___3 {
            c += sum - t + x;
        } else {
            c += x - t + sum;
        }
        sum = t;
        i += 1;
    }
    tmp___4 = strm_float_value((sum + c) / (*d).num as libc::c_double);
    strm_emit(
        strm,
        tmp___4,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_mvavg(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut mvavg_data = 0 as *mut mvavg_data;
    let mut n: strm_int = 0;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"i|v\0" as *const u8 as *const libc::c_char,
        &mut n as *mut strm_int,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(
        (::std::mem::size_of::<mvavg_data>() as libc::c_ulong)
            .wrapping_add(
                (n as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    ),
            ),
    );
    d = tmp___0 as *mut mvavg_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).num = n;
    (*d).i = 0 as libc::c_int;
    (*d).filled = 0 as libc::c_int;
    if argc == 1 as libc::c_int {
        (*d).func = strm_nil_value();
        (*d).func_p = 0 as libc::c_int;
    } else {
        (*d).func = func;
        (*d).func_p = 1 as libc::c_int;
    }
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_mvavg
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_stdev(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut stdev_data = 0 as *mut stdev_data;
    let mut x: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    d = (*strm).data as *mut stdev_data;
    tmp = strm_value_float(data);
    x = tmp;
    (*d).num += 1;
    x -= (*d).s1;
    (*d).s1 += x / (*d).num as libc::c_double;
    (*d).s2
        += ((*d).num - 1 as libc::c_int) as libc::c_double * x * x
            / (*d).num as libc::c_double;
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_stdevf(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut stdev_data = 0 as *mut stdev_data;
    let mut x: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    d = (*strm).data as *mut stdev_data;
    data = convert_number(strm, data, (*d).func);
    tmp = strm_number_p(data);
    if tmp == 0 {
        return 1 as libc::c_int;
    }
    x = strm_value_float(data);
    (*d).num += 1;
    x -= (*d).s1;
    (*d).s1 += x / (*d).num as libc::c_double;
    (*d).s2
        += ((*d).num - 1 as libc::c_int) as libc::c_double * x * x
            / (*d).num as libc::c_double;
    return 0 as libc::c_int;
}
unsafe extern "C" fn float2(mut m: libc::c_double, mut s: libc::c_double) -> strm_value {
    let mut buf: [strm_value; 2] = [0; 2];
    let mut tmp: strm_array = 0;
    fprintf(stderr, b"f2[%f, %f]\n\0" as *const u8 as *const libc::c_char, m, s);
    buf[0 as libc::c_int as usize] = strm_float_value(m);
    buf[1 as libc::c_int as usize] = strm_float_value(s);
    tmp = strm_ary_new(buf.as_mut_ptr() as *const strm_value, 2 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn stdev_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut stdev_data = 0 as *mut stdev_data;
    let mut s: libc::c_double = 0.;
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    d = (*strm).data as *mut stdev_data;
    match (*d).mode as libc::c_uint {
        0 => {
            s = sqrt((*d).s2 / ((*d).num - 1 as libc::c_int) as libc::c_double);
            tmp = strm_float_value(s);
            strm_emit(
                strm,
                tmp,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
            );
        }
        1 => {
            s = (*d).s2 / ((*d).num - 1 as libc::c_int) as libc::c_double;
            tmp___0 = strm_float_value(s);
            strm_emit(
                strm,
                tmp___0,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
            );
        }
        2 => {
            s = sqrt((*d).s2 / ((*d).num - 1 as libc::c_int) as libc::c_double);
            tmp___1 = float2((*d).s1, s);
            strm_emit(
                strm,
                tmp___1,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
            );
        }
        3 => {
            s = (*d).s2 / ((*d).num - 1 as libc::c_int) as libc::c_double;
            tmp___2 = float2((*d).s1, s);
            strm_emit(
                strm,
                tmp___2,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
            );
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_var_stdev(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
    mut mode: stdev_mode,
) -> libc::c_int {
    let mut d: *mut stdev_data = 0 as *mut stdev_data;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp___3: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"|v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<stdev_data>() as libc::c_ulong);
    d = tmp___0 as *mut stdev_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).num = 0 as libc::c_int;
    tmp___1 = 0.0f64;
    (*d).s2 = tmp___1;
    (*d).s1 = tmp___1;
    (*d).mode = mode;
    if argc == 0 as libc::c_int {
        tmp___2 = strm_stream_new(
            strm_filter,
            Some(
                iter_stdev
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            Some(
                stdev_finish
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            d as *mut libc::c_void,
        );
        *ret = strm_ptr_value(tmp___2 as *mut libc::c_void);
    } else {
        (*d).func = func;
        tmp___3 = strm_stream_new(
            strm_filter,
            Some(
                iter_stdevf
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            Some(
                stdev_finish
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
            d as *mut libc::c_void,
        );
        *ret = strm_ptr_value(tmp___3 as *mut libc::c_void);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_stdev(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_var_stdev(strm, argc, args, ret, mode_stdev);
    return tmp;
}
unsafe extern "C" fn exec_variance(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_var_stdev(strm, argc, args, ret, mode_variance);
    return tmp;
}
unsafe extern "C" fn exec_mean_stdev(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_var_stdev(strm, argc, args, ret, mode_mean_stdev);
    return tmp;
}
unsafe extern "C" fn exec_mean_variance(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = exec_var_stdev(strm, argc, args, ret, mode_mean_variance);
    return tmp;
}
unsafe extern "C" fn ary_var_stdev(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
    mut stdev: libc::c_int,
) -> libc::c_int {
    let mut func: strm_value = 0;
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut s1: libc::c_double = 0.;
    let mut s2: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut x: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut val: strm_value = 0;
    let mut x___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"a|v\0" as *const u8 as *const libc::c_char,
        &mut v as *mut *mut strm_value,
        &mut len as *mut libc::c_int,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    s2 = 0.0f64;
    s1 = s2;
    if argc == 0 as libc::c_int {
        i = 0 as libc::c_int;
        while i < len {
            tmp___0 = strm_value_float(*v.offset(i as isize));
            x = tmp___0;
            x -= s1;
            s1 += x / (i + 1 as libc::c_int) as libc::c_double;
            s2 += i as libc::c_double * x * x / (i + 1 as libc::c_int) as libc::c_double;
            i += 1;
        }
    } else {
        i = 0 as libc::c_int;
        while i < len {
            val = convert_number(strm, *v.offset(i as isize), func);
            tmp___1 = strm_number_p(val);
            if tmp___1 == 0 {
                return 1 as libc::c_int;
            }
            x___0 = strm_value_float(val);
            x___0 -= s1;
            s1 += x___0 / (i + 1 as libc::c_int) as libc::c_double;
            s2
                += i as libc::c_double * x___0 * x___0
                    / (i + 1 as libc::c_int) as libc::c_double;
            i += 1;
        }
    }
    s2 /= (i - 1 as libc::c_int) as libc::c_double;
    if stdev != 0 {
        s2 = sqrt(s2);
    }
    *ret = strm_float_value(s2);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_stdev(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = ary_var_stdev(strm, argc, args, ret, 1 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn ary_var(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = ary_var_stdev(strm, argc, args, ret, 0 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn iter_correl(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut correl_data = 0 as *mut correl_data;
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut dx: libc::c_double = 0.;
    let mut dy: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: libc::c_double = 0.;
    d = (*strm).data as *mut correl_data;
    tmp = strm_array_p(data);
    if tmp != 0 {
        tmp___0 = strm_ary_struct(data);
        if (*tmp___0).len != 2 as libc::c_int {
            strm_raise(strm, b"invalid data\0" as *const u8 as *const libc::c_char);
            return 1 as libc::c_int;
        }
    } else {
        strm_raise(strm, b"invalid data\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___1 = strm_ary_struct(data);
    v = (*tmp___1).ptr;
    tmp___2 = strm_number_p(*v.offset(0 as libc::c_int as isize));
    if tmp___2 != 0 {
        tmp___3 = strm_number_p(*v.offset(1 as libc::c_int as isize));
        if tmp___3 == 0 {
            strm_raise(
                strm,
                b"correl() requires [num, num]\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    } else {
        strm_raise(
            strm,
            b"correl() requires [num, num]\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    (*d).n += 1;
    tmp___4 = strm_value_float(*v.offset(0 as libc::c_int as isize));
    dx = tmp___4 - (*d).sx;
    (*d).sx += dx / (*d).n as libc::c_double;
    tmp___5 = strm_value_float(*v.offset(1 as libc::c_int as isize));
    dy = tmp___5 - (*d).sy;
    (*d).sy += dy / (*d).n as libc::c_double;
    (*d).sxx
        += ((*d).n - 1 as libc::c_int) as libc::c_double * dx * dx
            / (*d).n as libc::c_double;
    (*d).syy
        += ((*d).n - 1 as libc::c_int) as libc::c_double * dy * dy
            / (*d).n as libc::c_double;
    (*d).sxy
        += ((*d).n - 1 as libc::c_int) as libc::c_double * dx * dy
            / (*d).n as libc::c_double;
    return 0 as libc::c_int;
}
unsafe extern "C" fn correl_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut correl_data = 0 as *mut correl_data;
    let mut sxx: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    let mut syy: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut sxy: libc::c_double = 0.;
    let mut tmp___1: strm_value = 0;
    d = (*strm).data as *mut correl_data;
    (*d).n -= 1;
    tmp = sqrt((*d).sxx / (*d).n as libc::c_double);
    sxx = tmp;
    tmp___0 = sqrt((*d).syy / (*d).n as libc::c_double);
    syy = tmp___0;
    sxy = (*d).sxy / ((*d).n as libc::c_double * sxx * syy);
    tmp___1 = strm_float_value(sxy);
    strm_emit(
        strm,
        tmp___1,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_correl(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut correl_data = 0 as *mut correl_data;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: libc::c_double = 0.;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(strm, argc, args, b"\0" as *const u8 as *const libc::c_char);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<correl_data>() as libc::c_ulong);
    d = tmp___0 as *mut correl_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).n = 0 as libc::c_int;
    tmp___4 = 0 as libc::c_int as libc::c_double;
    (*d).sxy = tmp___4;
    tmp___3 = tmp___4;
    (*d).syy = tmp___3;
    tmp___2 = tmp___3;
    (*d).sxx = tmp___2;
    tmp___1 = tmp___2;
    (*d).sy = tmp___1;
    (*d).sx = tmp___1;
    tmp___5 = strm_stream_new(
        strm_filter,
        Some(
            iter_correl
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            correl_finish
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___5 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_correl(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut sx: libc::c_double = 0.;
    let mut sy: libc::c_double = 0.;
    let mut sxx: libc::c_double = 0.;
    let mut syy: libc::c_double = 0.;
    let mut sxy: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut data: strm_value = 0;
    let mut dv: *mut strm_value = 0 as *mut strm_value;
    let mut dx: libc::c_double = 0.;
    let mut dy: libc::c_double = 0.;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___3: libc::c_double = 0.;
    let mut tmp___4: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"a\0" as *const u8 as *const libc::c_char,
        &mut v as *mut *mut strm_value,
        &mut len as *mut libc::c_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    sxy = 0 as libc::c_int as libc::c_double;
    syy = sxy;
    sxx = syy;
    sy = sxx;
    sx = sy;
    i = 0 as libc::c_int;
    while i < len {
        data = *v.offset(i as isize);
        tmp___0 = strm_array_p(data);
        if tmp___0 != 0 {
            tmp___1 = strm_ary_struct(data);
            if !((*tmp___1).len != 2 as libc::c_int) {
                tmp___2 = strm_ary_struct(data);
                dv = (*tmp___2).ptr;
                tmp___3 = strm_value_float(*dv.offset(0 as libc::c_int as isize));
                dx = tmp___3 - sx;
                sx += dx / (i + 1 as libc::c_int) as libc::c_double;
                tmp___4 = strm_value_float(*dv.offset(1 as libc::c_int as isize));
                dy = tmp___4 - sy;
                sy += dy / (i + 1 as libc::c_int) as libc::c_double;
                sxx
                    += i as libc::c_double * dx * dx
                        / (i + 1 as libc::c_int) as libc::c_double;
                syy
                    += i as libc::c_double * dy * dy
                        / (i + 1 as libc::c_int) as libc::c_double;
                sxy
                    += i as libc::c_double * dx * dy
                        / (i + 1 as libc::c_int) as libc::c_double;
            }
        }
        i += 1;
    }
    sxx = sqrt(sxx / (len - 1 as libc::c_int) as libc::c_double);
    syy = sqrt(syy / (len - 1 as libc::c_int) as libc::c_double);
    sxy /= (len - 1 as libc::c_int) as libc::c_double * sxx * syy;
    *ret = strm_float_value(sxy);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_stat_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: strm_value = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: strm_value = 0;
    let mut tmp___7: strm_value = 0;
    let mut tmp___8: strm_value = 0;
    let mut tmp___9: strm_value = 0;
    let mut tmp___10: strm_value = 0;
    let mut tmp___11: strm_value = 0;
    let mut tmp___12: strm_value = 0;
    let mut tmp___13: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            exec_sum
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"sum\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            exec_avg
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"average\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_cfunc_value(
        Some(
            exec_avg
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"mean\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            exec_mvavg
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        state,
        b"moving_average\0" as *const u8 as *const libc::c_char,
        tmp___2,
    );
    tmp___3 = strm_cfunc_value(
        Some(
            exec_mvavg
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"rolling_mean\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = strm_cfunc_value(
        Some(
            exec_stdev
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"stdev\0" as *const u8 as *const libc::c_char, tmp___4);
    tmp___5 = strm_cfunc_value(
        Some(
            exec_variance
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"variance\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = strm_cfunc_value(
        Some(
            exec_mean_stdev
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"mean_stdev\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = strm_cfunc_value(
        Some(
            exec_mean_variance
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"mean_variance\0" as *const u8 as *const libc::c_char, tmp___7);
    tmp___8 = strm_cfunc_value(
        Some(
            exec_correl
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"correl\0" as *const u8 as *const libc::c_char, tmp___8);
    tmp___9 = strm_cfunc_value(
        Some(
            ary_sum
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_array, b"sum\0" as *const u8 as *const libc::c_char, tmp___9);
    tmp___10 = strm_cfunc_value(
        Some(
            ary_avg
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_array,
        b"average\0" as *const u8 as *const libc::c_char,
        tmp___10,
    );
    tmp___11 = strm_cfunc_value(
        Some(
            ary_stdev
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_array,
        b"stdev\0" as *const u8 as *const libc::c_char,
        tmp___11,
    );
    tmp___12 = strm_cfunc_value(
        Some(
            ary_var
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_array,
        b"variance\0" as *const u8 as *const libc::c_char,
        tmp___12,
    );
    tmp___13 = strm_cfunc_value(
        Some(
            ary_correl
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_array,
        b"correl\0" as *const u8 as *const libc::c_char,
        tmp___13,
    );
    strm_rand_init(state);
    strm_sort_init(state);
}
static mut ns_time: *mut strm_state = 0 as *const strm_state as *mut strm_state;
pub unsafe extern "C" fn strm_time_p(mut val: strm_value) -> libc::c_int {
    let mut p: *mut strm_misc = 0 as *mut strm_misc;
    if (val & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        != 18445899648779419648 as libc::c_ulonglong
    {
        return 0 as libc::c_int
    } else {
        p = (val & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
            as *mut libc::c_void as *mut strm_misc;
        if p.is_null() {
            return 0 as libc::c_int;
        }
        if (*p).type_0 as libc::c_uint != 4 as libc::c_uint {
            return 0 as libc::c_int;
        }
        if (*p).ns as libc::c_ulong != ns_time as libc::c_ulong {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
pub unsafe extern "C" fn num_to_timeval(mut d: libc::c_double, mut tv: *mut timeval) {
    let mut sec: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    tmp = floor(d);
    sec = tmp;
    (*tv).tv_sec = sec as __time_t;
    (*tv)
        .tv_usec = ((d - sec) * 1000000 as libc::c_int as libc::c_double)
        as __suseconds_t;
}
pub unsafe extern "C" fn timeval_to_num(mut tv: *mut timeval) -> libc::c_double {
    let mut d: libc::c_double = 0.;
    d = (*tv).tv_sec as libc::c_double;
    return d + (*tv).tv_usec as libc::c_double / 1000000.0f64;
}
static mut localoffset: libc::c_int = 1 as libc::c_int;
unsafe extern "C" fn time_localoffset(mut force: libc::c_int) -> libc::c_int {
    let mut now: time_t = 0;
    let mut gm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: time_t = 0;
    let mut tmp___0: libc::c_double = 0.;
    if force != 0 {
        now = time(0 as *mut libc::c_void as *mut time_t);
        gmtime_r(&mut now as *mut time_t as *const time_t, &mut gm as *mut tm);
        tmp = mktime(&mut gm);
        tmp___0 = difftime(now, tmp);
        localoffset = tmp___0 as libc::c_int;
    } else if localoffset == 1 as libc::c_int {
        now = time(0 as *mut libc::c_void as *mut time_t);
        gmtime_r(&mut now as *mut time_t as *const time_t, &mut gm as *mut tm);
        tmp = mktime(&mut gm);
        tmp___0 = difftime(now, tmp);
        localoffset = tmp___0 as libc::c_int;
    }
    return localoffset;
}
unsafe extern "C" fn time_alloc(
    mut tv: *mut timeval,
    mut utc_offset: libc::c_int,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<strm_time>() as libc::c_ulong);
    t = tmp as *mut strm_time;
    if t.is_null() {
        return 1 as libc::c_int;
    }
    (*t).type_0 = STRM_PTR_AUX;
    (*t).ns = ns_time;
    (*t).tv = *tv;
    (*t).utc_offset = utc_offset;
    *ret = strm_ptr_value(t as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn scan_digit(c: libc::c_char) -> libc::c_int {
    if 48 as libc::c_int <= c as libc::c_int {
        if c as libc::c_int <= 57 as libc::c_int {
            return c as libc::c_int - 48 as libc::c_int
        } else {
            return 60000 as libc::c_int
        }
    } else {
        return 60000 as libc::c_int
    };
}
unsafe extern "C" fn scan_num(
    mut sp: *mut *const libc::c_char,
    mut send: *const libc::c_char,
) -> libc::c_int {
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    s = *sp;
    n = 0 as libc::c_int;
    while (s as libc::c_ulong) < send as libc::c_ulong {
        tmp = scan_digit(*s);
        i = tmp;
        if i > 9 as libc::c_int {
            if s as libc::c_ulong == *sp as libc::c_ulong {
                return -(1 as libc::c_int);
            }
            *sp = s;
            return n;
        }
        s = s.offset(1);
        n = 10 as libc::c_int * n + i;
    }
    *sp = s;
    return n;
}
unsafe extern "C" fn parse_tz(
    mut s: *const libc::c_char,
    mut len: strm_int,
) -> libc::c_int {
    let mut h: libc::c_int = 0;
    let mut m: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    let mut send: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    send = s.offset(len as isize);
    match *s.offset(0 as libc::c_int as isize) as libc::c_int {
        90 => return 0 as libc::c_int,
        45 | 43 => {
            tmp = s;
            s = s.offset(1);
            c = *tmp;
            h = scan_num(&mut s, send);
            if h < 0 as libc::c_int {
                return 60000 as libc::c_int;
            }
            if *s as libc::c_int == 58 as libc::c_int {
                s = s.offset(1);
                m = scan_num(&mut s, send);
            } else if h >= 100 as libc::c_int {
                i = h;
                h = i / 100 as libc::c_int;
                m = i % 100 as libc::c_int;
            } else {
                m = 0 as libc::c_int;
            }
            if h > 14 as libc::c_int {
                return 60000 as libc::c_int;
            }
            if m > 59 as libc::c_int {
                return 60000 as libc::c_int;
            }
            if c as libc::c_int == 45 as libc::c_int {
                tmp___0 = -(1 as libc::c_int);
            } else {
                tmp___0 = 1 as libc::c_int;
            }
            return (h * 60 as libc::c_int + m) * tmp___0 * 60 as libc::c_int;
        }
        _ => return 60000 as libc::c_int,
    };
}
pub unsafe extern "C" fn strm_time_parse_time(
    mut p: *const libc::c_char,
    mut len: strm_int,
    mut sec: *mut libc::c_long,
    mut usec: *mut libc::c_long,
    mut offset: *mut libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut t: *const libc::c_char = 0 as *const libc::c_char;
    let mut t2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tend: *const libc::c_char = 0 as *const libc::c_char;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut localoffset___0: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tt: time_t = 0;
    let mut pp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tm2: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut frac: libc::c_long = 0;
    let mut tmp___11: libc::c_int = 0;
    let mut d: libc::c_double = 0.;
    let mut tmp___12: libc::c_double = 0.;
    let mut tmp___13: libc::c_double = 0.;
    let mut tmp___14: libc::c_double = 0.;
    let mut n: libc::c_int = 0;
    s = p;
    tm.tm_sec = 0 as libc::c_int;
    tm.tm_min = 0 as libc::c_int;
    tm.tm_hour = 0 as libc::c_int;
    tm.tm_mday = 0 as libc::c_int;
    tm.tm_mon = 0 as libc::c_int;
    tm.tm_year = 0 as libc::c_int;
    tm.tm_wday = 0 as libc::c_int;
    tm.tm_yday = 0 as libc::c_int;
    tm.tm_isdst = 0 as libc::c_int;
    tm.__tm_gmtoff = 0 as libc::c_long;
    tm.__tm_zone = 0 as *const libc::c_char;
    tmp = time_localoffset(1 as libc::c_int);
    localoffset___0 = tmp;
    if *s.offset(len as isize) as libc::c_int != 0 as libc::c_int {
        tmp___0 = malloc((len + 1 as libc::c_int) as size_t);
        pp = tmp___0 as *mut libc::c_char;
        memcpy(pp as *mut libc::c_void, p as *const libc::c_void, len as size_t);
        *pp.offset(len as isize) = '\u{0}' as i32 as libc::c_char;
        s = pp as *const libc::c_char;
    }
    tend = s.offset(len as isize);
    *usec = 0 as libc::c_long;
    tmp___1 = strptime(s, b"%Y.%m.%d\0" as *const u8 as *const libc::c_char, &mut tm);
    t = tmp___1 as *const libc::c_char;
    if t as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___2 = strptime(
            s,
            b"%Y-%m-%d\0" as *const u8 as *const libc::c_char,
            &mut tm,
        );
        t = tmp___2 as *const libc::c_char;
    }
    if t as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___3 = strptime(
            s,
            b"%Y/%m/%d\0" as *const u8 as *const libc::c_char,
            &mut tm,
        );
        t = tmp___3 as *const libc::c_char;
    }
    if t as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___4 = strptime(s, b"%Y%m%d\0" as *const u8 as *const libc::c_char, &mut tm);
        t = tmp___4 as *const libc::c_char;
        if !t.is_null() {
            if !(*t.offset(0 as libc::c_int as isize) as libc::c_int
                == 84 as libc::c_int)
            {
                if !(*t.offset(0 as libc::c_int as isize) as libc::c_int
                    == 32 as libc::c_int)
                {
                    t = 0 as *mut libc::c_void as *const libc::c_char;
                }
            }
        }
    }
    if t as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tmp___5 = strptime(
            s,
            b"%b %d %Y\0" as *const u8 as *const libc::c_char,
            &mut tm,
        );
        t = tmp___5 as *const libc::c_char;
        if !t.is_null() {
            if *t.offset(0 as libc::c_int as isize) as libc::c_int == 58 as libc::c_int {
                t = 0 as *mut libc::c_void as *const libc::c_char;
            }
        }
    }
    if t as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        tt = time(0 as *mut libc::c_void as *mut time_t);
        localtime_r(&mut tt as *mut time_t as *const time_t, &mut tm2 as *mut tm);
        tm.tm_year = tm2.tm_year;
        tmp___6 = strptime(s, b"%b %d\0" as *const u8 as *const libc::c_char, &mut tm);
        t = tmp___6 as *const libc::c_char;
    }
    if !(t as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong) {
        if t as libc::c_ulong == tend as libc::c_ulong {
            tt = mktime(&mut tm);
            tt += localoffset___0 as time_t;
            *sec = tt;
            *usec = 0 as libc::c_long;
            *offset = 50000 as libc::c_int;
            current_block = 2470915176595248889;
        } else {
            tmp___7 = t;
            t = t.offset(1);
            match *tmp___7 as libc::c_int {
                84 => {
                    current_block = 8869332144787829186;
                    match current_block {
                        6917933858253681090 => {
                            while *t as libc::c_int == 32 as libc::c_int {
                                t = t.offset(1);
                            }
                        }
                        _ => {}
                    }
                    tmp___8 = strptime(
                        t,
                        b"%H:%M:%S\0" as *const u8 as *const libc::c_char,
                        &mut tm,
                    );
                    t2 = tmp___8 as *const libc::c_char;
                    if t2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                        tmp___9 = strptime(
                            t,
                            b"%H%M%S\0" as *const u8 as *const libc::c_char,
                            &mut tm,
                        );
                        t2 = tmp___9 as *const libc::c_char;
                    }
                    if t2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                        tmp___10 = strptime(
                            t,
                            b"%H:%M\0" as *const u8 as *const libc::c_char,
                            &mut tm,
                        );
                        t2 = tmp___10 as *const libc::c_char;
                        if t2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
                        {
                            current_block = 8195898779914704147;
                        } else {
                            current_block = 5873035170358615968;
                        }
                    } else {
                        current_block = 5873035170358615968;
                    }
                    match current_block {
                        8195898779914704147 => {}
                        _ => {
                            t = t2;
                            tt = mktime(&mut tm);
                            if *t.offset(0 as libc::c_int as isize) as libc::c_int
                                == 46 as libc::c_int
                            {
                                t = t.offset(1);
                                tmp___11 = scan_num(&mut t, tend);
                                frac = tmp___11 as libc::c_long;
                                if frac < 0 as libc::c_long {
                                    current_block = 8195898779914704147;
                                } else {
                                    if frac > 0 as libc::c_long {
                                        tmp___12 = log10(frac as libc::c_double);
                                        tmp___13 = ceil(tmp___12);
                                        d = tmp___13;
                                        tmp___14 = pow(10.0f64, d);
                                        d = frac as libc::c_double / tmp___14;
                                        *usec = (d * 1000000 as libc::c_int as libc::c_double)
                                            as libc::c_long;
                                    }
                                    current_block = 15237655884915618618;
                                }
                            } else {
                                current_block = 15237655884915618618;
                            }
                            match current_block {
                                8195898779914704147 => {}
                                _ => {
                                    if *t.offset(0 as libc::c_int as isize) as libc::c_int
                                        == 90 as libc::c_int
                                    {
                                        tt += localoffset___0 as time_t;
                                        *offset = 0 as libc::c_int;
                                        current_block = 13349765058737954042;
                                    } else if t as libc::c_ulong == tend as libc::c_ulong {
                                        *offset = localoffset___0;
                                        current_block = 13349765058737954042;
                                    } else {
                                        match *t.offset(0 as libc::c_int as isize) as libc::c_int {
                                            45 | 43 => {
                                                n = parse_tz(
                                                    t,
                                                    tend.offset_from(t) as libc::c_long as strm_int,
                                                );
                                                if n == 60000 as libc::c_int {
                                                    current_block = 8195898779914704147;
                                                } else {
                                                    tt += localoffset___0 as time_t;
                                                    tt -= n as time_t;
                                                    *offset = n;
                                                    current_block = 13349765058737954042;
                                                }
                                            }
                                            _ => {
                                                current_block = 8195898779914704147;
                                            }
                                        }
                                    }
                                    match current_block {
                                        8195898779914704147 => {}
                                        _ => {
                                            *sec = tt;
                                            current_block = 2470915176595248889;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                32 => {
                    current_block = 6917933858253681090;
                    match current_block {
                        6917933858253681090 => {
                            while *t as libc::c_int == 32 as libc::c_int {
                                t = t.offset(1);
                            }
                        }
                        _ => {}
                    }
                    tmp___8 = strptime(
                        t,
                        b"%H:%M:%S\0" as *const u8 as *const libc::c_char,
                        &mut tm,
                    );
                    t2 = tmp___8 as *const libc::c_char;
                    if t2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                        tmp___9 = strptime(
                            t,
                            b"%H%M%S\0" as *const u8 as *const libc::c_char,
                            &mut tm,
                        );
                        t2 = tmp___9 as *const libc::c_char;
                    }
                    if t2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                        tmp___10 = strptime(
                            t,
                            b"%H:%M\0" as *const u8 as *const libc::c_char,
                            &mut tm,
                        );
                        t2 = tmp___10 as *const libc::c_char;
                        if t2 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
                        {
                            current_block = 8195898779914704147;
                        } else {
                            current_block = 5873035170358615968;
                        }
                    } else {
                        current_block = 5873035170358615968;
                    }
                    match current_block {
                        8195898779914704147 => {}
                        _ => {
                            t = t2;
                            tt = mktime(&mut tm);
                            if *t.offset(0 as libc::c_int as isize) as libc::c_int
                                == 46 as libc::c_int
                            {
                                t = t.offset(1);
                                tmp___11 = scan_num(&mut t, tend);
                                frac = tmp___11 as libc::c_long;
                                if frac < 0 as libc::c_long {
                                    current_block = 8195898779914704147;
                                } else {
                                    if frac > 0 as libc::c_long {
                                        tmp___12 = log10(frac as libc::c_double);
                                        tmp___13 = ceil(tmp___12);
                                        d = tmp___13;
                                        tmp___14 = pow(10.0f64, d);
                                        d = frac as libc::c_double / tmp___14;
                                        *usec = (d * 1000000 as libc::c_int as libc::c_double)
                                            as libc::c_long;
                                    }
                                    current_block = 15237655884915618618;
                                }
                            } else {
                                current_block = 15237655884915618618;
                            }
                            match current_block {
                                8195898779914704147 => {}
                                _ => {
                                    if *t.offset(0 as libc::c_int as isize) as libc::c_int
                                        == 90 as libc::c_int
                                    {
                                        tt += localoffset___0 as time_t;
                                        *offset = 0 as libc::c_int;
                                        current_block = 13349765058737954042;
                                    } else if t as libc::c_ulong == tend as libc::c_ulong {
                                        *offset = localoffset___0;
                                        current_block = 13349765058737954042;
                                    } else {
                                        match *t.offset(0 as libc::c_int as isize) as libc::c_int {
                                            45 | 43 => {
                                                n = parse_tz(
                                                    t,
                                                    tend.offset_from(t) as libc::c_long as strm_int,
                                                );
                                                if n == 60000 as libc::c_int {
                                                    current_block = 8195898779914704147;
                                                } else {
                                                    tt += localoffset___0 as time_t;
                                                    tt -= n as time_t;
                                                    *offset = n;
                                                    current_block = 13349765058737954042;
                                                }
                                            }
                                            _ => {
                                                current_block = 8195898779914704147;
                                            }
                                        }
                                    }
                                    match current_block {
                                        8195898779914704147 => {}
                                        _ => {
                                            *sec = tt;
                                            current_block = 2470915176595248889;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                _ => {
                    current_block = 8195898779914704147;
                }
            }
        }
        match current_block {
            8195898779914704147 => {}
            _ => {
                if s as libc::c_ulong != p as libc::c_ulong {
                    free(s as *mut libc::c_char as *mut libc::c_void);
                }
                return 0 as libc::c_int;
            }
        }
    }
    if s as libc::c_ulong != p as libc::c_ulong {
        free(s as *mut libc::c_char as *mut libc::c_void);
    }
    return -(1 as libc::c_int);
}
pub unsafe extern "C" fn strm_time_new(
    mut sec: libc::c_long,
    mut usec: libc::c_long,
    mut offset: libc::c_int,
) -> strm_value {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut v: strm_value = 0;
    let mut tmp: strm_value = 0;
    let mut tmp___0: libc::c_int = 0;
    tv.tv_sec = sec;
    tv.tv_usec = usec;
    tmp___0 = time_alloc(&mut tv, offset, &mut v);
    if tmp___0 == 1 as libc::c_int {
        tmp = strm_nil_value();
        return tmp;
    }
    return v;
}
unsafe extern "C" fn time_time(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut t: time_t = 0;
    let mut utc_offset: libc::c_int = 0;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut slen: libc::c_int = 0;
    let mut sec: libc::c_long = 0;
    let mut usec: libc::c_long = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: strm_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut str: strm_string = 0;
    let mut tmp___5: strm_int = 0;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: strm_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: libc::c_int = 0;
    tv.tv_sec = 0 as libc::c_int as __time_t;
    tv.tv_usec = 0 as libc::c_long;
    tm.tm_sec = 0 as libc::c_int;
    tm.tm_min = 0 as libc::c_int;
    tm.tm_hour = 0 as libc::c_int;
    tm.tm_mday = 0 as libc::c_int;
    tm.tm_mon = 0 as libc::c_int;
    tm.tm_year = 0 as libc::c_int;
    tm.tm_wday = 0 as libc::c_int;
    tm.tm_yday = 0 as libc::c_int;
    tm.tm_isdst = 0 as libc::c_int;
    tm.__tm_gmtoff = 0 as libc::c_long;
    tm.__tm_zone = 0 as *const libc::c_char;
    utc_offset = 0 as libc::c_int;
    let mut current_block_66: u64;
    match argc {
        1 => {
            tmp = strm_parse_args(
                strm,
                argc,
                args,
                b"s\0" as *const u8 as *const libc::c_char,
                &mut s as *mut *mut libc::c_char,
                &mut slen as *mut libc::c_int,
            );
            if tmp == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
            tmp___0 = strm_time_parse_time(
                s as *const libc::c_char,
                slen,
                &mut sec,
                &mut usec,
                &mut utc_offset,
            );
            if tmp___0 < 0 as libc::c_int {
                strm_raise(
                    strm,
                    b"bad time format\0" as *const u8 as *const libc::c_char,
                );
                return 1 as libc::c_int;
            }
            tv.tv_sec = sec;
            tv.tv_usec = usec;
            tmp___1 = time_alloc(&mut tv, utc_offset, ret);
            return tmp___1;
        }
        3 => {
            tm.tm_year = strm_value_int(*args.offset(0 as libc::c_int as isize));
            tmp___2 = strm_value_int(*args.offset(1 as libc::c_int as isize));
            tm.tm_mon = tmp___2 - 1 as libc::c_int;
            tm.tm_mday = strm_value_int(*args.offset(2 as libc::c_int as isize));
            tv.tv_sec = mktime(&mut tm);
            tmp___3 = time_localoffset(1 as libc::c_int);
            tv.tv_sec += tmp___3 as __time_t;
            utc_offset = 50000 as libc::c_int;
            tmp___4 = time_alloc(&mut tv, utc_offset, ret);
            return tmp___4;
        }
        8 => {
            str = *args.offset(7 as libc::c_int as isize);
            tmp___5 = strm_str_len(str);
            tmp___6 = strm_strp_ptr(&mut str);
            utc_offset = parse_tz(tmp___6, tmp___5);
            if utc_offset == 60000 as libc::c_int {
                strm_raise(
                    strm,
                    b"wrong timezeone\0" as *const u8 as *const libc::c_char,
                );
                return 1 as libc::c_int;
            }
            current_block_66 = 4912276487600802613;
        }
        7 => {
            current_block_66 = 4912276487600802613;
        }
        6 => {
            current_block_66 = 9793472745663742675;
        }
        5 => {
            current_block_66 = 3958623233890484478;
        }
        4 => {
            current_block_66 = 18082322151756331283;
        }
        _ => {
            strm_raise(
                strm,
                b"wrong # of arguments\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    }
    match current_block_66 {
        4912276487600802613 => {
            tmp___7 = strm_value_int(*args.offset(6 as libc::c_int as isize));
            tv.tv_usec = (tmp___7 / 1000 as libc::c_int) as __suseconds_t;
            current_block_66 = 9793472745663742675;
        }
        _ => {}
    }
    match current_block_66 {
        9793472745663742675 => {
            tm.tm_sec = strm_value_int(*args.offset(5 as libc::c_int as isize));
            current_block_66 = 3958623233890484478;
        }
        _ => {}
    }
    match current_block_66 {
        3958623233890484478 => {
            tm.tm_min = strm_value_int(*args.offset(4 as libc::c_int as isize));
        }
        _ => {}
    }
    tm.tm_year = strm_value_int(*args.offset(0 as libc::c_int as isize));
    tm.tm_mon = strm_value_int(*args.offset(1 as libc::c_int as isize));
    tm.tm_mday = strm_value_int(*args.offset(2 as libc::c_int as isize));
    tm.tm_hour = strm_value_int(*args.offset(3 as libc::c_int as isize));
    t = mktime(&mut tm);
    tv.tv_sec = t;
    if argc == 8 as libc::c_int {
        tmp___8 = time_localoffset(1 as libc::c_int);
        tv.tv_sec += tmp___8 as __time_t;
        tv.tv_sec -= utc_offset as __time_t;
    } else {
        utc_offset = time_localoffset(0 as libc::c_int);
    }
    tmp___9 = time_alloc(&mut tv, utc_offset, ret);
    return tmp___9;
}
unsafe extern "C" fn time_now(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut utc_offset: libc::c_int = 0;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut slen: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    if argc == 0 as libc::c_int {
        utc_offset = time_localoffset(0 as libc::c_int);
    } else {
        tmp = strm_parse_args(
            strm,
            argc,
            args,
            b"s\0" as *const u8 as *const libc::c_char,
            &mut s as *mut *mut libc::c_char,
            &mut slen as *mut strm_int,
        );
        if tmp == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
        utc_offset = parse_tz(s as *const libc::c_char, slen);
        if utc_offset == 60000 as libc::c_int {
            strm_raise(strm, b"wrong timezeone\0" as *const u8 as *const libc::c_char);
            return 1 as libc::c_int;
        }
    }
    gettimeofday(&mut tv as *mut timeval, 0 as *mut libc::c_void);
    tmp___0 = time_alloc(&mut tv, utc_offset, ret);
    return tmp___0;
}
unsafe extern "C" fn get_time(mut val: strm_value) -> *mut strm_time {
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strm_value_ptr(val, STRM_PTR_AUX);
    t = tmp as *mut strm_time;
    if (*t).ns as libc::c_ulong != ns_time as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut strm_time;
    }
    return t;
}
unsafe extern "C" fn time_plus(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut t1: *mut strm_time = 0 as *mut strm_time;
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tv2: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_int = 0;
    if argc != 2 as libc::c_int {
        strm_raise(strm, b"wrong # of arguments\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    t1 = get_time(*args.offset(0 as libc::c_int as isize));
    tmp = strm_number_p(*args.offset(1 as libc::c_int as isize));
    if tmp == 0 {
        strm_raise(strm, b"number required\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = strm_value_float(*args.offset(1 as libc::c_int as isize));
    num_to_timeval(tmp___0, &mut tv);
    tv2.tv_sec = (*t1).tv.tv_sec + tv.tv_sec;
    tv2.tv_usec = (*t1).tv.tv_usec + tv.tv_usec;
    while tv2.tv_usec >= 1000000 as libc::c_long {
        tv2.tv_sec += 1;
        tv2.tv_usec -= 1000000 as libc::c_long;
    }
    tmp___1 = time_alloc(&mut tv2, (*t1).utc_offset, ret);
    return tmp___1;
}
unsafe extern "C" fn time_minus(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut t1: *mut strm_time = 0 as *mut strm_time;
    let mut t2: *mut strm_time = 0 as *mut strm_time;
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut d: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    if argc != 2 as libc::c_int {
        strm_raise(strm, b"wrong # of arguments\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = strm_number_p(*args.offset(1 as libc::c_int as isize));
    if tmp___0 != 0 {
        d = strm_value_float(*args.offset(1 as libc::c_int as isize));
        *args.offset(1 as libc::c_int as isize) = strm_float_value(-d);
        tmp = time_plus(strm, argc, args, ret);
        return tmp;
    }
    t1 = get_time(*args.offset(0 as libc::c_int as isize));
    t2 = get_time(*args.offset(1 as libc::c_int as isize));
    tv.tv_sec = (*t1).tv.tv_sec - (*t2).tv.tv_sec;
    tv.tv_usec = (*t1).tv.tv_usec - (*t2).tv.tv_usec;
    while tv.tv_usec < 0 as libc::c_long {
        tv.tv_sec -= 1;
        tv.tv_usec += 1000000 as libc::c_long;
    }
    d = timeval_to_num(&mut tv);
    *ret = strm_float_value(d);
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_tm(
    mut t: time_t,
    mut utc_offset: libc::c_int,
    mut tm: *mut tm,
) {
    t += utc_offset as time_t;
    gmtime_r(&mut t as *mut time_t as *const time_t, tm);
}
unsafe extern "C" fn time_str(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut utc_offset: libc::c_int = 0;
    let mut buf: [libc::c_char; 256] = [0; 256];
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut n: size_t = 0;
    let mut time___0: strm_value = 0;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut slen: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut sbuf: [libc::c_char; 20] = [0; 20];
    let mut d: libc::c_double = 0.;
    let mut t___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: size_t = 0;
    let mut off: libc::c_int = 0;
    let mut sign: libc::c_char = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: size_t = 0;
    if argc == 1 as libc::c_int {
        t = get_time(*args.offset(0 as libc::c_int as isize));
        utc_offset = (*t).utc_offset;
    } else {
        tmp = strm_parse_args(
            strm,
            argc,
            args,
            b"v|s\0" as *const u8 as *const libc::c_char,
            &mut time___0 as *mut strm_value,
            &mut s as *mut *mut libc::c_char,
            &mut slen as *mut strm_int,
        );
        if tmp == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
        t = get_time(time___0);
        utc_offset = parse_tz(s as *const libc::c_char, slen);
        if utc_offset == 60000 as libc::c_int {
            strm_raise(strm, b"wrong timezeone\0" as *const u8 as *const libc::c_char);
            return 1 as libc::c_int;
        }
    }
    if utc_offset == 50000 as libc::c_int {
        get_tm((*t).tv.tv_sec, 0 as libc::c_int, &mut tm);
        if tm.tm_hour == 0 as libc::c_int {
            if tm.tm_min == 0 as libc::c_int {
                if tm.tm_sec == 0 as libc::c_int {
                    n = strftime(
                        buf.as_mut_ptr(),
                        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                        b"%Y.%m.%d\0" as *const u8 as *const libc::c_char,
                        &mut tm as *mut tm as *const tm,
                    );
                    *ret = strm_str_new(
                        buf.as_mut_ptr() as *const libc::c_char,
                        n as strm_int,
                    );
                    return 0 as libc::c_int;
                }
            }
        }
        utc_offset = 0 as libc::c_int;
    }
    get_tm((*t).tv.tv_sec, utc_offset, &mut tm);
    n = strftime(
        buf.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
        b"%Y.%m.%dT%H:%M:%S\0" as *const u8 as *const libc::c_char,
        &mut tm as *mut tm as *const tm,
    );
    p = buf.as_mut_ptr().offset(n as isize);
    if (*t).tv.tv_usec != 0 as libc::c_long {
        d = (*t).tv.tv_usec as libc::c_double / 1000000.0f64;
        snprintf(
            sbuf.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
            b"%.3f\0" as *const u8 as *const libc::c_char,
            d,
        );
        t___0 = sbuf.as_mut_ptr().offset(1 as libc::c_int as isize);
        len = strlen(t___0 as *const libc::c_char);
        strncpy(p, t___0 as *const libc::c_char, len);
        p = p.offset(len as isize);
    }
    if utc_offset == 0 as libc::c_int {
        *p.offset(0 as libc::c_int as isize) = 'Z' as i32 as libc::c_char;
        *p.offset(1 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
    } else {
        off = utc_offset / 60 as libc::c_int;
        if off > 0 as libc::c_int {
            tmp___0 = '+' as i32;
        } else {
            tmp___0 = '-' as i32;
        }
        sign = tmp___0 as libc::c_char;
        if off < 0 as libc::c_int {
            off = -off;
        }
        snprintf(
            p,
            (::std::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
                .wrapping_sub(
                    p.offset_from(buf.as_mut_ptr()) as libc::c_long as libc::c_ulong,
                ),
            b"%c%02d:%02d\0" as *const u8 as *const libc::c_char,
            sign as libc::c_int,
            off / 60 as libc::c_int,
            off % 60 as libc::c_int,
        );
    }
    tmp___1 = strlen(buf.as_mut_ptr() as *const libc::c_char);
    *ret = strm_str_new(buf.as_mut_ptr() as *const libc::c_char, tmp___1 as strm_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_num(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    if (*t).tv.tv_usec == 0 as libc::c_long {
        *ret = strm_int_value((*t).tv.tv_sec as strm_int);
    } else {
        tmp___0 = timeval_to_num(&mut (*t).tv);
        *ret = strm_float_value(tmp___0);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_year(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    get_tm((*t).tv.tv_sec, (*t).utc_offset, &mut tm);
    *ret = strm_int_value(tm.tm_year + 1900 as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_month(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    get_tm((*t).tv.tv_sec, (*t).utc_offset, &mut tm);
    *ret = strm_int_value(tm.tm_mon + 1 as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_day(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    get_tm((*t).tv.tv_sec, (*t).utc_offset, &mut tm);
    *ret = strm_int_value(tm.tm_mday);
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_hour(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    get_tm((*t).tv.tv_sec, (*t).utc_offset, &mut tm);
    *ret = strm_int_value(tm.tm_hour);
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_min(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    get_tm((*t).tv.tv_sec, (*t).utc_offset, &mut tm);
    *ret = strm_int_value(tm.tm_min);
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_sec(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    get_tm((*t).tv.tv_sec, (*t).utc_offset, &mut tm);
    *ret = strm_int_value(tm.tm_sec);
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_weekday(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tm: tm = tm {
        tm_sec: 0,
        tm_min: 0,
        tm_hour: 0,
        tm_mday: 0,
        tm_mon: 0,
        tm_year: 0,
        tm_wday: 0,
        tm_yday: 0,
        tm_isdst: 0,
        __tm_gmtoff: 0,
        __tm_zone: 0 as *const libc::c_char,
    };
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    get_tm((*t).tv.tv_sec, (*t).utc_offset, &mut tm);
    *ret = strm_int_value(tm.tm_wday);
    return 0 as libc::c_int;
}
unsafe extern "C" fn time_nanosec(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut time___0: strm_value = 0;
    let mut t: *mut strm_time = 0 as *mut strm_time;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut time___0 as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = get_time(time___0);
    *ret = strm_int_value(((*t).tv.tv_usec * 1000 as libc::c_long) as strm_int);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_time_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: strm_value = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: strm_value = 0;
    let mut tmp___7: strm_value = 0;
    let mut tmp___8: strm_value = 0;
    let mut tmp___9: strm_value = 0;
    let mut tmp___10: strm_value = 0;
    let mut tmp___11: strm_value = 0;
    let mut tmp___12: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            time_now
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"now\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            time_time
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"time\0" as *const u8 as *const libc::c_char, tmp___0);
    ns_time = strm_ns_new(
        0 as *mut libc::c_void as *mut strm_state,
        b"time\0" as *const u8 as *const libc::c_char,
    );
    tmp___1 = strm_cfunc_value(
        Some(
            time_plus
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"+\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            time_minus
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"-\0" as *const u8 as *const libc::c_char, tmp___2);
    tmp___3 = strm_cfunc_value(
        Some(
            time_str
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"string\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = strm_cfunc_value(
        Some(
            time_num
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"number\0" as *const u8 as *const libc::c_char, tmp___4);
    tmp___5 = strm_cfunc_value(
        Some(
            time_year
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"year\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = strm_cfunc_value(
        Some(
            time_month
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"month\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = strm_cfunc_value(
        Some(
            time_day
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"day\0" as *const u8 as *const libc::c_char, tmp___7);
    tmp___8 = strm_cfunc_value(
        Some(
            time_hour
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"hour\0" as *const u8 as *const libc::c_char, tmp___8);
    tmp___9 = strm_cfunc_value(
        Some(
            time_min
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"minute\0" as *const u8 as *const libc::c_char, tmp___9);
    tmp___10 = strm_cfunc_value(
        Some(
            time_sec
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"second\0" as *const u8 as *const libc::c_char, tmp___10);
    tmp___11 = strm_cfunc_value(
        Some(
            time_nanosec
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"nanosecond\0" as *const u8 as *const libc::c_char, tmp___11);
    tmp___12 = strm_cfunc_value(
        Some(
            time_weekday
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_time, b"weekday\0" as *const u8 as *const libc::c_char, tmp___12);
}
pub unsafe extern "C" fn strm_queue_new() -> *mut strm_queue {
    let mut q: *mut strm_queue = 0 as *mut strm_queue;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<strm_queue>() as libc::c_ulong);
    q = tmp as *mut strm_queue;
    if q as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut strm_queue;
    }
    (*q).head = 0 as *mut libc::c_void as *mut strm_queue_node;
    (*q).tail = 0 as *mut libc::c_void as *mut strm_queue_node;
    pthread_mutex_init(
        &mut (*q).mutex,
        0 as *mut libc::c_void as *const pthread_mutexattr_t,
    );
    return q;
}
pub unsafe extern "C" fn strm_queue_add(
    mut q: *mut strm_queue,
    mut val: *mut libc::c_void,
) -> libc::c_int {
    let mut node: *mut strm_queue_node = 0 as *mut strm_queue_node;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<strm_queue_node>() as libc::c_ulong);
    node = tmp as *mut strm_queue_node;
    if node as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as libc::c_int;
    }
    (*node).n = val;
    (*node).next = 0 as *mut libc::c_void as *mut strm_queue_node;
    pthread_mutex_lock(&mut (*q).mutex);
    if !((*q).tail).is_null() {
        (*(*q).tail).next = node;
    }
    (*q).tail = node;
    if ((*q).head).is_null() {
        (*q).head = node;
    }
    pthread_mutex_unlock(&mut (*q).mutex);
    return 1 as libc::c_int;
}
pub unsafe extern "C" fn strm_queue_get(mut q: *mut strm_queue) -> *mut libc::c_void {
    let mut t: *mut strm_queue_node = 0 as *mut strm_queue_node;
    let mut n: *mut libc::c_void = 0 as *mut libc::c_void;
    pthread_mutex_lock(&mut (*q).mutex);
    if ((*q).head).is_null() {
        pthread_mutex_unlock(&mut (*q).mutex);
        return 0 as *mut libc::c_void;
    }
    t = (*q).head;
    (*q).head = (*t).next;
    if (*q).head as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*q).tail = 0 as *mut libc::c_void as *mut strm_queue_node;
    }
    pthread_mutex_unlock(&mut (*q).mutex);
    n = (*t).n;
    free(t as *mut libc::c_void);
    return n;
}
pub unsafe extern "C" fn strm_queue_free(mut q: *mut strm_queue) {
    let mut t: *mut strm_queue_node = 0 as *mut strm_queue_node;
    let mut tmp: *mut strm_queue_node = 0 as *mut strm_queue_node;
    if q.is_null() {
        return;
    }
    if !((*q).head).is_null() {
        t = (*q).head;
        while !t.is_null() {
            tmp = (*t).next;
            free(t as *mut libc::c_void);
            t = tmp;
        }
    }
    pthread_mutex_destroy(&mut (*q).mutex);
    free(q as *mut libc::c_void);
}
pub unsafe extern "C" fn strm_queue_empty_p(mut q: *mut strm_queue) -> libc::c_int {
    if (*q).head as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_init(mut state: *mut strm_state) {
    strm_number_init(state);
    strm_array_init(state);
    strm_string_init(state);
    strm_latch_init(state);
    strm_iter_init(state);
    strm_socket_init(state);
    strm_csv_init(state);
    strm_kvs_init(state);
    strm_time_init(state);
    strm_math_init(state);
    strm_graph_init(state);
}
pub unsafe extern "C" fn strm_ptr_value(mut p: *mut libc::c_void) -> strm_value {
    return (18445899648779419648 as libc::c_ulonglong
        | (p as intptr_t as strm_value
            & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as libc::c_ulonglong)
        as strm_value;
}
pub unsafe extern "C" fn strm_cfunc_value(
    mut f: Option::<
        unsafe extern "C" fn(
            *mut strm_stream,
            libc::c_int,
            *mut strm_value,
            *mut strm_value,
        ) -> libc::c_int,
    >,
) -> strm_value {
    return (18445336698825998336 as libc::c_ulonglong
        | (::std::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
            >,
            intptr_t,
        >(f) as strm_value & !((65535 as libc::c_ulong) << 48 as libc::c_int))
            as libc::c_ulonglong) as strm_value;
}
pub unsafe extern "C" fn strm_bool_value(mut i: libc::c_int) -> strm_value {
    return (18442521949058891776 as libc::c_ulonglong
        | (i != 0) as libc::c_int as libc::c_ulong as libc::c_ulonglong) as strm_value;
}
pub unsafe extern "C" fn strm_int_value(mut i: libc::c_int) -> strm_value {
    return (18442803424035602432 as libc::c_ulonglong
        | (i as uint64_t & !((65535 as libc::c_ulong) << 48 as libc::c_int))
            as libc::c_ulonglong) as strm_value;
}
pub unsafe extern "C" fn strm_float_value(mut f: libc::c_double) -> strm_value {
    let mut u: __anonunion_u_274369385 = __anonunion_u_274369385 { f: 0. };
    let mut tmp: libc::c_int = 0;
    tmp = f.is_nan() as i32;
    if tmp != 0 {
        return 18442240474082181120 as libc::c_ulonglong as strm_value;
    }
    u.f = f;
    return u.i;
}
pub unsafe extern "C" fn strm_foreign_value(mut p: *mut libc::c_void) -> strm_value {
    return (18446462598732840960 as libc::c_ulonglong
        | (p as intptr_t as strm_value
            & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as libc::c_ulonglong)
        as strm_value;
}
unsafe extern "C" fn strm_ptr(mut v: strm_value) -> *mut libc::c_void {
    return (v & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
        as *mut libc::c_void;
}
unsafe extern "C" fn strm_ptr_type(mut p: *mut libc::c_void) -> strm_ptr_type {
    let mut obj: *mut object = 0 as *mut object;
    obj = p as *mut object;
    return (*obj).type_0;
}
pub unsafe extern "C" fn strm_value_ptr(
    mut v: strm_value,
    mut e: strm_ptr_type,
) -> *mut libc::c_void {
    let mut p: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: strm_ptr_type = STRM_PTR_STREAM;
    if !((v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18445899648779419648 as libc::c_ulonglong)
    {
        __assert_fail(
            b"strm_value_tag(v) == STRM_TAG_PTR\0" as *const u8 as *const libc::c_char,
            b"value.c\0" as *const u8 as *const libc::c_char,
            72 as libc::c_uint,
            b"strm_value_ptr\0" as *const u8 as *const libc::c_char,
        );
    }
    p = strm_ptr(v);
    if !p.is_null() {
        tmp___3 = strm_ptr_type(p);
        if !(tmp___3 as libc::c_uint == e as libc::c_uint) {
            __assert_fail(
                b"p && strm_ptr_type(p) == e\0" as *const u8 as *const libc::c_char,
                b"value.c\0" as *const u8 as *const libc::c_char,
                74 as libc::c_uint,
                b"strm_value_ptr\0" as *const u8 as *const libc::c_char,
            );
        }
    } else {
        __assert_fail(
            b"p && strm_ptr_type(p) == e\0" as *const u8 as *const libc::c_char,
            b"value.c\0" as *const u8 as *const libc::c_char,
            74 as libc::c_uint,
            b"strm_value_ptr\0" as *const u8 as *const libc::c_char,
        );
    }
    return p;
}
pub unsafe extern "C" fn strm_value_foreign(mut v: strm_value) -> *mut libc::c_void {
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    if !((v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18446462598732840960 as libc::c_ulonglong)
    {
        __assert_fail(
            b"strm_value_tag(v) == STRM_TAG_FOREIGN\0" as *const u8
                as *const libc::c_char,
            b"value.c\0" as *const u8 as *const libc::c_char,
            81 as libc::c_uint,
            b"strm_value_foreign\0" as *const u8 as *const libc::c_char,
        );
    }
    tmp___0 = strm_ptr(v);
    return tmp___0;
}
pub unsafe extern "C" fn strm_value_bool(mut v: strm_value) -> libc::c_int {
    let mut i: uint64_t = 0;
    i = v & !((65535 as libc::c_ulong) << 48 as libc::c_int);
    if i == 0 as libc::c_ulong {
        match v & (65535 as libc::c_ulong) << 48 as libc::c_int {
            18445899648779419648 | 18442521949058891776 => {}
            _ => {
                if !((v & (65535 as libc::c_ulong) << 48 as libc::c_int)
                    as libc::c_ulonglong == 18442521949058891776 as libc::c_ulonglong)
                {
                    __assert_fail(
                        b"strm_value_tag(v) == STRM_TAG_BOOL\0" as *const u8
                            as *const libc::c_char,
                        b"value.c\0" as *const u8 as *const libc::c_char,
                        96 as libc::c_uint,
                        b"strm_value_bool\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
        }
        return 0 as libc::c_int;
    } else {
        return 1 as libc::c_int
    };
}
pub unsafe extern "C" fn strm_int_p(mut v: strm_value) -> libc::c_int {
    return ((v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18442803424035602432 as libc::c_ulonglong) as libc::c_int;
}
#[inline]
unsafe extern "C" fn strm_to_int(mut v: strm_value) -> int32_t {
    return (v & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as int32_t;
}
pub unsafe extern "C" fn strm_float_p(mut v: strm_value) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    if v as libc::c_ulonglong == 18442240474082181120 as libc::c_ulonglong {
        tmp = 1 as libc::c_int;
    } else if v as libc::c_ulonglong & 18442240474082181120 as libc::c_ulonglong
            != 18442240474082181120 as libc::c_ulonglong
        {
        tmp = 1 as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp;
}
#[inline]
unsafe extern "C" fn strm_to_float(mut v: strm_value) -> libc::c_double {
    let mut u: __anonunion_u_274369386 = __anonunion_u_274369386 { f: 0. };
    u.i = v;
    return u.f;
}
pub unsafe extern "C" fn strm_value_int(mut v: strm_value) -> libc::c_int {
    let mut tmp: int32_t = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_int = 0;
    match v & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18442803424035602432 => {
            tmp = strm_to_int(v);
            return tmp;
        }
        _ => {
            tmp___1 = strm_float_p(v);
            if tmp___1 != 0 {
                tmp___0 = strm_to_float(v);
                return tmp___0 as libc::c_int;
            }
            if !((v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
                == 18442803424035602432 as libc::c_ulonglong)
            {
                __assert_fail(
                    b"strm_value_tag(v) == STRM_TAG_INT\0" as *const u8
                        as *const libc::c_char,
                    b"value.c\0" as *const u8 as *const libc::c_char,
                    146 as libc::c_uint,
                    b"strm_value_int\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_value_float(mut v: strm_value) -> libc::c_double {
    let mut tmp: int32_t = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    tmp___6 = strm_int_p(v);
    if tmp___6 != 0 {
        tmp = strm_to_int(v);
        return tmp as libc::c_double;
    } else {
        tmp___5 = strm_float_p(v);
        if tmp___5 != 0 {
            tmp___0 = strm_to_float(v);
            return tmp___0;
        } else {
            tmp___4 = strm_float_p(v);
            if tmp___4 == 0 {
                __assert_fail(
                    b"strm_float_p(v)\0" as *const u8 as *const libc::c_char,
                    b"value.c\0" as *const u8 as *const libc::c_char,
                    164 as libc::c_uint,
                    b"strm_value_float\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    return 0.0f64;
}
pub unsafe extern "C" fn strm_value_cfunc(mut v: strm_value) -> strm_cfunc {
    if !((v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18445336698825998336 as libc::c_ulonglong)
    {
        __assert_fail(
            b"strm_value_tag(v) == STRM_TAG_CFUNC\0" as *const u8 as *const libc::c_char,
            b"value.c\0" as *const u8 as *const libc::c_char,
            173 as libc::c_uint,
            b"strm_value_cfunc\0" as *const u8 as *const libc::c_char,
        );
    }
    return ::std::mem::transmute::<
        libc::intptr_t,
        Option::<
            unsafe extern "C" fn(
                *mut strm_stream,
                libc::c_int,
                *mut strm_value,
                *mut strm_value,
            ) -> libc::c_int,
        >,
    >(
        (v & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
            as libc::intptr_t,
    );
}
pub unsafe extern "C" fn strm_number_p(mut v: strm_value) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = strm_int_p(v);
    if tmp != 0 {
        return 1 as libc::c_int
    } else {
        tmp___0 = strm_float_p(v);
        if tmp___0 != 0 { return 1 as libc::c_int } else { return 0 as libc::c_int }
    };
}
pub unsafe extern "C" fn strm_bool_p(mut v: strm_value) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    if (v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18442521949058891776 as libc::c_ulonglong
    {
        tmp = 1 as libc::c_int;
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp;
}
pub unsafe extern "C" fn strm_nil_p(mut v: strm_value) -> libc::c_int {
    if (v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        != 18445899648779419648 as libc::c_ulonglong
    {
        return 0 as libc::c_int;
    }
    return (v & !((65535 as libc::c_ulong) << 48 as libc::c_int) == 0 as libc::c_ulong)
        as libc::c_int;
}
pub unsafe extern "C" fn strm_cfunc_p(mut v: strm_value) -> libc::c_int {
    return ((v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18445336698825998336 as libc::c_ulonglong) as libc::c_int;
}
pub unsafe extern "C" fn strm_ptr_tag_p(
    mut v: strm_value,
    mut e: strm_ptr_type,
) -> libc::c_int {
    let mut p: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: strm_ptr_type = STRM_PTR_STREAM;
    if (v & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18445899648779419648 as libc::c_ulonglong
    {
        tmp = strm_ptr(v);
        p = tmp;
        tmp___0 = strm_ptr_type(p);
        return (tmp___0 as libc::c_uint == e as libc::c_uint) as libc::c_int;
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_value_eq(
    mut a: strm_value,
    mut b: strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut current_block_18: u64;
    if a == b {
        return 1 as libc::c_int;
    }
    if !(a & (65535 as libc::c_ulong) << 48 as libc::c_int
        != b & (65535 as libc::c_ulong) << 48 as libc::c_int)
    {
        match a & (65535 as libc::c_ulong) << 48 as libc::c_int {
            18443647848965734400 | 18443366373989023744 => {
                current_block_18 = 14585597296120879182;
                match current_block_18 {
                    3146822544606917427 => {
                        return ((a & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                            as intptr_t as *mut libc::c_void as libc::c_ulong
                            == (b & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                as intptr_t as *mut libc::c_void as libc::c_ulong)
                            as libc::c_int;
                    }
                    14585597296120879182 => {
                        tmp = strm_ary_eq(a, b);
                        return tmp;
                    }
                    669991627213175712 => {
                        return (::std::mem::transmute::<
                            Option::<
                                unsafe extern "C" fn(
                                    *mut strm_stream,
                                    libc::c_int,
                                    *mut strm_value,
                                    *mut strm_value,
                                ) -> libc::c_int,
                            >,
                            libc::c_ulong,
                        >(
                            ::std::mem::transmute::<
                                libc::intptr_t,
                                Option::<
                                    unsafe extern "C" fn(
                                        *mut strm_stream,
                                        libc::c_int,
                                        *mut strm_value,
                                        *mut strm_value,
                                    ) -> libc::c_int,
                                >,
                            >(
                                (a & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                    as intptr_t as libc::intptr_t,
                            ),
                        )
                            == ::std::mem::transmute::<
                                Option::<
                                    unsafe extern "C" fn(
                                        *mut strm_stream,
                                        libc::c_int,
                                        *mut strm_value,
                                        *mut strm_value,
                                    ) -> libc::c_int,
                                >,
                                libc::c_ulong,
                            >(
                                ::std::mem::transmute::<
                                    libc::intptr_t,
                                    Option::<
                                        unsafe extern "C" fn(
                                            *mut strm_stream,
                                            libc::c_int,
                                            *mut strm_value,
                                            *mut strm_value,
                                        ) -> libc::c_int,
                                    >,
                                >(
                                    (b & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                        as intptr_t as libc::intptr_t,
                                ),
                            )) as libc::c_int;
                    }
                    _ => {
                        tmp___0 = strm_str_eq(a, b);
                        return tmp___0;
                    }
                }
            }
            18445055223849287680 | 18444773748872577024 => {
                current_block_18 = 6792483586390751536;
                match current_block_18 {
                    3146822544606917427 => {
                        return ((a & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                            as intptr_t as *mut libc::c_void as libc::c_ulong
                            == (b & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                as intptr_t as *mut libc::c_void as libc::c_ulong)
                            as libc::c_int;
                    }
                    14585597296120879182 => {
                        tmp = strm_ary_eq(a, b);
                        return tmp;
                    }
                    669991627213175712 => {
                        return (::std::mem::transmute::<
                            Option::<
                                unsafe extern "C" fn(
                                    *mut strm_stream,
                                    libc::c_int,
                                    *mut strm_value,
                                    *mut strm_value,
                                ) -> libc::c_int,
                            >,
                            libc::c_ulong,
                        >(
                            ::std::mem::transmute::<
                                libc::intptr_t,
                                Option::<
                                    unsafe extern "C" fn(
                                        *mut strm_stream,
                                        libc::c_int,
                                        *mut strm_value,
                                        *mut strm_value,
                                    ) -> libc::c_int,
                                >,
                            >(
                                (a & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                    as intptr_t as libc::intptr_t,
                            ),
                        )
                            == ::std::mem::transmute::<
                                Option::<
                                    unsafe extern "C" fn(
                                        *mut strm_stream,
                                        libc::c_int,
                                        *mut strm_value,
                                        *mut strm_value,
                                    ) -> libc::c_int,
                                >,
                                libc::c_ulong,
                            >(
                                ::std::mem::transmute::<
                                    libc::intptr_t,
                                    Option::<
                                        unsafe extern "C" fn(
                                            *mut strm_stream,
                                            libc::c_int,
                                            *mut strm_value,
                                            *mut strm_value,
                                        ) -> libc::c_int,
                                    >,
                                >(
                                    (b & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                        as intptr_t as libc::intptr_t,
                                ),
                            )) as libc::c_int;
                    }
                    _ => {
                        tmp___0 = strm_str_eq(a, b);
                        return tmp___0;
                    }
                }
            }
            18445336698825998336 => {
                current_block_18 = 669991627213175712;
                match current_block_18 {
                    3146822544606917427 => {
                        return ((a & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                            as intptr_t as *mut libc::c_void as libc::c_ulong
                            == (b & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                as intptr_t as *mut libc::c_void as libc::c_ulong)
                            as libc::c_int;
                    }
                    14585597296120879182 => {
                        tmp = strm_ary_eq(a, b);
                        return tmp;
                    }
                    669991627213175712 => {
                        return (::std::mem::transmute::<
                            Option::<
                                unsafe extern "C" fn(
                                    *mut strm_stream,
                                    libc::c_int,
                                    *mut strm_value,
                                    *mut strm_value,
                                ) -> libc::c_int,
                            >,
                            libc::c_ulong,
                        >(
                            ::std::mem::transmute::<
                                libc::intptr_t,
                                Option::<
                                    unsafe extern "C" fn(
                                        *mut strm_stream,
                                        libc::c_int,
                                        *mut strm_value,
                                        *mut strm_value,
                                    ) -> libc::c_int,
                                >,
                            >(
                                (a & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                    as intptr_t as libc::intptr_t,
                            ),
                        )
                            == ::std::mem::transmute::<
                                Option::<
                                    unsafe extern "C" fn(
                                        *mut strm_stream,
                                        libc::c_int,
                                        *mut strm_value,
                                        *mut strm_value,
                                    ) -> libc::c_int,
                                >,
                                libc::c_ulong,
                            >(
                                ::std::mem::transmute::<
                                    libc::intptr_t,
                                    Option::<
                                        unsafe extern "C" fn(
                                            *mut strm_stream,
                                            libc::c_int,
                                            *mut strm_value,
                                            *mut strm_value,
                                        ) -> libc::c_int,
                                    >,
                                >(
                                    (b & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                        as intptr_t as libc::intptr_t,
                                ),
                            )) as libc::c_int;
                    }
                    _ => {
                        tmp___0 = strm_str_eq(a, b);
                        return tmp___0;
                    }
                }
            }
            18445899648779419648 => {
                current_block_18 = 3146822544606917427;
                match current_block_18 {
                    3146822544606917427 => {
                        return ((a & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                            as intptr_t as *mut libc::c_void as libc::c_ulong
                            == (b & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                as intptr_t as *mut libc::c_void as libc::c_ulong)
                            as libc::c_int;
                    }
                    14585597296120879182 => {
                        tmp = strm_ary_eq(a, b);
                        return tmp;
                    }
                    669991627213175712 => {
                        return (::std::mem::transmute::<
                            Option::<
                                unsafe extern "C" fn(
                                    *mut strm_stream,
                                    libc::c_int,
                                    *mut strm_value,
                                    *mut strm_value,
                                ) -> libc::c_int,
                            >,
                            libc::c_ulong,
                        >(
                            ::std::mem::transmute::<
                                libc::intptr_t,
                                Option::<
                                    unsafe extern "C" fn(
                                        *mut strm_stream,
                                        libc::c_int,
                                        *mut strm_value,
                                        *mut strm_value,
                                    ) -> libc::c_int,
                                >,
                            >(
                                (a & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                    as intptr_t as libc::intptr_t,
                            ),
                        )
                            == ::std::mem::transmute::<
                                Option::<
                                    unsafe extern "C" fn(
                                        *mut strm_stream,
                                        libc::c_int,
                                        *mut strm_value,
                                        *mut strm_value,
                                    ) -> libc::c_int,
                                >,
                                libc::c_ulong,
                            >(
                                ::std::mem::transmute::<
                                    libc::intptr_t,
                                    Option::<
                                        unsafe extern "C" fn(
                                            *mut strm_stream,
                                            libc::c_int,
                                            *mut strm_value,
                                            *mut strm_value,
                                        ) -> libc::c_int,
                                    >,
                                >(
                                    (b & !((65535 as libc::c_ulong) << 48 as libc::c_int))
                                        as intptr_t as libc::intptr_t,
                                ),
                            )) as libc::c_int;
                    }
                    _ => {
                        tmp___0 = strm_str_eq(a, b);
                        return tmp___0;
                    }
                }
            }
            _ => {}
        }
    }
    tmp___3 = strm_number_p(a);
    if tmp___3 != 0 {
        tmp___4 = strm_number_p(b);
        if tmp___4 != 0 {
            tmp___1 = strm_value_float(a);
            tmp___2 = strm_value_float(b);
            return (tmp___1 == tmp___2) as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_symbol_p(mut str: strm_string) -> libc::c_int {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut pend: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___2: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    tmp = strm_strp_ptr(&mut str);
    p = tmp;
    tmp___0 = strm_str_len(str);
    pend = p.offset(tmp___0 as isize);
    tmp___1 = __ctype_b_loc();
    if *(*tmp___1).offset(*p as libc::c_int as isize) as libc::c_int
        & 1024 as libc::c_int == 0
    {
        if *p as libc::c_int != 95 as libc::c_int {
            return 0 as libc::c_int;
        }
    }
    p = p.offset(1);
    while (p as libc::c_ulong) < pend as libc::c_ulong {
        tmp___2 = __ctype_b_loc();
        if *(*tmp___2).offset(*p as libc::c_int as isize) as libc::c_int
            & 8 as libc::c_int == 0
        {
            if *p as libc::c_int != 95 as libc::c_int {
                return 0 as libc::c_int;
            }
        }
        p = p.offset(1);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn str_dump_len(mut str: strm_string) -> strm_int {
    let mut len: strm_int = 0;
    let mut p: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut pend: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    len = 2 as libc::c_int;
    tmp = strm_strp_ptr(&mut str);
    p = tmp as *mut libc::c_uchar as *const libc::c_uchar;
    tmp___0 = strm_str_len(str);
    pend = p.offset(tmp___0 as isize);
    while (p as libc::c_ulong) < pend as libc::c_ulong {
        match *p as libc::c_int {
            34 | 9 | 13 | 10 => {
                len += 2 as libc::c_int;
            }
            _ => {
                tmp___1 = __ctype_b_loc();
                if *(*tmp___1).offset(*p as libc::c_int as isize) as libc::c_int
                    & 16384 as libc::c_int != 0
                {
                    len += 1;
                } else if *p as libc::c_int & 255 as libc::c_int > 127 as libc::c_int {
                    len += 1;
                } else {
                    len += 3 as libc::c_int;
                }
            }
        }
        p = p.offset(1);
    }
    return len;
}
unsafe extern "C" fn str_dump(mut str: strm_string, mut len: strm_int) -> strm_string {
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut pend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: strm_int = 0;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___8: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___9: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___10: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___11: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___12: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___13: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___14: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___15: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___16: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___17: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___18: strm_string = 0;
    tmp = malloc(len as size_t);
    buf = tmp as *mut libc::c_char;
    s = buf;
    tmp___0 = strm_strp_ptr(&mut str);
    p = tmp___0 as *mut libc::c_char;
    tmp___1 = strm_str_len(str);
    pend = p.offset(tmp___1 as isize);
    tmp___2 = s;
    s = s.offset(1);
    *tmp___2 = '"' as i32 as libc::c_char;
    while (p as libc::c_ulong) < pend as libc::c_ulong {
        match *p as libc::c_int {
            10 => {
                tmp___3 = s;
                s = s.offset(1);
                *tmp___3 = '\\' as i32 as libc::c_char;
                tmp___4 = s;
                s = s.offset(1);
                *tmp___4 = 'n' as i32 as libc::c_char;
            }
            13 => {
                tmp___5 = s;
                s = s.offset(1);
                *tmp___5 = '\\' as i32 as libc::c_char;
                tmp___6 = s;
                s = s.offset(1);
                *tmp___6 = 'r' as i32 as libc::c_char;
            }
            9 => {
                tmp___7 = s;
                s = s.offset(1);
                *tmp___7 = '\\' as i32 as libc::c_char;
                tmp___8 = s;
                s = s.offset(1);
                *tmp___8 = 't' as i32 as libc::c_char;
            }
            27 => {
                tmp___9 = s;
                s = s.offset(1);
                *tmp___9 = '\\' as i32 as libc::c_char;
                tmp___10 = s;
                s = s.offset(1);
                *tmp___10 = 'e' as i32 as libc::c_char;
            }
            0 => {
                tmp___11 = s;
                s = s.offset(1);
                *tmp___11 = '\\' as i32 as libc::c_char;
                tmp___12 = s;
                s = s.offset(1);
                *tmp___12 = '0' as i32 as libc::c_char;
            }
            34 => {
                tmp___13 = s;
                s = s.offset(1);
                *tmp___13 = '\\' as i32 as libc::c_char;
                tmp___14 = s;
                s = s.offset(1);
                *tmp___14 = '"' as i32 as libc::c_char;
            }
            _ => {
                tmp___16 = __ctype_b_loc();
                if *(*tmp___16).offset(*p as libc::c_int as isize) as libc::c_int
                    & 16384 as libc::c_int != 0
                {
                    tmp___15 = s;
                    s = s.offset(1);
                    *tmp___15 = (*p as libc::c_int & 255 as libc::c_int) as libc::c_char;
                } else if *p as libc::c_int & 255 as libc::c_int > 127 as libc::c_int {
                    tmp___15 = s;
                    s = s.offset(1);
                    *tmp___15 = (*p as libc::c_int & 255 as libc::c_int) as libc::c_char;
                } else {
                    sprintf(
                        s,
                        b"\\x%02x\0" as *const u8 as *const libc::c_char,
                        *p as libc::c_int & 255 as libc::c_int,
                    );
                    s = s.offset(4 as libc::c_int as isize);
                }
            }
        }
        p = p.offset(1);
    }
    tmp___17 = s;
    s = s.offset(1);
    *tmp___17 = '"' as i32 as libc::c_char;
    tmp___18 = strm_str_new(buf as *const libc::c_char, len);
    return tmp___18;
}
pub unsafe extern "C" fn strm_inspect(mut v: strm_value) -> strm_string {
    let mut str: strm_string = 0;
    let mut tmp: strm_int = 0;
    let mut tmp___0: strm_string = 0;
    let mut ns: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: strm_int = 0;
    let mut bi: strm_int = 0;
    let mut capa: strm_int = 0;
    let mut a: strm_array = 0;
    let mut tmp___3: strm_int = 0;
    let mut name: strm_string = 0;
    let mut tmp___4: strm_string = 0;
    let mut nlen: strm_int = 0;
    let mut tmp___5: strm_int = 0;
    let mut tmp___6: strm_int = 0;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___9: strm_int = 0;
    let mut tmp___10: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut str___0: strm_string = 0;
    let mut tmp___11: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___12: strm_string = 0;
    let mut key: strm_string = 0;
    let mut tmp___17: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___18: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___19: strm_string = 0;
    let mut tmp___20: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___21: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___22: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___23: libc::c_int = 0;
    let mut slen: strm_int = 0;
    let mut tmp___24: strm_int = 0;
    let mut tmp___25: strm_int = 0;
    let mut tmp___26: strm_int = 0;
    let mut tmp___27: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___28: strm_int = 0;
    let mut tmp___29: strm_int = 0;
    let mut tmp___30: strm_int = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: strm_int = 0;
    let mut tmp___33: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___34: strm_int = 0;
    let mut tmp___35: strm_int = 0;
    let mut tmp___36: strm_int = 0;
    let mut tmp___37: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___38: strm_int = 0;
    let mut tmp___39: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___40: strm_int = 0;
    let mut tmp___41: strm_string = 0;
    let mut tmp___42: strm_string = 0;
    let mut tmp___43: libc::c_int = 0;
    let mut tmp___44: libc::c_int = 0;
    tmp___44 = strm_string_p(v);
    if tmp___44 != 0 {
        str = v;
        tmp = str_dump_len(str);
        tmp___0 = str_dump(str, tmp);
        return tmp___0;
    } else {
        tmp___43 = strm_array_p(v);
        if tmp___43 != 0 {
            tmp___1 = strm_ary_struct(v);
            ns = (*tmp___1).ns;
            tmp___2 = malloc(32 as libc::c_int as size_t);
            buf = tmp___2 as *mut libc::c_char;
            bi = 0 as libc::c_int;
            capa = 32 as libc::c_int;
            a = v;
            if buf as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                return 1 as libc::c_int as strm_string;
            }
            tmp___3 = bi;
            bi += 1;
            *buf.offset(tmp___3 as isize) = '[' as i32 as libc::c_char;
            if !ns.is_null() {
                tmp___4 = strm_ns_name(ns);
                name = tmp___4;
                tmp___5 = strm_str_len(name);
                nlen = tmp___5;
                if name != 0 as libc::c_ulong {
                    tmp___6 = bi;
                    bi += 1;
                    *buf.offset(tmp___6 as isize) = '@' as i32 as libc::c_char;
                    if bi + nlen + 2 as libc::c_int > capa {
                        capa *= 2 as libc::c_int;
                        tmp___7 = realloc(buf as *mut libc::c_void, capa as size_t);
                        p = tmp___7 as *mut libc::c_char;
                        if p as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong
                        {
                            free(buf as *mut libc::c_void);
                            return 1 as libc::c_int as strm_string;
                        }
                        buf = p;
                    }
                    tmp___8 = strm_strp_ptr(&mut name);
                    memcpy(
                        buf.offset(bi as isize) as *mut libc::c_void,
                        tmp___8 as *const libc::c_void,
                        nlen as size_t,
                    );
                    bi += nlen;
                    tmp___10 = strm_ary_struct(a);
                    if (*tmp___10).len > 0 as libc::c_int {
                        tmp___9 = bi;
                        bi += 1;
                        *buf.offset(tmp___9 as isize) = ' ' as i32 as libc::c_char;
                    }
                }
            }
            i = 0 as libc::c_int;
            loop {
                tmp___39 = strm_ary_struct(a);
                if !(i < (*tmp___39).len) {
                    break;
                }
                tmp___11 = strm_ary_struct(a);
                tmp___12 = strm_inspect(*((*tmp___11).ptr).offset(i as isize));
                str___0 = tmp___12;
                tmp___20 = strm_ary_struct(a);
                if (*tmp___20).headers != 0 {
                    tmp___21 = strm_ary_struct(a);
                    tmp___22 = strm_ary_struct((*tmp___21).headers);
                    tmp___23 = strm_string_p(*((*tmp___22).ptr).offset(i as isize));
                    if tmp___23 != 0 {
                        tmp___17 = strm_ary_struct(a);
                        tmp___18 = strm_ary_struct((*tmp___17).headers);
                        tmp___19 = *((*tmp___18).ptr).offset(i as isize);
                    } else {
                        tmp___19 = 0 as libc::c_int as strm_string;
                    }
                } else {
                    tmp___19 = 0 as libc::c_int as strm_string;
                }
                key = tmp___19;
                if key != 0 {
                    tmp___24 = strm_str_len(key);
                    tmp___25 = tmp___24 + 1 as libc::c_int;
                } else {
                    tmp___25 = 0 as libc::c_int;
                }
                tmp___26 = strm_str_len(str___0);
                slen = tmp___25 + tmp___26 + 3 as libc::c_int;
                if bi + slen > capa {
                    capa *= 2 as libc::c_int;
                    tmp___27 = realloc(buf as *mut libc::c_void, capa as size_t);
                    buf = tmp___27 as *mut libc::c_char;
                }
                if i > 0 as libc::c_int {
                    tmp___28 = bi;
                    bi += 1;
                    *buf.offset(tmp___28 as isize) = ',' as i32 as libc::c_char;
                    tmp___29 = bi;
                    bi += 1;
                    *buf.offset(tmp___29 as isize) = ' ' as i32 as libc::c_char;
                }
                if key != 0 {
                    tmp___31 = str_symbol_p(key);
                    if tmp___31 == 0 {
                        tmp___30 = str_dump_len(key);
                        key = str_dump(key, tmp___30);
                    }
                    tmp___32 = strm_str_len(key);
                    tmp___33 = strm_strp_ptr(&mut key);
                    memcpy(
                        buf.offset(bi as isize) as *mut libc::c_void,
                        tmp___33 as *const libc::c_void,
                        tmp___32 as size_t,
                    );
                    tmp___34 = strm_str_len(key);
                    bi += tmp___34;
                    tmp___35 = bi;
                    bi += 1;
                    *buf.offset(tmp___35 as isize) = ':' as i32 as libc::c_char;
                }
                tmp___36 = strm_str_len(str___0);
                tmp___37 = strm_strp_ptr(&mut str___0);
                memcpy(
                    buf.offset(bi as isize) as *mut libc::c_void,
                    tmp___37 as *const libc::c_void,
                    tmp___36 as size_t,
                );
                tmp___38 = strm_str_len(str___0);
                bi += tmp___38;
                i += 1;
            }
            tmp___40 = bi;
            bi += 1;
            *buf.offset(tmp___40 as isize) = ']' as i32 as libc::c_char;
            tmp___41 = strm_str_new(buf as *const libc::c_char, bi);
            return tmp___41;
        } else {
            tmp___42 = strm_to_str(v);
            return tmp___42;
        }
    };
}
pub unsafe extern "C" fn strm_to_str(mut v: strm_value) -> strm_string {
    let mut buf: [libc::c_char; 32] = [0; 32];
    let mut n: libc::c_int = 0;
    let mut ns: *mut strm_state = 0 as *mut strm_state;
    let mut tmp: *mut strm_state = 0 as *mut strm_state;
    let mut m: strm_value = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: int32_t = 0;
    let mut tmp___3: strm_string = 0;
    let mut tmp___5: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___6: int32_t = 0;
    let mut tmp___7: strm_string = 0;
    let mut tmp___8: strm_cfunc = None;
    let mut tmp___9: strm_string = 0;
    let mut tmp___10: strm_string = 0;
    let mut tmp___11: strm_string = 0;
    let mut p: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___12: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___13: strm_ptr_type = STRM_PTR_STREAM;
    let mut io: strm_io_0 = 0 as *mut strm_io;
    let mut mode: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut fbuf: [libc::c_char; 7] = [0; 7];
    let mut gf: *mut strm_genfunc = 0 as *mut strm_genfunc;
    let mut tmp___14: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___15: strm_string = 0;
    let mut tmp___16: libc::c_double = 0.;
    let mut tmp___17: strm_string = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: strm_string = 0;
    tmp = strm_value_ns(v);
    ns = tmp;
    if !ns.is_null() {
        tmp___0 = strm_str_intern_static(
            b"string\0" as *const u8 as *const libc::c_char,
            (::std::mem::size_of::<[libc::c_char; 7]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_ulong) as strm_int,
        );
        n = strm_var_get(ns, tmp___0, &mut m);
        if n == 0 as libc::c_int {
            n = strm_funcall(
                0 as *mut libc::c_void as *mut strm_stream,
                m,
                1 as libc::c_int,
                &mut v,
                &mut m,
            );
            if n == 0 as libc::c_int {
                tmp___1 = strm_string_p(m);
                if tmp___1 != 0 {
                    return m;
                }
            }
        }
    }
    match v & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18442803424035602432 => {
            tmp___2 = strm_to_int(v);
            n = sprintf(
                buf.as_mut_ptr(),
                b"%d\0" as *const u8 as *const libc::c_char,
                tmp___2,
            );
            tmp___3 = strm_str_new(buf.as_mut_ptr() as *const libc::c_char, n);
            return tmp___3;
        }
        18442521949058891776 => {
            tmp___6 = strm_to_int(v);
            if tmp___6 != 0 {
                tmp___5 = b"true\0" as *const u8 as *const libc::c_char;
            } else {
                tmp___5 = b"false\0" as *const u8 as *const libc::c_char;
            }
            n = sprintf(buf.as_mut_ptr(), tmp___5);
            tmp___7 = strm_str_new(buf.as_mut_ptr() as *const libc::c_char, n);
            return tmp___7;
        }
        18445336698825998336 => {
            tmp___8 = strm_value_cfunc(v);
            n = sprintf(
                buf.as_mut_ptr(),
                b"<cfunc:%p>\0" as *const u8 as *const libc::c_char,
                ::std::mem::transmute::<strm_cfunc, *mut libc::c_void>(tmp___8),
            );
            tmp___9 = strm_str_new(buf.as_mut_ptr() as *const libc::c_char, n);
            return tmp___9;
        }
        18445055223849287680 | 18444773748872577024 | 18444492273895866368
        | 18444210798919155712 => return v,
        18443647848965734400 | 18443366373989023744 => {
            tmp___10 = strm_inspect(v);
            return tmp___10;
        }
        18445899648779419648 => {
            if v & !((65535 as libc::c_ulong) << 48 as libc::c_int) == 0 as libc::c_ulong
            {
                tmp___11 = strm_str_static(
                    b"nil\0" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 4]>() as libc::c_ulong)
                        .wrapping_sub(1 as libc::c_ulong) as strm_int,
                );
                return tmp___11;
            } else {
                tmp___12 = strm_ptr(v);
                p = tmp___12;
                tmp___13 = strm_ptr_type(p);
                match tmp___13 as libc::c_uint {
                    0 => {
                        n = sprintf(
                            buf.as_mut_ptr(),
                            b"<stream:%p>\0" as *const u8 as *const libc::c_char,
                            p,
                        );
                    }
                    3 => {
                        io = p as strm_io_0;
                        match (*io).mode & 3 as libc::c_int {
                            1 => {
                                mode = b"r\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char;
                            }
                            2 => {
                                mode = b"w\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char;
                            }
                            3 => {
                                mode = b"rw\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char;
                            }
                            _ => {
                                mode = b"?\0" as *const u8 as *const libc::c_char
                                    as *mut libc::c_char;
                            }
                        }
                        n = sprintf(
                            buf.as_mut_ptr(),
                            b"<io: fd=%d mode=%s>\0" as *const u8 as *const libc::c_char,
                            (*io).fd,
                            mode,
                        );
                    }
                    1 => {
                        n = sprintf(
                            buf.as_mut_ptr(),
                            b"<lambda:%p>\0" as *const u8 as *const libc::c_char,
                            p,
                        );
                    }
                    2 => {
                        gf = p as *mut strm_genfunc;
                        tmp___14 = strm_str_cstr((*gf).id, fbuf.as_mut_ptr());
                        n = sprintf(
                            buf.as_mut_ptr(),
                            b"<genfunc:&%s>\0" as *const u8 as *const libc::c_char,
                            tmp___14,
                        );
                    }
                    4 => {
                        n = sprintf(
                            buf.as_mut_ptr(),
                            b"<obj:%p>\0" as *const u8 as *const libc::c_char,
                            p,
                        );
                    }
                    _ => {}
                }
                tmp___15 = strm_str_new(buf.as_mut_ptr() as *const libc::c_char, n);
                return tmp___15;
            }
        }
        _ => {
            tmp___18 = strm_float_p(v);
            if tmp___18 != 0 {
                tmp___16 = strm_to_float(v);
                n = sprintf(
                    buf.as_mut_ptr(),
                    b"%.14g\0" as *const u8 as *const libc::c_char,
                    tmp___16,
                );
                tmp___17 = strm_str_new(buf.as_mut_ptr() as *const libc::c_char, n);
                return tmp___17;
            }
            n = sprintf(
                buf.as_mut_ptr(),
                b"<%p>\0" as *const u8 as *const libc::c_char,
                (v & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
                    as *mut libc::c_void,
            );
            tmp___19 = strm_str_new(buf.as_mut_ptr() as *const libc::c_char, n);
            return tmp___19;
        }
    };
}
pub unsafe extern "C" fn strm_p(mut val: strm_value) -> *const libc::c_char {
    let mut buf: [libc::c_char; 7] = [0; 7];
    let mut str: strm_string = 0;
    let mut tmp: strm_string = 0;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    tmp = strm_to_str(val);
    str = tmp;
    tmp___0 = strm_str_cstr(str, buf.as_mut_ptr());
    p = tmp___0;
    fputs(p, stdout);
    fputs(b"\n\0" as *const u8 as *const libc::c_char, stdout);
    return p;
}
pub unsafe extern "C" fn strm_nil_value() -> strm_value {
    return 18445899648779419648 as libc::c_ulonglong as strm_value;
}
pub unsafe extern "C" fn strm_value_ns(mut val: strm_value) -> *mut strm_state {
    let mut ns: *mut strm_state = 0 as *mut strm_state;
    let mut tmp: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut p: *mut strm_misc = 0 as *mut strm_misc;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___4: strm_ptr_type = STRM_PTR_STREAM;
    tmp___0 = strm_array_p(val);
    if tmp___0 != 0 {
        tmp = strm_ary_struct(val);
        ns = (*tmp).ns;
        if !ns.is_null() {
            return ns;
        }
        return strm_ns_array;
    }
    tmp___1 = strm_string_p(val);
    if tmp___1 != 0 {
        return strm_ns_string;
    }
    tmp___2 = strm_number_p(val);
    if tmp___2 != 0 {
        return strm_ns_number;
    }
    if (val & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18445899648779419648 as libc::c_ulonglong
    {
        tmp___3 = strm_ptr(val);
        p = tmp___3 as *mut strm_misc;
        if p.is_null() {
            return 0 as *mut libc::c_void as *mut strm_state;
        }
        tmp___4 = strm_ptr_type(p as *mut libc::c_void);
        if tmp___4 as libc::c_uint == 4 as libc::c_uint {
            return (*p).ns;
        }
    }
    return 0 as *mut libc::c_void as *mut strm_state;
}
pub unsafe extern "C" fn strm_latch_finish_p(
    mut latch: *mut strm_stream,
) -> libc::c_int {
    let mut c: *mut latch_data = 0 as *mut latch_data;
    let mut tmp: libc::c_int = 0;
    if (*latch).mode as libc::c_uint == 2 as libc::c_uint {
        return 0 as libc::c_int;
    }
    c = (*latch).data as *mut latch_data;
    tmp = strm_queue_empty_p((*c).dq);
    return tmp;
}
unsafe extern "C" fn latch_push(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut latch_data = 0 as *mut latch_data;
    let mut r: *mut recv_data = 0 as *mut recv_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    d = (*strm).data as *mut latch_data;
    tmp = strm_queue_get((*d).rq);
    r = tmp as *mut recv_data;
    if (*strm).mode as libc::c_uint != 2 as libc::c_uint {
        return 1 as libc::c_int;
    }
    if !r.is_null() {
        (Some(((*r).func).expect("non-null function pointer")))
            .expect("non-null function pointer")((*r).strm, data);
        free(r as *mut libc::c_void);
    } else {
        tmp___0 = malloc(::std::mem::size_of::<strm_value>() as libc::c_ulong);
        v = tmp___0 as *mut strm_value;
        *v = data;
        strm_queue_add((*d).dq, v as *mut libc::c_void);
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_latch_receive(
    mut latch: *mut strm_stream,
    mut strm: *mut strm_stream,
    mut func: Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
) {
    let mut d: *mut latch_data = 0 as *mut latch_data;
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut r: *mut recv_data = 0 as *mut recv_data;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    if !(::std::mem::transmute::<
        Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        libc::c_ulong,
    >((*latch).start_func)
        == ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
            libc::c_ulong,
        >(
            Some(
                latch_push
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
        ))
    {
        __assert_fail(
            b"latch->start_func == latch_push\0" as *const u8 as *const libc::c_char,
            b"latch.c\0" as *const u8 as *const libc::c_char,
            53 as libc::c_uint,
            b"strm_latch_receive\0" as *const u8 as *const libc::c_char,
        );
    }
    d = (*latch).data as *mut latch_data;
    tmp___0 = strm_queue_get((*d).dq);
    v = tmp___0 as *mut strm_value;
    if !v.is_null() {
        (Some(func.expect("non-null function pointer")))
            .expect("non-null function pointer")(strm, *v);
        free(v as *mut libc::c_void);
    } else {
        tmp___1 = malloc(::std::mem::size_of::<recv_data>() as libc::c_ulong);
        r = tmp___1 as *mut recv_data;
        (*r).strm = strm;
        (*r).func = func;
        strm_queue_add((*d).rq, r as *mut libc::c_void);
    };
}
unsafe extern "C" fn latch_close(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut latch_data = 0 as *mut latch_data;
    let mut r: *mut recv_data = 0 as *mut recv_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    d = (*strm).data as *mut latch_data;
    loop {
        tmp = strm_queue_get((*d).rq);
        r = tmp as *mut recv_data;
        if r.is_null() {
            break;
        }
        (Some(((*r).func).expect("non-null function pointer")))
            .expect("non-null function pointer")((*r).strm, data);
        free(r as *mut libc::c_void);
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_latch_new() -> *mut strm_stream {
    let mut d: *mut latch_data = 0 as *mut latch_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = malloc(::std::mem::size_of::<latch_data>() as libc::c_ulong);
    d = tmp as *mut latch_data;
    if !(d as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
        __assert_fail(
            b"d != NULL\0" as *const u8 as *const libc::c_char,
            b"latch.c\0" as *const u8 as *const libc::c_char,
            87 as libc::c_uint,
            b"strm_latch_new\0" as *const u8 as *const libc::c_char,
        );
    }
    (*d).dq = strm_queue_new();
    (*d).rq = strm_queue_new();
    tmp___1 = strm_stream_new(
        strm_consumer,
        Some(
            latch_push
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            latch_close
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    return tmp___1;
}
unsafe extern "C" fn zip_iter(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut z: *mut zip_data = 0 as *mut zip_data;
    let mut tmp: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___0: strm_int = 0;
    let mut i: strm_int = 0;
    let mut done: strm_int = 0;
    let mut tmp___1: libc::c_int = 0;
    z = (*strm).data as *mut zip_data;
    tmp = strm_ary_struct((*z).a);
    tmp___0 = (*z).i;
    (*z).i += 1;
    *((*tmp).ptr).offset(tmp___0 as isize) = data;
    if (*z).i < (*z).len {
        strm_latch_receive(
            *((*z).latch).as_mut_ptr().offset((*z).i as isize),
            strm,
            Some(
                zip_iter
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
        );
    } else {
        done = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < (*z).len {
            tmp___1 = strm_latch_finish_p(*((*z).latch).as_mut_ptr().offset(i as isize));
            if tmp___1 != 0 {
                done = 1 as libc::c_int;
                break;
            } else {
                i += 1;
            }
        }
        if done != 0 {
            strm_emit(
                strm,
                (*z).a,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
            );
            i = 0 as libc::c_int;
            while i < (*z).len {
                strm_stream_close(*((*z).latch).as_mut_ptr().offset(i as isize));
                i += 1;
            }
            strm_stream_close(strm);
        } else {
            strm_emit(
                strm,
                (*z).a,
                Some(
                    zip_start
                        as unsafe extern "C" fn(
                            *mut strm_stream,
                            strm_value,
                        ) -> libc::c_int,
                ),
            );
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zip_start(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut z: *mut zip_data = 0 as *mut zip_data;
    z = (*strm).data as *mut zip_data;
    if !z.is_null() {
        (*z).i = 0 as libc::c_int;
        (*z).a = strm_ary_new(0 as *mut libc::c_void as *const strm_value, (*z).len);
        strm_latch_receive(
            *((*z).latch).as_mut_ptr().offset(0 as libc::c_int as isize),
            strm,
            Some(
                zip_iter
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zip_close(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    (*strm).data = 0 as *mut libc::c_void;
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_zip(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut z: *mut zip_data = 0 as *mut zip_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: strm_int = 0;
    let mut s: *mut strm_stream = 0 as *mut strm_stream;
    let mut r: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = malloc(
        (::std::mem::size_of::<zip_data>() as libc::c_ulong)
            .wrapping_add(
                (::std::mem::size_of::<*mut strm_stream>() as libc::c_ulong)
                    .wrapping_mul(argc as libc::c_ulong),
            ),
    );
    z = tmp as *mut zip_data;
    (*z).i = 0 as libc::c_int;
    (*z).len = argc;
    i = 0 as libc::c_int;
    while i < argc {
        s = strm_latch_new();
        tmp___0 = strm_ptr_value(s as *mut libc::c_void);
        strm_connect(strm, *args.offset(i as isize), tmp___0, &mut r);
        let ref mut fresh1 = *((*z).latch).as_mut_ptr().offset(i as isize);
        *fresh1 = s;
        i += 1;
    }
    tmp___1 = strm_stream_new(
        strm_producer,
        Some(
            zip_start
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            zip_close
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        z as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn concat_iter(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut concat_data = 0 as *mut concat_data;
    let mut tmp: libc::c_int = 0;
    d = (*strm).data as *mut concat_data;
    strm_emit(
        strm,
        data,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    tmp = strm_latch_finish_p(*((*d).latch).as_mut_ptr().offset((*d).i as isize));
    if tmp != 0 {
        strm_stream_close(*((*d).latch).as_mut_ptr().offset((*d).i as isize));
        (*d).i += 1;
    }
    if (*d).i < (*d).len {
        strm_latch_receive(
            *((*d).latch).as_mut_ptr().offset((*d).i as isize),
            strm,
            Some(
                concat_iter
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
        );
    } else {
        strm_stream_close(strm);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn concat_start(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut concat_data = 0 as *mut concat_data;
    d = (*strm).data as *mut concat_data;
    if !d.is_null() {
        strm_latch_receive(
            *((*d).latch).as_mut_ptr().offset((*d).i as isize),
            strm,
            Some(
                concat_iter
                    as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
            ),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_concat(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut concat_data = 0 as *mut concat_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: strm_int = 0;
    let mut s: *mut strm_stream = 0 as *mut strm_stream;
    let mut r: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = malloc(
        (::std::mem::size_of::<concat_data>() as libc::c_ulong)
            .wrapping_add(
                (::std::mem::size_of::<*mut strm_stream>() as libc::c_ulong)
                    .wrapping_mul(argc as libc::c_ulong),
            ),
    );
    d = tmp as *mut concat_data;
    (*d).i = 0 as libc::c_int;
    (*d).len = argc;
    i = 0 as libc::c_int;
    while i < argc {
        s = strm_latch_new();
        tmp___0 = strm_ptr_value(s as *mut libc::c_void);
        strm_connect(strm, *args.offset(i as isize), tmp___0, &mut r);
        let ref mut fresh2 = *((*d).latch).as_mut_ptr().offset(i as isize);
        *fresh2 = s;
        i += 1;
    }
    tmp___1 = strm_stream_new(
        strm_producer,
        Some(
            concat_start
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_latch_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            exec_zip
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"&\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            exec_zip
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"zip\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_cfunc_value(
        Some(
            exec_concat
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"concat\0" as *const u8 as *const libc::c_char, tmp___1);
}
static mut khash_ac_HASH_UPPER___0: libc::c_double = 0.77f64;
#[inline]
unsafe extern "C" fn kh_init_env() -> *mut kh_env_t {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<kh_env_t>() as libc::c_ulong,
    );
    return tmp as *mut kh_env_t;
}
#[inline]
unsafe extern "C" fn kh_get_env(mut h: *const kh_env_t, mut key: khint64_t) -> khint_t {
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp: khint_t = 0;
    if (*h).n_buckets != 0 {
        step = 0 as libc::c_int as khint_t;
        mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
        k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
        i = k & mask;
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if i == last {
                return (*h).n_buckets;
            }
        }
        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint != 0
        {
            tmp = (*h).n_buckets;
        } else {
            tmp = i;
        }
        return tmp;
    } else {
        return 0 as libc::c_int as khint_t
    };
}
#[inline]
unsafe extern "C" fn kh_resize_env(
    mut h: *mut kh_env_t,
    mut new_n_buckets: khint_t,
) -> libc::c_int {
    let mut new_flags: *mut khint32_t = 0 as *mut khint32_t;
    let mut j: khint_t = 0;
    let mut tmp: khint_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: khint_t = 0;
    let mut new_keys: *mut khint64_t = 0 as *mut khint64_t;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut new_vals: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut key: khint64_t = 0;
    let mut val: strm_value = 0;
    let mut new_mask: khint_t = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp___4: khint64_t = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    new_flags = 0 as *mut khint32_t;
    j = 1 as libc::c_int as khint_t;
    new_n_buckets = new_n_buckets.wrapping_sub(1);
    new_n_buckets |= new_n_buckets >> 1 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 2 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 4 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 8 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 16 as libc::c_int;
    new_n_buckets = new_n_buckets.wrapping_add(1);
    if new_n_buckets < 4 as libc::c_uint {
        new_n_buckets = 4 as libc::c_int as khint_t;
    }
    if (*h).size
        >= (new_n_buckets as libc::c_double * khash_ac_HASH_UPPER___0 + 0.5f64)
            as khint_t
    {
        j = 0 as libc::c_int as khint_t;
    } else {
        if new_n_buckets < 16 as libc::c_uint {
            tmp = 1 as libc::c_int as khint_t;
        } else {
            tmp = new_n_buckets >> 4 as libc::c_int;
        }
        tmp___0 = malloc(
            (tmp as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        new_flags = tmp___0 as *mut khint32_t;
        if new_flags.is_null() {
            return -(1 as libc::c_int);
        }
        if new_n_buckets < 16 as libc::c_uint {
            tmp___1 = 1 as libc::c_int as khint_t;
        } else {
            tmp___1 = new_n_buckets >> 4 as libc::c_int;
        }
        memset(
            new_flags as *mut libc::c_void,
            170 as libc::c_int,
            (tmp___1 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        if (*h).n_buckets < new_n_buckets {
            tmp___2 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<khint64_t>() as libc::c_ulong),
            );
            new_keys = tmp___2 as *mut khint64_t;
            if new_keys.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).keys = new_keys;
            tmp___3 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
            );
            new_vals = tmp___3 as *mut strm_value;
            if new_vals.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).vals = new_vals;
        }
    }
    if j != 0 {
        j = 0 as libc::c_int as khint_t;
        while j != (*h).n_buckets {
            if *((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                >> ((j & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint
                == 0 as libc::c_uint
            {
                key = *((*h).keys).offset(j as isize);
                new_mask = new_n_buckets.wrapping_sub(1 as libc::c_uint);
                val = *((*h).vals).offset(j as isize);
                *((*h).flags)
                    .offset(
                        (j >> 4 as libc::c_int) as isize,
                    ) = (*((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                    as libc::c_ulong
                    | (1 as libc::c_ulong)
                        << ((j & 15 as libc::c_uint) << 1 as libc::c_int)) as khint32_t;
                loop {
                    step = 0 as libc::c_int as khint_t;
                    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int)
                        as khint32_t;
                    i = k & new_mask;
                    while *new_flags.offset((i >> 4 as libc::c_int) as isize)
                        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                        & 2 as libc::c_uint == 0
                    {
                        step = step.wrapping_add(1);
                        i = i.wrapping_add(step) & new_mask;
                    }
                    *new_flags
                        .offset(
                            (i >> 4 as libc::c_int) as isize,
                        ) = (*new_flags.offset((i >> 4 as libc::c_int) as isize)
                        as libc::c_ulong
                        & !((2 as libc::c_ulong)
                            << ((i & 15 as libc::c_uint) << 1 as libc::c_int)))
                        as khint32_t;
                    if i < (*h).n_buckets {
                        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                            & 3 as libc::c_uint == 0 as libc::c_uint
                        {
                            tmp___4 = *((*h).keys).offset(i as isize);
                            *((*h).keys).offset(i as isize) = key;
                            key = tmp___4;
                            tmp___5 = *((*h).vals).offset(i as isize);
                            *((*h).vals).offset(i as isize) = val;
                            val = tmp___5;
                            *((*h).flags)
                                .offset(
                                    (i >> 4 as libc::c_int) as isize,
                                ) = (*((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                                as libc::c_ulong
                                | (1 as libc::c_ulong)
                                    << ((i & 15 as libc::c_uint) << 1 as libc::c_int))
                                as khint32_t;
                        } else {
                            *((*h).keys).offset(i as isize) = key;
                            *((*h).vals).offset(i as isize) = val;
                            break;
                        }
                    } else {
                        *((*h).keys).offset(i as isize) = key;
                        *((*h).vals).offset(i as isize) = val;
                        break;
                    }
                }
            }
            j = j.wrapping_add(1);
        }
        if (*h).n_buckets > new_n_buckets {
            tmp___6 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<khint64_t>() as libc::c_ulong),
            );
            (*h).keys = tmp___6 as *mut khint64_t;
            tmp___7 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
            );
            (*h).vals = tmp___7 as *mut strm_value;
        }
        free((*h).flags as *mut libc::c_void);
        (*h).flags = new_flags;
        (*h).n_buckets = new_n_buckets;
        (*h).n_occupied = (*h).size;
        (*h)
            .upper_bound = ((*h).n_buckets as libc::c_double * khash_ac_HASH_UPPER___0
            + 0.5f64) as khint_t;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn kh_put_env(
    mut h: *mut kh_env_t,
    mut key: khint64_t,
    mut ret: *mut libc::c_int,
) -> khint_t {
    let mut x: khint_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut site: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    if (*h).n_occupied >= (*h).upper_bound {
        if (*h).n_buckets > (*h).size << 1 as libc::c_int {
            tmp = kh_resize_env(h, ((*h).n_buckets).wrapping_sub(1 as libc::c_uint));
            if tmp < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        } else {
            tmp___0 = kh_resize_env(h, ((*h).n_buckets).wrapping_add(1 as libc::c_uint));
            if tmp___0 < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        }
    }
    mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
    step = 0 as libc::c_int as khint_t;
    site = (*h).n_buckets;
    x = site;
    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
    i = k & mask;
    if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        x = i;
    } else {
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                != 0
            {
                site = i;
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if !(i == last) {
                continue;
            }
            x = site;
            break;
        }
        if x == (*h).n_buckets {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint
                != 0
            {
                if site != (*h).n_buckets {
                    x = site;
                } else {
                    x = i;
                }
            } else {
                x = i;
            }
        }
    }
    if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
        >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        (*h).n_occupied = ((*h).n_occupied).wrapping_add(1);
        *ret = 1 as libc::c_int;
    } else if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
            >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint != 0
        {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        *ret = 2 as libc::c_int;
    } else {
        *ret = 0 as libc::c_int;
    }
    return x;
}
pub static mut globals: *mut strm_env = 0 as *const strm_env as *mut strm_env;
unsafe extern "C" fn env_set(
    mut env: *mut strm_env,
    mut name: strm_string,
    mut val: strm_value,
) -> libc::c_int {
    let mut r: libc::c_int = 0;
    let mut k: khiter_t = 0;
    let mut tmp___0: libc::c_int = 0;
    if !(env as libc::c_ulong != globals as libc::c_ulong) {
        if strm_event_loop_started != 0 {
            __assert_fail(
                b"env != globals || !strm_event_loop_started\0" as *const u8
                    as *const libc::c_char,
                b"env.c\0" as *const u8 as *const libc::c_char,
                14 as libc::c_uint,
                b"env_set\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    tmp___0 = strm_str_intern_p(name);
    if tmp___0 == 0 {
        name = strm_str_intern_str(name);
    }
    k = kh_put_env(env, name, &mut r);
    if r <= 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    *((*env).vals).offset(k as isize) = val;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn env_get(
    mut env: *mut strm_env,
    mut name: strm_string,
    mut val: *mut strm_value,
) -> libc::c_int {
    let mut k: khiter_t = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strm_str_intern_p(name);
    if tmp == 0 {
        name = strm_str_intern_str(name);
    }
    k = kh_get_env(env as *const kh_env_t, name);
    if k == (*env).n_buckets {
        return 1 as libc::c_int;
    }
    *val = *((*env).vals).offset(k as isize);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_var_set(
    mut state: *mut strm_state,
    mut name: strm_string,
    mut val: strm_value,
) -> libc::c_int {
    let mut e: *mut strm_env = 0 as *mut strm_env;
    let mut tmp: *mut kh_env_t = 0 as *mut kh_env_t;
    let mut tmp___0: libc::c_int = 0;
    if state.is_null() {
        if globals.is_null() {
            globals = kh_init_env();
        }
        e = globals;
    } else {
        if ((*state).env).is_null() {
            tmp = kh_init_env();
            (*state).env = tmp as *mut libc::c_void;
        }
        e = (*state).env as *mut strm_env;
    }
    tmp___0 = env_set(e, name, val);
    return tmp___0;
}
pub unsafe extern "C" fn strm_var_def(
    mut state: *mut strm_state,
    mut name: *const libc::c_char,
    mut val: strm_value,
) -> libc::c_int {
    let mut tmp: size_t = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = strlen(name);
    tmp___0 = strm_str_intern(name, tmp as strm_int);
    tmp___1 = strm_var_set(state, tmp___0, val);
    return tmp___1;
}
pub unsafe extern "C" fn strm_var_get(
    mut state: *mut strm_state,
    mut name: strm_string,
    mut val: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    while !state.is_null() {
        if !((*state).env).is_null() {
            tmp = env_get((*state).env as *mut strm_env, name, val);
            if tmp == 0 as libc::c_int {
                return 0 as libc::c_int;
            }
        }
        state = (*state).prev;
    }
    if globals.is_null() {
        return 1 as libc::c_int;
    }
    tmp___0 = env_get(globals, name, val);
    return tmp___0;
}
pub unsafe extern "C" fn strm_var_match(
    mut state: *mut strm_state,
    mut name: strm_string,
    mut val: strm_value,
) -> libc::c_int {
    let mut v0: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    if !state.is_null() {
        if !((*state).env).is_null() {
            tmp___0 = env_get((*state).env as *mut strm_env, name, &mut v0);
            if tmp___0 == 0 as libc::c_int {
                tmp = strm_value_eq(v0, val);
                if tmp != 0 {
                    return 0 as libc::c_int;
                }
                return 1 as libc::c_int;
            }
        }
    }
    tmp___1 = strm_var_set(state, name, val);
    return tmp___1;
}
pub unsafe extern "C" fn strm_env_copy(
    mut s1: *mut strm_state,
    mut s2: *mut strm_state,
) -> libc::c_int {
    let mut e1: *mut strm_env = 0 as *mut strm_env;
    let mut e2: *mut strm_env = 0 as *mut strm_env;
    let mut k: khiter_t = 0;
    let mut kk: khiter_t = 0;
    let mut r: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut kh_env_t = 0 as *mut kh_env_t;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut kh_env_t = 0 as *mut kh_env_t;
    e1 = (*s1).env as *mut strm_env;
    e2 = (*s2).env as *mut strm_env;
    if e1.is_null() {
        tmp___0 = kh_init_env();
        tmp = tmp___0 as *mut libc::c_void;
        (*s1).env = tmp;
        e1 = tmp as *mut strm_env;
    }
    if e2.is_null() {
        tmp___2 = kh_init_env();
        tmp___1 = tmp___2 as *mut libc::c_void;
        (*s1).env = tmp___1;
        e2 = tmp___1 as *mut strm_env;
    }
    k = 0 as libc::c_int as khint_t;
    while k != (*e2).n_buckets {
        if *((*e2).flags).offset((k >> 4 as libc::c_int) as isize)
            >> ((k & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint == 0
        {
            kk = kh_put_env(e1, *((*e2).keys).offset(k as isize), &mut r);
            if r <= 0 as libc::c_int {
                return 1 as libc::c_int;
            }
            *((*e1).vals).offset(kk as isize) = *((*e2).vals).offset(k as isize);
        }
        k = k.wrapping_add(1);
    }
    return 0 as libc::c_int;
}
pub static mut workers: *mut strm_worker = 0 as *const strm_worker as *mut strm_worker;
static mut queue: *mut strm_queue = 0 as *const strm_queue as *mut strm_queue;
static mut prod_queue: *mut strm_queue = 0 as *const strm_queue as *mut strm_queue;
static mut worker_max: libc::c_int = 0;
static mut stream_count: libc::c_int = 0 as libc::c_int;
pub static mut strm_event_loop_started: libc::c_int = 0 as libc::c_int;
pub unsafe extern "C" fn strm_task_new(
    mut func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    >,
    mut data: strm_value,
) -> *mut strm_task {
    let mut t: *mut strm_task = 0 as *mut strm_task;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<strm_task>() as libc::c_ulong);
    t = tmp as *mut strm_task;
    (*t).func = func;
    (*t).data = data;
    return t;
}
pub unsafe extern "C" fn strm_task_add(
    mut strm: *mut strm_stream,
    mut task: *mut strm_task,
) {
    strm_queue_add((*strm).queue, task as *mut libc::c_void);
    if (*strm).mode as libc::c_uint == 0 as libc::c_uint {
        strm_queue_add(prod_queue, strm as *mut libc::c_void);
    } else {
        strm_queue_add(queue, strm as *mut libc::c_void);
    };
}
pub unsafe extern "C" fn strm_task_push(
    mut strm: *mut strm_stream,
    mut func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    >,
    mut data: strm_value,
) {
    let mut tmp: *mut strm_task = 0 as *mut strm_task;
    if (*strm).mode as libc::c_uint == 4 as libc::c_uint {
        return
    } else {
        if (*strm).mode as libc::c_uint == 3 as libc::c_uint {
            return;
        }
    }
    tmp = strm_task_new(func, data);
    strm_task_add(strm, tmp);
}
pub unsafe extern "C" fn strm_emit(
    mut strm: *mut strm_stream,
    mut data: strm_value,
    mut func: Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
) {
    let mut i: libc::c_int = 0;
    let mut closed: libc::c_int = 0;
    let mut i___0: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_value = 0;
    if (*strm).mode as libc::c_uint == 3 as libc::c_uint {
        return;
    }
    tmp = strm_nil_p(data);
    if tmp == 0 {
        if !((*strm).dst).is_null() {
            strm_task_push((*strm).dst, (*(*strm).dst).start_func, data);
            if (*(*strm).dst).mode as libc::c_uint == 4 as libc::c_uint {
                (*strm).dst = 0 as *mut libc::c_void as *mut strm_stream;
            }
        }
        if !((*strm).rest).is_null() {
            i = 0 as libc::c_int;
            while (i as size_t) < (*strm).rsize {
                strm_task_push(
                    *((*strm).rest).offset(i as isize),
                    (**((*strm).rest).offset(i as isize)).start_func,
                    data,
                );
                i += 1;
            }
        }
        if (*strm).dst as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            closed = 1 as libc::c_int;
            if !((*strm).rest).is_null() {
                i___0 = 0 as libc::c_int;
                while (i___0 as size_t) < (*strm).rsize {
                    if (**((*strm).rest).offset(i___0 as isize)).mode as libc::c_uint
                        != 4 as libc::c_uint
                    {
                        closed = 0 as libc::c_int;
                        break;
                    } else {
                        i___0 += 1;
                    }
                }
            }
            if closed != 0 {
                (*strm).mode = strm_dying;
                return;
            }
        }
    }
    sched_yield();
    if func.is_some() {
        tmp___0 = strm_nil_value();
        strm_task_push(strm, func, tmp___0);
    }
}
pub unsafe extern "C" fn strm_stream_connect(
    mut src: *mut strm_stream,
    mut dst: *mut strm_stream,
) -> libc::c_int {
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: size_t = 0;
    let mut tmp___3: strm_value = 0;
    if !((*src).mode as libc::c_uint != 2 as libc::c_uint) {
        __assert_fail(
            b"src->mode != strm_consumer\0" as *const u8 as *const libc::c_char,
            b"core.c\0" as *const u8 as *const libc::c_char,
            102 as libc::c_uint,
            b"strm_stream_connect\0" as *const u8 as *const libc::c_char,
        );
    }
    if !((*dst).mode as libc::c_uint != 0 as libc::c_uint) {
        __assert_fail(
            b"dst->mode != strm_producer\0" as *const u8 as *const libc::c_char,
            b"core.c\0" as *const u8 as *const libc::c_char,
            103 as libc::c_uint,
            b"strm_stream_connect\0" as *const u8 as *const libc::c_char,
        );
    }
    if (*src).dst as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        (*src).dst = dst;
    } else {
        if (*src).rsize <= (*src).rcapa {
            (*src)
                .rcapa = ((*src).rcapa)
                .wrapping_mul(2 as libc::c_ulong)
                .wrapping_add(2 as libc::c_ulong);
            tmp___1 = realloc(
                (*src).rest as *mut libc::c_void,
                (::std::mem::size_of::<*mut strm_stream>() as libc::c_ulong)
                    .wrapping_mul((*src).rcapa),
            );
            (*src).rest = tmp___1 as *mut *mut strm_stream;
        }
        tmp___2 = (*src).rsize;
        (*src).rsize = ((*src).rsize).wrapping_add(1);
        let ref mut fresh3 = *((*src).rest).offset(tmp___2 as isize);
        *fresh3 = dst;
    }
    ::std::intrinsics::atomic_xadd_seqcst(&mut (*dst).refcnt, 1 as libc::c_int);
    if (*src).mode as libc::c_uint == 0 as libc::c_uint {
        task_init();
        tmp___3 = strm_nil_value();
        strm_task_push(src, (*src).start_func, tmp___3);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn worker_count() -> libc::c_int {
    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut n: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = getenv(b"STRM_WORKER_MAX\0" as *const u8 as *const libc::c_char);
    e = tmp;
    if !e.is_null() {
        n = atoi(e as *const libc::c_char);
        if n > 0 as libc::c_int {
            return n;
        }
    }
    tmp___0 = cpu_count();
    return tmp___0;
}
unsafe extern "C" fn task_exec(mut strm: *mut strm_stream, mut task: *mut strm_task) {
    let mut func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    > = None;
    let mut data: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    func = (*task).func;
    data = (*task).data;
    free(task as *mut libc::c_void);
    if (*strm).mode as libc::c_uint == 4 as libc::c_uint {
        return;
    }
    tmp = (Some(func.expect("non-null function pointer")))
        .expect("non-null function pointer")(strm, data);
    if tmp == 1 as libc::c_int {
        if strm_option_verbose != 0 {
            strm_eprint(strm);
        }
    }
    if (*strm).mode as libc::c_uint == 3 as libc::c_uint {
        strm_stream_close(strm);
    }
}
unsafe extern "C" fn task_loop(mut data: *mut libc::c_void) -> *mut libc::c_void {
    let mut strm: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut t: *mut strm_task = 0 as *mut strm_task;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: bool = false;
    loop {
        tmp = strm_queue_get(queue);
        strm = tmp as *mut strm_stream;
        if strm.is_null() {
            tmp___0 = strm_queue_get(prod_queue);
            strm = tmp___0 as *mut strm_stream;
        }
        if !strm.is_null() {
            tmp___2 = (::std::intrinsics::atomic_cxchg(
                &mut (*strm).excl,
                0 as libc::c_int,
                1 as libc::c_int,
            ))
                .1;
            if tmp___2 {
                loop {
                    tmp___1 = strm_queue_get((*strm).queue);
                    t = tmp___1 as *mut strm_task;
                    if !(t as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
                        break;
                    }
                    task_exec(strm, t);
                }
                (::std::intrinsics::atomic_cxchg(
                    &mut (*strm).excl,
                    1 as libc::c_int,
                    0 as libc::c_int,
                ))
                    .1;
            }
        }
        if stream_count == 0 as libc::c_int {
            break;
        }
    }
    return 0 as *mut libc::c_void;
}
unsafe extern "C" fn task_init() {
    let mut i: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if !workers.is_null() {
        return;
    }
    strm_event_loop_started = 1 as libc::c_int;
    strm_init_io_loop();
    queue = strm_queue_new();
    prod_queue = strm_queue_new();
    worker_max = worker_count();
    tmp = malloc(
        (::std::mem::size_of::<strm_worker>() as libc::c_ulong)
            .wrapping_mul(worker_max as libc::c_ulong),
    );
    workers = tmp as *mut strm_worker;
    i = 0 as libc::c_int;
    while i < worker_max {
        pthread_create(
            &mut (*workers.offset(i as isize)).th as *mut pthread_t,
            0 as *mut libc::c_void as *const pthread_attr_t,
            Some(
                task_loop as unsafe extern "C" fn(*mut libc::c_void) -> *mut libc::c_void,
            ),
            workers.offset(i as isize) as *mut libc::c_void,
        );
        i += 1;
    }
}
pub unsafe extern "C" fn strm_loop() -> libc::c_int {
    if stream_count == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    task_init();
    loop {
        sched_yield();
        if stream_count == 0 as libc::c_int {
            break;
        }
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_stream_new(
    mut mode: strm_stream_mode,
    mut start_func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    >,
    mut close_func: Option::<
        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
    >,
    mut data: *mut libc::c_void,
) -> *mut strm_stream {
    let mut s: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<strm_stream>() as libc::c_ulong);
    s = tmp as *mut strm_stream;
    (*s).type_0 = STRM_PTR_STREAM;
    (*s).mode = mode;
    (*s).start_func = start_func;
    (*s).close_func = close_func;
    (*s).data = data;
    (*s).dst = 0 as *mut libc::c_void as *mut strm_stream;
    (*s).rest = 0 as *mut libc::c_void as *mut *mut strm_stream;
    (*s).rsize = 0 as libc::c_int as size_t;
    (*s).rcapa = 0 as libc::c_int as size_t;
    (*s).flags = 0 as libc::c_uint;
    (*s).exc = 0 as *mut libc::c_void as *mut node_error;
    (*s).refcnt = 0 as libc::c_int;
    (*s).excl = 0 as libc::c_int;
    (*s).queue = strm_queue_new();
    ::std::intrinsics::atomic_xadd_seqcst(&mut stream_count, 1 as libc::c_int);
    return s;
}
pub unsafe extern "C" fn strm_stream_close(mut strm: *mut strm_stream) {
    let mut mode: strm_stream_mode = strm_producer;
    let mut tmp: bool = false;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: strm_value = 0;
    let mut i: libc::c_int = 0;
    let mut tmp___3: strm_value = 0;
    mode = (*strm).mode;
    if mode as libc::c_uint == 4 as libc::c_uint {
        return;
    }
    ::std::intrinsics::atomic_xsub_seqcst(&mut (*strm).refcnt, 1 as libc::c_int);
    if (*strm).refcnt > 0 as libc::c_int {
        return;
    }
    tmp = (::std::intrinsics::atomic_cxchg(
        &mut (*strm).mode,
        mode as libc::c_uint as strm_stream_mode,
        strm_killed,
    ))
        .1;
    if !tmp {
        return;
    }
    if ((*strm).close_func).is_some() {
        tmp___0 = strm_nil_value();
        tmp___1 = (Some(((*strm).close_func).expect("non-null function pointer")))
            .expect("non-null function pointer")(strm, tmp___0);
        if tmp___1 == 1 as libc::c_int {
            return;
        }
    } else {
        free((*strm).data);
        (*strm).data = 0 as *mut libc::c_void;
    }
    if !((*strm).dst).is_null() {
        tmp___2 = strm_nil_value();
        strm_task_push(
            (*strm).dst,
            ::std::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut strm_stream) -> ()>,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(Some(strm_stream_close as unsafe extern "C" fn(*mut strm_stream) -> ())),
            tmp___2,
        );
    }
    if !((*strm).rest).is_null() {
        i = 0 as libc::c_int;
        while (i as size_t) < (*strm).rsize {
            tmp___3 = strm_nil_value();
            strm_task_push(
                *((*strm).rest).offset(i as isize),
                ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(*mut strm_stream) -> ()>,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(
                    Some(
                        strm_stream_close as unsafe extern "C" fn(*mut strm_stream) -> (),
                    ),
                ),
                tmp___3,
            );
            i += 1;
        }
        free((*strm).rest as *mut libc::c_void);
    }
    ::std::intrinsics::atomic_xsub_seqcst(&mut stream_count, 1 as libc::c_int);
}
static mut khash_ac_HASH_UPPER___1: libc::c_double = 0.77f64;
#[inline]
unsafe extern "C" fn kh_init_kvs() -> *mut kh_kvs_t {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<kh_kvs_t>() as libc::c_ulong,
    );
    return tmp as *mut kh_kvs_t;
}
#[inline]
unsafe extern "C" fn kh_destroy_kvs(mut h: *mut kh_kvs_t) {
    if !h.is_null() {
        free((*h).keys as *mut libc::c_void);
        free((*h).flags as *mut libc::c_void);
        free((*h).vals as *mut libc::c_void);
        free(h as *mut libc::c_void);
    }
}
#[inline]
unsafe extern "C" fn kh_get_kvs(
    mut h: *const kh_kvs_t,
    mut key: strm_string,
) -> khint_t {
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp: khint_t = 0;
    if (*h).n_buckets != 0 {
        step = 0 as libc::c_int as khint_t;
        mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
        k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
        i = k & mask;
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if i == last {
                return (*h).n_buckets;
            }
        }
        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint != 0
        {
            tmp = (*h).n_buckets;
        } else {
            tmp = i;
        }
        return tmp;
    } else {
        return 0 as libc::c_int as khint_t
    };
}
#[inline]
unsafe extern "C" fn kh_resize_kvs(
    mut h: *mut kh_kvs_t,
    mut new_n_buckets: khint_t,
) -> libc::c_int {
    let mut new_flags: *mut khint32_t = 0 as *mut khint32_t;
    let mut j: khint_t = 0;
    let mut tmp: khint_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: khint_t = 0;
    let mut new_keys: *mut strm_string = 0 as *mut strm_string;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut new_vals: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut key: strm_string = 0;
    let mut val: strm_value = 0;
    let mut new_mask: khint_t = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp___4: strm_string = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    new_flags = 0 as *mut khint32_t;
    j = 1 as libc::c_int as khint_t;
    new_n_buckets = new_n_buckets.wrapping_sub(1);
    new_n_buckets |= new_n_buckets >> 1 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 2 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 4 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 8 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 16 as libc::c_int;
    new_n_buckets = new_n_buckets.wrapping_add(1);
    if new_n_buckets < 4 as libc::c_uint {
        new_n_buckets = 4 as libc::c_int as khint_t;
    }
    if (*h).size
        >= (new_n_buckets as libc::c_double * khash_ac_HASH_UPPER___1 + 0.5f64)
            as khint_t
    {
        j = 0 as libc::c_int as khint_t;
    } else {
        if new_n_buckets < 16 as libc::c_uint {
            tmp = 1 as libc::c_int as khint_t;
        } else {
            tmp = new_n_buckets >> 4 as libc::c_int;
        }
        tmp___0 = malloc(
            (tmp as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        new_flags = tmp___0 as *mut khint32_t;
        if new_flags.is_null() {
            return -(1 as libc::c_int);
        }
        if new_n_buckets < 16 as libc::c_uint {
            tmp___1 = 1 as libc::c_int as khint_t;
        } else {
            tmp___1 = new_n_buckets >> 4 as libc::c_int;
        }
        memset(
            new_flags as *mut libc::c_void,
            170 as libc::c_int,
            (tmp___1 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        if (*h).n_buckets < new_n_buckets {
            tmp___2 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_string>() as libc::c_ulong),
            );
            new_keys = tmp___2 as *mut strm_string;
            if new_keys.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).keys = new_keys;
            tmp___3 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
            );
            new_vals = tmp___3 as *mut strm_value;
            if new_vals.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).vals = new_vals;
        }
    }
    if j != 0 {
        j = 0 as libc::c_int as khint_t;
        while j != (*h).n_buckets {
            if *((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                >> ((j & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint
                == 0 as libc::c_uint
            {
                key = *((*h).keys).offset(j as isize);
                new_mask = new_n_buckets.wrapping_sub(1 as libc::c_uint);
                val = *((*h).vals).offset(j as isize);
                *((*h).flags)
                    .offset(
                        (j >> 4 as libc::c_int) as isize,
                    ) = (*((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                    as libc::c_ulong
                    | (1 as libc::c_ulong)
                        << ((j & 15 as libc::c_uint) << 1 as libc::c_int)) as khint32_t;
                loop {
                    step = 0 as libc::c_int as khint_t;
                    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int)
                        as khint32_t;
                    i = k & new_mask;
                    while *new_flags.offset((i >> 4 as libc::c_int) as isize)
                        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                        & 2 as libc::c_uint == 0
                    {
                        step = step.wrapping_add(1);
                        i = i.wrapping_add(step) & new_mask;
                    }
                    *new_flags
                        .offset(
                            (i >> 4 as libc::c_int) as isize,
                        ) = (*new_flags.offset((i >> 4 as libc::c_int) as isize)
                        as libc::c_ulong
                        & !((2 as libc::c_ulong)
                            << ((i & 15 as libc::c_uint) << 1 as libc::c_int)))
                        as khint32_t;
                    if i < (*h).n_buckets {
                        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                            & 3 as libc::c_uint == 0 as libc::c_uint
                        {
                            tmp___4 = *((*h).keys).offset(i as isize);
                            *((*h).keys).offset(i as isize) = key;
                            key = tmp___4;
                            tmp___5 = *((*h).vals).offset(i as isize);
                            *((*h).vals).offset(i as isize) = val;
                            val = tmp___5;
                            *((*h).flags)
                                .offset(
                                    (i >> 4 as libc::c_int) as isize,
                                ) = (*((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                                as libc::c_ulong
                                | (1 as libc::c_ulong)
                                    << ((i & 15 as libc::c_uint) << 1 as libc::c_int))
                                as khint32_t;
                        } else {
                            *((*h).keys).offset(i as isize) = key;
                            *((*h).vals).offset(i as isize) = val;
                            break;
                        }
                    } else {
                        *((*h).keys).offset(i as isize) = key;
                        *((*h).vals).offset(i as isize) = val;
                        break;
                    }
                }
            }
            j = j.wrapping_add(1);
        }
        if (*h).n_buckets > new_n_buckets {
            tmp___6 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_string>() as libc::c_ulong),
            );
            (*h).keys = tmp___6 as *mut strm_string;
            tmp___7 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
            );
            (*h).vals = tmp___7 as *mut strm_value;
        }
        free((*h).flags as *mut libc::c_void);
        (*h).flags = new_flags;
        (*h).n_buckets = new_n_buckets;
        (*h).n_occupied = (*h).size;
        (*h)
            .upper_bound = ((*h).n_buckets as libc::c_double * khash_ac_HASH_UPPER___1
            + 0.5f64) as khint_t;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn kh_put_kvs(
    mut h: *mut kh_kvs_t,
    mut key: strm_string,
    mut ret: *mut libc::c_int,
) -> khint_t {
    let mut x: khint_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut site: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    if (*h).n_occupied >= (*h).upper_bound {
        if (*h).n_buckets > (*h).size << 1 as libc::c_int {
            tmp = kh_resize_kvs(h, ((*h).n_buckets).wrapping_sub(1 as libc::c_uint));
            if tmp < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        } else {
            tmp___0 = kh_resize_kvs(h, ((*h).n_buckets).wrapping_add(1 as libc::c_uint));
            if tmp___0 < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        }
    }
    mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
    step = 0 as libc::c_int as khint_t;
    site = (*h).n_buckets;
    x = site;
    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
    i = k & mask;
    if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        x = i;
    } else {
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                != 0
            {
                site = i;
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if !(i == last) {
                continue;
            }
            x = site;
            break;
        }
        if x == (*h).n_buckets {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint
                != 0
            {
                if site != (*h).n_buckets {
                    x = site;
                } else {
                    x = i;
                }
            } else {
                x = i;
            }
        }
    }
    if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
        >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        (*h).n_occupied = ((*h).n_occupied).wrapping_add(1);
        *ret = 1 as libc::c_int;
    } else if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
            >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint != 0
        {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        *ret = 2 as libc::c_int;
    } else {
        *ret = 0 as libc::c_int;
    }
    return x;
}
#[inline]
unsafe extern "C" fn kh_init_txn() -> *mut kh_txn_t {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<kh_txn_t>() as libc::c_ulong,
    );
    return tmp as *mut kh_txn_t;
}
#[inline]
unsafe extern "C" fn kh_destroy_txn(mut h: *mut kh_txn_t) {
    if !h.is_null() {
        free((*h).keys as *mut libc::c_void);
        free((*h).flags as *mut libc::c_void);
        free((*h).vals as *mut libc::c_void);
        free(h as *mut libc::c_void);
    }
}
#[inline]
unsafe extern "C" fn kh_get_txn(
    mut h: *const kh_txn_t,
    mut key: strm_string,
) -> khint_t {
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp: khint_t = 0;
    if (*h).n_buckets != 0 {
        step = 0 as libc::c_int as khint_t;
        mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
        k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
        i = k & mask;
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if i == last {
                return (*h).n_buckets;
            }
        }
        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint != 0
        {
            tmp = (*h).n_buckets;
        } else {
            tmp = i;
        }
        return tmp;
    } else {
        return 0 as libc::c_int as khint_t
    };
}
#[inline]
unsafe extern "C" fn kh_resize_txn(
    mut h: *mut kh_txn_t,
    mut new_n_buckets: khint_t,
) -> libc::c_int {
    let mut new_flags: *mut khint32_t = 0 as *mut khint32_t;
    let mut j: khint_t = 0;
    let mut tmp: khint_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: khint_t = 0;
    let mut new_keys: *mut strm_string = 0 as *mut strm_string;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut new_vals: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut key: strm_string = 0;
    let mut val: strm_value = 0;
    let mut new_mask: khint_t = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp___4: strm_string = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    new_flags = 0 as *mut khint32_t;
    j = 1 as libc::c_int as khint_t;
    new_n_buckets = new_n_buckets.wrapping_sub(1);
    new_n_buckets |= new_n_buckets >> 1 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 2 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 4 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 8 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 16 as libc::c_int;
    new_n_buckets = new_n_buckets.wrapping_add(1);
    if new_n_buckets < 4 as libc::c_uint {
        new_n_buckets = 4 as libc::c_int as khint_t;
    }
    if (*h).size
        >= (new_n_buckets as libc::c_double * khash_ac_HASH_UPPER___1 + 0.5f64)
            as khint_t
    {
        j = 0 as libc::c_int as khint_t;
    } else {
        if new_n_buckets < 16 as libc::c_uint {
            tmp = 1 as libc::c_int as khint_t;
        } else {
            tmp = new_n_buckets >> 4 as libc::c_int;
        }
        tmp___0 = malloc(
            (tmp as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        new_flags = tmp___0 as *mut khint32_t;
        if new_flags.is_null() {
            return -(1 as libc::c_int);
        }
        if new_n_buckets < 16 as libc::c_uint {
            tmp___1 = 1 as libc::c_int as khint_t;
        } else {
            tmp___1 = new_n_buckets >> 4 as libc::c_int;
        }
        memset(
            new_flags as *mut libc::c_void,
            170 as libc::c_int,
            (tmp___1 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        if (*h).n_buckets < new_n_buckets {
            tmp___2 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_string>() as libc::c_ulong),
            );
            new_keys = tmp___2 as *mut strm_string;
            if new_keys.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).keys = new_keys;
            tmp___3 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
            );
            new_vals = tmp___3 as *mut strm_value;
            if new_vals.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).vals = new_vals;
        }
    }
    if j != 0 {
        j = 0 as libc::c_int as khint_t;
        while j != (*h).n_buckets {
            if *((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                >> ((j & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint
                == 0 as libc::c_uint
            {
                key = *((*h).keys).offset(j as isize);
                new_mask = new_n_buckets.wrapping_sub(1 as libc::c_uint);
                val = *((*h).vals).offset(j as isize);
                *((*h).flags)
                    .offset(
                        (j >> 4 as libc::c_int) as isize,
                    ) = (*((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                    as libc::c_ulong
                    | (1 as libc::c_ulong)
                        << ((j & 15 as libc::c_uint) << 1 as libc::c_int)) as khint32_t;
                loop {
                    step = 0 as libc::c_int as khint_t;
                    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int)
                        as khint32_t;
                    i = k & new_mask;
                    while *new_flags.offset((i >> 4 as libc::c_int) as isize)
                        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                        & 2 as libc::c_uint == 0
                    {
                        step = step.wrapping_add(1);
                        i = i.wrapping_add(step) & new_mask;
                    }
                    *new_flags
                        .offset(
                            (i >> 4 as libc::c_int) as isize,
                        ) = (*new_flags.offset((i >> 4 as libc::c_int) as isize)
                        as libc::c_ulong
                        & !((2 as libc::c_ulong)
                            << ((i & 15 as libc::c_uint) << 1 as libc::c_int)))
                        as khint32_t;
                    if i < (*h).n_buckets {
                        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                            & 3 as libc::c_uint == 0 as libc::c_uint
                        {
                            tmp___4 = *((*h).keys).offset(i as isize);
                            *((*h).keys).offset(i as isize) = key;
                            key = tmp___4;
                            tmp___5 = *((*h).vals).offset(i as isize);
                            *((*h).vals).offset(i as isize) = val;
                            val = tmp___5;
                            *((*h).flags)
                                .offset(
                                    (i >> 4 as libc::c_int) as isize,
                                ) = (*((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                                as libc::c_ulong
                                | (1 as libc::c_ulong)
                                    << ((i & 15 as libc::c_uint) << 1 as libc::c_int))
                                as khint32_t;
                        } else {
                            *((*h).keys).offset(i as isize) = key;
                            *((*h).vals).offset(i as isize) = val;
                            break;
                        }
                    } else {
                        *((*h).keys).offset(i as isize) = key;
                        *((*h).vals).offset(i as isize) = val;
                        break;
                    }
                }
            }
            j = j.wrapping_add(1);
        }
        if (*h).n_buckets > new_n_buckets {
            tmp___6 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_string>() as libc::c_ulong),
            );
            (*h).keys = tmp___6 as *mut strm_string;
            tmp___7 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_value>() as libc::c_ulong),
            );
            (*h).vals = tmp___7 as *mut strm_value;
        }
        free((*h).flags as *mut libc::c_void);
        (*h).flags = new_flags;
        (*h).n_buckets = new_n_buckets;
        (*h).n_occupied = (*h).size;
        (*h)
            .upper_bound = ((*h).n_buckets as libc::c_double * khash_ac_HASH_UPPER___1
            + 0.5f64) as khint_t;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn kh_put_txn(
    mut h: *mut kh_txn_t,
    mut key: strm_string,
    mut ret: *mut libc::c_int,
) -> khint_t {
    let mut x: khint_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut site: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    if (*h).n_occupied >= (*h).upper_bound {
        if (*h).n_buckets > (*h).size << 1 as libc::c_int {
            tmp = kh_resize_txn(h, ((*h).n_buckets).wrapping_sub(1 as libc::c_uint));
            if tmp < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        } else {
            tmp___0 = kh_resize_txn(h, ((*h).n_buckets).wrapping_add(1 as libc::c_uint));
            if tmp___0 < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        }
    }
    mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
    step = 0 as libc::c_int as khint_t;
    site = (*h).n_buckets;
    x = site;
    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
    i = k & mask;
    if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        x = i;
    } else {
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                != 0
            {
                site = i;
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if !(i == last) {
                continue;
            }
            x = site;
            break;
        }
        if x == (*h).n_buckets {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint
                != 0
            {
                if site != (*h).n_buckets {
                    x = site;
                } else {
                    x = i;
                }
            } else {
                x = i;
            }
        }
    }
    if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
        >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        (*h).n_occupied = ((*h).n_occupied).wrapping_add(1);
        *ret = 1 as libc::c_int;
    } else if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
            >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint != 0
        {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        *ret = 2 as libc::c_int;
    } else {
        *ret = 0 as libc::c_int;
    }
    return x;
}
unsafe extern "C" fn get_kvs(
    mut argc: libc::c_int,
    mut args: *mut strm_value,
) -> *mut strm_kvs {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if argc == 0 as libc::c_int {
        return 0 as *mut libc::c_void as *mut strm_kvs;
    }
    tmp = strm_value_ptr(*args.offset(0 as libc::c_int as isize), STRM_PTR_AUX);
    return tmp as *mut strm_kvs;
}
unsafe extern "C" fn kvs_get(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut k: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut tmp: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut key: strm_string = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: strm_string = 0;
    let mut i: khiter_t = 0;
    tmp = get_kvs(argc, args);
    k = tmp;
    tmp___0 = strm_to_str(*args.offset(1 as libc::c_int as isize));
    tmp___1 = strm_str_intern_str(tmp___0);
    key = tmp___1;
    if k.is_null() {
        strm_raise(strm, b"no kvs given\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    pthread_mutex_lock(&mut (*k).lock);
    i = kh_get_kvs((*k).kv as *const kh_kvs_t, key);
    if i == (*(*k).kv).n_buckets {
        *ret = strm_nil_value();
    } else {
        *ret = *((*(*k).kv).vals).offset(i as isize);
    }
    pthread_mutex_unlock(&mut (*k).lock);
    return 0 as libc::c_int;
}
unsafe extern "C" fn kvs_serial(mut kvs: *mut strm_kvs) -> uint64_t {
    let mut serial: uint64_t = 0;
    pthread_mutex_lock(&mut (*kvs).lock);
    serial = (*kvs).serial;
    pthread_mutex_unlock(&mut (*kvs).lock);
    return serial;
}
unsafe extern "C" fn kvs_put(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut k: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut tmp: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut key: strm_string = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: strm_string = 0;
    let mut i: khiter_t = 0;
    let mut st: libc::c_int = 0;
    tmp = get_kvs(argc, args);
    k = tmp;
    tmp___0 = strm_to_str(*args.offset(1 as libc::c_int as isize));
    tmp___1 = strm_str_intern_str(tmp___0);
    key = tmp___1;
    if k.is_null() {
        strm_raise(strm, b"no kvs given\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    pthread_mutex_lock(&mut (*k).lock);
    i = kh_put_kvs((*k).kv, key, &mut st);
    if st < 0 as libc::c_int {
        pthread_mutex_unlock(&mut (*k).lock);
        return 1 as libc::c_int;
    }
    (*k).serial = ((*k).serial).wrapping_add(1);
    *((*(*k).kv).vals).offset(i as isize) = *args.offset(2 as libc::c_int as isize);
    pthread_mutex_unlock(&mut (*k).lock);
    return 0 as libc::c_int;
}
unsafe extern "C" fn kvs_update(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut k: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut tmp: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut key: strm_string = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: strm_string = 0;
    let mut old: strm_value = 0;
    let mut val: strm_value = 0;
    let mut i: khiter_t = 0;
    let mut st: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = get_kvs(argc, args);
    k = tmp;
    tmp___0 = strm_to_str(*args.offset(1 as libc::c_int as isize));
    tmp___1 = strm_str_intern_str(tmp___0);
    key = tmp___1;
    if k.is_null() {
        strm_raise(strm, b"no kvs given\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    pthread_mutex_lock(&mut (*k).lock);
    i = kh_get_kvs((*k).kv as *const kh_kvs_t, key);
    if i == (*(*k).kv).n_buckets {
        pthread_mutex_unlock(&mut (*k).lock);
        return 1 as libc::c_int;
    }
    old = *((*(*k).kv).vals).offset(i as isize);
    pthread_mutex_unlock(&mut (*k).lock);
    tmp___2 = strm_funcall(
        strm,
        *args.offset(2 as libc::c_int as isize),
        1 as libc::c_int,
        &mut old,
        &mut val,
    );
    if tmp___2 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    pthread_mutex_lock(&mut (*k).lock);
    i = kh_put_kvs((*k).kv, key, &mut st);
    if st != 0 as libc::c_int {
        pthread_mutex_unlock(&mut (*k).lock);
        return 1 as libc::c_int;
    } else {
        if *((*(*k).kv).vals).offset(i as isize) != old {
            pthread_mutex_unlock(&mut (*k).lock);
            return 1 as libc::c_int;
        }
    }
    (*k).serial = ((*k).serial).wrapping_add(1);
    *((*(*k).kv).vals).offset(i as isize) = val;
    pthread_mutex_unlock(&mut (*k).lock);
    *ret = val;
    return 0 as libc::c_int;
}
unsafe extern "C" fn kvs_close(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut k: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut tmp: *mut strm_kvs = 0 as *mut strm_kvs;
    tmp = get_kvs(argc, args);
    k = tmp;
    if k.is_null() {
        strm_raise(strm, b"no kvs given\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    kh_destroy_kvs((*k).kv);
    return 0 as libc::c_int;
}
static mut ns_kvs: *mut strm_state = 0 as *const strm_state as *mut strm_state;
static mut ns_txn: *mut strm_state = 0 as *const strm_state as *mut strm_state;
unsafe extern "C" fn kvs_new(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut k: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<strm_kvs>() as libc::c_ulong);
    k = tmp as *mut strm_kvs;
    if k.is_null() {
        return 1 as libc::c_int;
    }
    (*k).ns = ns_kvs;
    (*k).type_0 = STRM_PTR_AUX;
    (*k).kv = kh_init_kvs();
    (*k).serial = 1 as libc::c_int as uint64_t;
    pthread_mutex_init(
        &mut (*k).lock,
        0 as *mut libc::c_void as *const pthread_mutexattr_t,
    );
    *ret = strm_ptr_value(k as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn txn_new(mut kvs: *mut strm_kvs) -> *mut strm_txn {
    let mut t: *mut strm_txn = 0 as *mut strm_txn;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<strm_txn>() as libc::c_ulong);
    t = tmp as *mut strm_txn;
    if t.is_null() {
        return 0 as *mut libc::c_void as *mut strm_txn;
    }
    (*t).ns = ns_txn;
    (*t).type_0 = STRM_PTR_AUX;
    (*t).tv = kh_init_txn();
    (*t).kvs = kvs;
    (*t).serial = kvs_serial(kvs);
    return t;
}
unsafe extern "C" fn txn_free(mut txn: *mut strm_txn) {
    kh_destroy_txn((*txn).tv);
    (*txn).tv = 0 as *mut libc::c_void as *mut kh_txn_t;
}
unsafe extern "C" fn kvs_txn(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut kvs: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut tmp: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut txn: *mut strm_txn = 0 as *mut strm_txn;
    let mut val: strm_value = 0;
    let mut i: khiter_t = 0;
    let mut j: khiter_t = 0;
    let mut tv: *mut kh_txn_t = 0 as *mut kh_txn_t;
    let mut kv: *mut kh_kvs_t = 0 as *mut kh_kvs_t;
    let mut st: libc::c_int = 0;
    let mut result: libc::c_int = 0;
    let mut tries: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut key: strm_value = 0;
    let mut v: strm_value = 0;
    tmp = get_kvs(argc, args);
    kvs = tmp;
    st = 0 as libc::c_int;
    result = 0 as libc::c_int;
    tries = 0 as libc::c_int;
    if kvs.is_null() {
        strm_raise(strm, b"no kvs given\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    txn = txn_new(kvs);
    val = strm_ptr_value(txn as *mut libc::c_void);
    '_retry: loop {
        tmp___0 = strm_funcall(
            strm,
            *args.offset(1 as libc::c_int as isize),
            1 as libc::c_int,
            &mut val,
            ret,
        );
        if tmp___0 == 1 as libc::c_int {
            if (*txn).serial == 0 as libc::c_ulong {
                tries += 1;
                if tries > 10 as libc::c_int {
                    strm_raise(
                        strm,
                        b"too many transaction retries\0" as *const u8
                            as *const libc::c_char,
                    );
                    break;
                } else {
                    (*txn).serial = kvs_serial(kvs);
                }
            } else {
                txn_free(txn);
                return 1 as libc::c_int;
            }
        } else {
            pthread_mutex_lock(&mut (*kvs).lock);
            if (*kvs).serial != (*txn).serial {
                pthread_mutex_unlock(&mut (*kvs).lock);
            } else {
                kv = (*kvs).kv;
                tv = (*txn).tv;
                i = 0 as libc::c_int as khint_t;
                while i != (*tv).n_buckets {
                    if *((*tv).flags).offset((i >> 4 as libc::c_int) as isize)
                        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                        & 3 as libc::c_uint == 0
                    {
                        key = *((*tv).keys).offset(i as isize);
                        v = *((*tv).vals).offset(i as isize);
                        j = kh_put_kvs(kv, key, &mut st);
                        if st < 0 as libc::c_int {
                            pthread_mutex_unlock(&mut (*kvs).lock);
                            break '_retry;
                        } else {
                            *((*kv).vals).offset(j as isize) = v;
                        }
                    }
                    i = i.wrapping_add(1);
                }
                if result == 0 as libc::c_int {
                    (*kvs).serial = ((*kvs).serial).wrapping_add(1);
                }
                pthread_mutex_unlock(&mut (*kvs).lock);
                match result {
                    1 => {
                        continue;
                    }
                    _ => {}
                }
                txn_free(txn);
                return 0 as libc::c_int;
            }
        }
    }
    txn_free(txn);
    return 1 as libc::c_int;
}
unsafe extern "C" fn get_txn(
    mut argc: libc::c_int,
    mut args: *mut strm_value,
) -> *mut strm_txn {
    let mut txn: *mut strm_txn = 0 as *mut strm_txn;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if argc == 0 as libc::c_int {
        return 0 as *mut libc::c_void as *mut strm_txn;
    }
    tmp = strm_value_ptr(*args.offset(0 as libc::c_int as isize), STRM_PTR_AUX);
    txn = tmp as *mut strm_txn;
    if ((*txn).tv).is_null() {
        return 0 as *mut libc::c_void as *mut strm_txn;
    }
    return txn;
}
unsafe extern "C" fn void_txn(mut strm: *mut strm_stream) -> libc::c_int {
    strm_raise(strm, b"invalid transaction\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
unsafe extern "C" fn txn_retry(mut txn: *mut strm_txn) -> libc::c_int {
    (*txn).serial = 0 as libc::c_int as uint64_t;
    return 1 as libc::c_int;
}
unsafe extern "C" fn txn_get(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut t: *mut strm_txn = 0 as *mut strm_txn;
    let mut tmp: *mut strm_txn = 0 as *mut strm_txn;
    let mut k: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut key: strm_string = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: strm_string = 0;
    let mut i: khiter_t = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: uint64_t = 0;
    tmp = get_txn(argc, args);
    t = tmp;
    tmp___0 = strm_to_str(*args.offset(1 as libc::c_int as isize));
    tmp___1 = strm_str_intern_str(tmp___0);
    key = tmp___1;
    if t.is_null() {
        tmp___2 = void_txn(strm);
        return tmp___2;
    }
    k = (*t).kvs;
    tmp___4 = kvs_serial(k);
    if (*t).serial != tmp___4 {
        tmp___3 = txn_retry(t);
        return tmp___3;
    }
    i = kh_get_txn((*t).tv as *const kh_txn_t, key);
    if i == (*(*t).tv).n_buckets {
        pthread_mutex_lock(&mut (*k).lock);
        i = kh_get_kvs((*k).kv as *const kh_kvs_t, key);
        if i == (*(*k).kv).n_buckets {
            *ret = strm_nil_value();
        } else {
            *ret = *((*(*k).kv).vals).offset(i as isize);
        }
        pthread_mutex_unlock(&mut (*k).lock);
    } else {
        *ret = *((*(*t).tv).vals).offset(i as isize);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn txn_put(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut t: *mut strm_txn = 0 as *mut strm_txn;
    let mut tmp: *mut strm_txn = 0 as *mut strm_txn;
    let mut key: strm_string = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: strm_string = 0;
    let mut i: khiter_t = 0;
    let mut st: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = get_txn(argc, args);
    t = tmp;
    tmp___0 = strm_to_str(*args.offset(1 as libc::c_int as isize));
    tmp___1 = strm_str_intern_str(tmp___0);
    key = tmp___1;
    if t.is_null() {
        tmp___2 = void_txn(strm);
        return tmp___2;
    }
    i = kh_put_txn((*t).tv, key, &mut st);
    if st < 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    *((*(*t).tv).vals).offset(i as isize) = *args.offset(2 as libc::c_int as isize);
    return 0 as libc::c_int;
}
unsafe extern "C" fn txn_update(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut t: *mut strm_txn = 0 as *mut strm_txn;
    let mut tmp: *mut strm_txn = 0 as *mut strm_txn;
    let mut k: *mut strm_kvs = 0 as *mut strm_kvs;
    let mut key: strm_string = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: strm_string = 0;
    let mut val: strm_value = 0;
    let mut i: khiter_t = 0;
    let mut st: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: uint64_t = 0;
    let mut tmp___5: libc::c_int = 0;
    tmp = get_txn(argc, args);
    t = tmp;
    tmp___0 = strm_to_str(*args.offset(1 as libc::c_int as isize));
    tmp___1 = strm_str_intern_str(tmp___0);
    key = tmp___1;
    if t.is_null() {
        tmp___2 = void_txn(strm);
        return tmp___2;
    }
    k = (*t).kvs;
    tmp___4 = kvs_serial(k);
    if (*t).serial != tmp___4 {
        tmp___3 = txn_retry(t);
        return tmp___3;
    }
    i = kh_put_txn((*t).tv, key, &mut st);
    if st < 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    if st == 0 as libc::c_int {
        val = *((*(*t).tv).vals).offset(i as isize);
    } else {
        pthread_mutex_lock(&mut (*k).lock);
        i = kh_get_kvs((*k).kv as *const kh_kvs_t, key);
        if i == (*(*k).kv).n_buckets {
            pthread_mutex_unlock(&mut (*k).lock);
            return 1 as libc::c_int;
        } else {
            val = *((*(*k).kv).vals).offset(i as isize);
        }
        pthread_mutex_unlock(&mut (*k).lock);
    }
    tmp___5 = strm_funcall(
        strm,
        *args.offset(2 as libc::c_int as isize),
        1 as libc::c_int,
        &mut val,
        &mut val,
    );
    if tmp___5 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *((*(*t).tv).vals).offset(i as isize) = val;
    *ret = val;
    return 0 as libc::c_int;
}
unsafe extern "C" fn to_str(
    mut strm: *mut strm_stream,
    mut val: strm_value,
    mut type_0: *mut libc::c_char,
) -> strm_value {
    let mut buf: [libc::c_char; 256] = [0; 256];
    let mut n: libc::c_int = 0;
    let mut tmp: strm_string = 0;
    n = sprintf(
        buf.as_mut_ptr(),
        b"<%s:%p>\0" as *const u8 as *const libc::c_char,
        type_0,
        (val & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
            as *mut libc::c_void,
    );
    tmp = strm_str_new(buf.as_mut_ptr() as *const libc::c_char, n);
    return tmp;
}
unsafe extern "C" fn kvs_str(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    if argc != 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = to_str(
        strm,
        *args.offset(0 as libc::c_int as isize),
        b"kvs\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn txn_str(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    if argc != 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = to_str(
        strm,
        *args.offset(0 as libc::c_int as isize),
        b"txn\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
    );
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_kvs_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: strm_value = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: strm_value = 0;
    let mut tmp___7: strm_value = 0;
    let mut tmp___8: strm_value = 0;
    let mut tmp___9: strm_value = 0;
    ns_kvs = strm_ns_new(
        0 as *mut libc::c_void as *mut strm_state,
        b"kvs\0" as *const u8 as *const libc::c_char,
    );
    tmp = strm_cfunc_value(
        Some(
            kvs_get
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_kvs, b"get\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            kvs_put
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_kvs, b"put\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_cfunc_value(
        Some(
            kvs_update
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_kvs, b"update\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            kvs_txn
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_kvs, b"txn\0" as *const u8 as *const libc::c_char, tmp___2);
    tmp___3 = strm_cfunc_value(
        Some(
            kvs_close
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_kvs, b"close\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = strm_cfunc_value(
        Some(
            kvs_str
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_kvs, b"string\0" as *const u8 as *const libc::c_char, tmp___4);
    ns_txn = strm_ns_new(
        0 as *mut libc::c_void as *mut strm_state,
        b"kvs_txn\0" as *const u8 as *const libc::c_char,
    );
    tmp___5 = strm_cfunc_value(
        Some(
            txn_get
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_txn, b"get\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = strm_cfunc_value(
        Some(
            txn_put
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_txn, b"put\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = strm_cfunc_value(
        Some(
            txn_update
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_txn, b"update\0" as *const u8 as *const libc::c_char, tmp___7);
    tmp___8 = strm_cfunc_value(
        Some(
            txn_str
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(ns_kvs, b"string\0" as *const u8 as *const libc::c_char, tmp___8);
    tmp___9 = strm_cfunc_value(
        Some(
            kvs_new
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"kvs\0" as *const u8 as *const libc::c_char, tmp___9);
}
pub unsafe extern "C" fn node_array_new() -> *mut node {
    let mut v: *mut node_array = 0 as *mut node_array;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_array>() as libc::c_ulong);
    v = tmp as *mut node_array;
    (*v).type_0 = NODE_ARRAY;
    (*v).len = 0 as libc::c_int;
    (*v).max = 0 as libc::c_int;
    (*v).data = 0 as *mut libc::c_void as *mut *mut node;
    (*v).headers = 0 as *mut libc::c_void as *mut node_string_0;
    (*v).ns = 0 as *mut libc::c_void as node_string_0;
    return v as *mut node;
}
pub unsafe extern "C" fn node_pair_new(
    mut key: node_string_0,
    mut value: *mut node,
) -> *mut node {
    let mut npair: *mut node_pair = 0 as *mut node_pair;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_pair>() as libc::c_ulong);
    npair = tmp as *mut node_pair;
    (*npair).type_0 = NODE_PAIR;
    (*npair).key = key;
    (*npair).value = value;
    return npair as *mut node;
}
pub unsafe extern "C" fn node_array_headers(mut np: *mut node) -> *mut node {
    let mut i: libc::c_int = 0;
    let mut v: *mut node_array = 0 as *mut node_array;
    let mut headers: *mut node_string_0 = 0 as *mut node_string_0;
    let mut npair: *mut node_pair = 0 as *mut node_pair;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    headers = 0 as *mut libc::c_void as *mut node_string_0;
    if np.is_null() {
        np = node_array_new();
    }
    v = np as *mut node_array;
    i = 0 as libc::c_int;
    while i < (*v).len {
        npair = *((*v).data).offset(i as isize) as *mut node_pair;
        if !npair.is_null() {
            if (*npair).type_0 as libc::c_uint == 7 as libc::c_uint {
                if headers.is_null() {
                    tmp = malloc(
                        (::std::mem::size_of::<node_string_0>() as libc::c_ulong)
                            .wrapping_mul((*v).len as libc::c_ulong),
                    );
                    headers = tmp as *mut node_string_0;
                }
                let ref mut fresh4 = *headers.offset(i as isize);
                *fresh4 = (*npair).key;
                let ref mut fresh5 = *((*v).data).offset(i as isize);
                *fresh5 = (*npair).value;
                free(npair as *mut libc::c_void);
            }
        }
        i += 1;
    }
    (*v).headers = headers;
    return np;
}
pub unsafe extern "C" fn node_array_add(mut a: *mut node, mut data: *mut node) {
    let mut _v: *mut node_array = 0 as *mut node_array;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    _v = a as *mut node_array;
    if (*_v).len == (*_v).max {
        (*_v).max = (*_v).len + 10 as libc::c_int;
        tmp = realloc(
            (*_v).data as *mut libc::c_void,
            (::std::mem::size_of::<*mut node>() as libc::c_ulong)
                .wrapping_mul((*_v).max as libc::c_ulong),
        );
        (*_v).data = tmp as *mut *mut node;
    }
    let ref mut fresh6 = *((*_v).data).offset((*_v).len as isize);
    *fresh6 = data;
    (*_v).len += 1;
}
pub unsafe extern "C" fn node_array_free(mut v: *mut node_array) {
    let mut i: strm_int = 0;
    i = 0 as libc::c_int;
    while i < (*v).len {
        node_free(*((*v).data).offset(i as isize));
        i += 1;
    }
    free((*v).data as *mut libc::c_void);
    if !((*v).headers).is_null() {
        i = 0 as libc::c_int;
        while i < (*v).len {
            free(*((*v).headers).offset(i as isize) as *mut libc::c_void);
            i += 1;
        }
        free((*v).headers as *mut libc::c_void);
    }
    if !((*v).ns).is_null() {
        free((*v).ns as *mut libc::c_void);
    }
    free(v as *mut libc::c_void);
}
pub unsafe extern "C" fn node_nodes_new() -> *mut node {
    let mut v: *mut node_nodes = 0 as *mut node_nodes;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_nodes>() as libc::c_ulong);
    v = tmp as *mut node_nodes;
    (*v).type_0 = NODE_NODES;
    (*v).len = 0 as libc::c_int;
    (*v).max = 0 as libc::c_int;
    (*v).data = 0 as *mut libc::c_void as *mut *mut node;
    return v as *mut node;
}
pub unsafe extern "C" fn node_nodes_add(mut a: *mut node, mut data: *mut node) {
    let mut _v: *mut node_nodes = 0 as *mut node_nodes;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    _v = a as *mut node_nodes;
    if (*_v).len == (*_v).max {
        (*_v).max = (*_v).len + 10 as libc::c_int;
        tmp = realloc(
            (*_v).data as *mut libc::c_void,
            (::std::mem::size_of::<*mut node>() as libc::c_ulong)
                .wrapping_mul((*_v).max as libc::c_ulong),
        );
        (*_v).data = tmp as *mut *mut node;
    }
    let ref mut fresh7 = *((*_v).data).offset((*_v).len as isize);
    *fresh7 = data;
    (*_v).len += 1;
}
pub unsafe extern "C" fn node_nodes_prepend(mut a: *mut node, mut data: *mut node) {
    let mut _v: *mut node_nodes = 0 as *mut node_nodes;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    _v = a as *mut node_nodes;
    if (*_v).len == (*_v).max {
        (*_v).max = (*_v).len + 10 as libc::c_int;
        tmp = realloc(
            (*_v).data as *mut libc::c_void,
            (::std::mem::size_of::<*mut node>() as libc::c_ulong)
                .wrapping_mul((*_v).max as libc::c_ulong),
        );
        (*_v).data = tmp as *mut *mut node;
    }
    memmove(
        ((*_v).data).offset(1 as libc::c_int as isize) as *mut libc::c_void,
        (*_v).data as *const libc::c_void,
        ((*_v).len as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<*mut node>() as libc::c_ulong),
    );
    let ref mut fresh8 = *((*_v).data).offset(0 as libc::c_int as isize);
    *fresh8 = data;
    (*_v).len += 1;
}
pub unsafe extern "C" fn node_nodes_concat(
    mut s: *mut node,
    mut s2: *mut node,
) -> *mut node {
    let mut v: *mut node_nodes = 0 as *mut node_nodes;
    let mut v2: *mut node_nodes = 0 as *mut node_nodes;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    if s.is_null() {
        return s2;
    }
    if !s2.is_null() {
        v = s as *mut node_nodes;
        v2 = s2 as *mut node_nodes;
        if (*v).len + (*v2).len > (*v).max {
            (*v).max = (*v).len + (*v2).len + 10 as libc::c_int;
            tmp = realloc(
                (*v).data as *mut libc::c_void,
                (::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong)
                    .wrapping_mul((*v).max as libc::c_ulong),
            );
            (*v).data = tmp as *mut *mut node;
        }
        memcpy(
            ((*v).data).offset((*v).len as isize) as *mut libc::c_void,
            (*v2).data as *const libc::c_void,
            ((*v2).len as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<*mut node>() as libc::c_ulong),
        );
        (*v).len += (*v2).len;
    }
    return s;
}
pub unsafe extern "C" fn node_nodes_free(mut v: *mut node_nodes) {
    let mut i: strm_int = 0;
    i = 0 as libc::c_int;
    while i < (*v).len {
        node_free(*((*v).data).offset(i as isize));
        i += 1;
    }
    free((*v).data as *mut libc::c_void);
    free(v as *mut libc::c_void);
}
pub unsafe extern "C" fn node_obj_new(
    mut np: *mut node,
    mut ns: node_string_0,
) -> *mut node {
    let mut v: *mut node_array = 0 as *mut node_array;
    let mut tmp: *mut node = 0 as *mut node;
    if np.is_null() {
        tmp = node_array_new();
        v = tmp as *mut node_array;
    } else {
        v = np as *mut node_array;
    }
    (*v).ns = ns;
    return v as *mut node;
}
pub unsafe extern "C" fn node_args_new() -> *mut node {
    let mut v: *mut node_args = 0 as *mut node_args;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_args>() as libc::c_ulong);
    v = tmp as *mut node_args;
    (*v).type_0 = NODE_ARGS;
    (*v).len = 0 as libc::c_int;
    (*v).max = 0 as libc::c_int;
    (*v).data = 0 as *mut libc::c_void as *mut node_string_0;
    return v as *mut node;
}
pub unsafe extern "C" fn node_args_add(mut v: *mut node, mut data: node_string_0) {
    let mut _v: *mut node_args = 0 as *mut node_args;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    _v = v as *mut node_args;
    if (*_v).len == (*_v).max {
        (*_v).max = (*_v).len + 10 as libc::c_int;
        tmp = realloc(
            (*_v).data as *mut libc::c_void,
            (::std::mem::size_of::<node_string_0>() as libc::c_ulong)
                .wrapping_mul((*_v).max as libc::c_ulong),
        );
        (*_v).data = tmp as *mut node_string_0;
    }
    let ref mut fresh9 = *((*_v).data).offset((*_v).len as isize);
    *fresh9 = data;
    (*_v).len += 1;
}
pub unsafe extern "C" fn node_args_prepend(mut a: *mut node, mut data: node_string_0) {
    let mut _v: *mut node_args = 0 as *mut node_args;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    _v = a as *mut node_args;
    if (*_v).len == (*_v).max {
        (*_v).max = (*_v).len + 10 as libc::c_int;
        tmp = realloc(
            (*_v).data as *mut libc::c_void,
            (::std::mem::size_of::<node_string_0>() as libc::c_ulong)
                .wrapping_mul((*_v).max as libc::c_ulong),
        );
        (*_v).data = tmp as *mut node_string_0;
    }
    memmove(
        ((*_v).data).offset(1 as libc::c_int as isize) as *mut libc::c_void,
        (*_v).data as *const libc::c_void,
        ((*_v).len as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<node_string_0>() as libc::c_ulong),
    );
    let ref mut fresh10 = *((*_v).data).offset(0 as libc::c_int as isize);
    *fresh10 = data;
    (*_v).len += 1;
}
pub unsafe extern "C" fn node_args_free(mut a: *mut node) {
    let mut i: strm_int = 0;
    let mut v: *mut node_args = 0 as *mut node_args;
    v = a as *mut node_args;
    if !((*a).type_0 as libc::c_uint == 6 as libc::c_uint) {
        __assert_fail(
            b"a->type == NODE_ARGS\0" as *const u8 as *const libc::c_char,
            b"node.c\0" as *const u8 as *const libc::c_char,
            191 as libc::c_uint,
            b"node_args_free\0" as *const u8 as *const libc::c_char,
        );
    }
    i = 0 as libc::c_int;
    while i < (*v).len {
        free(*((*v).data).offset(i as isize) as *mut libc::c_void);
        i += 1;
    }
    free((*v).data as *mut libc::c_void);
    free(v as *mut libc::c_void);
}
pub unsafe extern "C" fn node_pattern_new(mut type_0: node_type) -> *mut node {
    let mut v: *mut node_nodes = 0 as *mut node_nodes;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_nodes>() as libc::c_ulong);
    v = tmp as *mut node_nodes;
    (*v).type_0 = type_0;
    (*v).len = 0 as libc::c_int;
    (*v).max = 0 as libc::c_int;
    (*v).data = 0 as *mut libc::c_void as *mut *mut node;
    return v as *mut node;
}
pub unsafe extern "C" fn node_pattern_add(mut v: *mut node, mut data: *mut node) {
    let mut _v: *mut node_nodes = 0 as *mut node_nodes;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    _v = v as *mut node_nodes;
    if (*_v).len == (*_v).max {
        (*_v).max = (*_v).len + 10 as libc::c_int;
        tmp = realloc(
            (*_v).data as *mut libc::c_void,
            (::std::mem::size_of::<*mut node>() as libc::c_ulong)
                .wrapping_mul((*_v).max as libc::c_ulong),
        );
        (*_v).data = tmp as *mut *mut node;
    }
    let ref mut fresh11 = *((*_v).data).offset((*_v).len as isize);
    *fresh11 = data;
    (*_v).len += 1;
}
pub unsafe extern "C" fn node_psplat_new(
    mut head: *mut node,
    mut mid: *mut node,
    mut tail: *mut node,
) -> *mut node {
    let mut cons: *mut node_psplat = 0 as *mut node_psplat;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_psplat>() as libc::c_ulong);
    cons = tmp as *mut node_psplat;
    (*cons).type_0 = NODE_PSPLAT;
    (*cons).head = head;
    (*cons).mid = mid;
    (*cons).tail = tail;
    return cons as *mut node;
}
pub unsafe extern "C" fn node_plambda_new(
    mut pat: *mut node,
    mut cond: *mut node,
) -> *mut node {
    let mut lambda: *mut node_plambda = 0 as *mut node_plambda;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_plambda>() as libc::c_ulong);
    lambda = tmp as *mut node_plambda;
    (*lambda).type_0 = NODE_PLAMBDA;
    (*lambda).pat = pat;
    (*lambda).cond = cond;
    (*lambda).body = 0 as *mut libc::c_void as *mut node;
    return lambda as *mut node;
}
pub unsafe extern "C" fn node_plambda_body(
    mut n: *mut node,
    mut body: *mut node,
) -> *mut node {
    let mut lambda: *mut node_plambda = 0 as *mut node_plambda;
    lambda = n as *mut node_plambda;
    (*lambda).body = body;
    return lambda as *mut node;
}
pub unsafe extern "C" fn node_plambda_add(
    mut n: *mut node,
    mut lambda: *mut node,
) -> *mut node {
    let mut l: *mut node_plambda = 0 as *mut node_plambda;
    l = n as *mut node_plambda;
    while !((*l).next).is_null() {
        l = (*l).next as *mut node_plambda;
    }
    (*l).next = lambda;
    return n;
}
pub unsafe extern "C" fn node_splat_new(mut n: *mut node) -> *mut node {
    let mut splat: *mut node_splat = 0 as *mut node_splat;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_splat>() as libc::c_ulong);
    splat = tmp as *mut node_splat;
    (*splat).type_0 = NODE_SPLAT;
    (*splat).node = n;
    return splat as *mut node;
}
pub unsafe extern "C" fn node_ns_new(
    mut name: node_string_0,
    mut body: *mut node,
) -> *mut node {
    let mut newns: *mut node_ns = 0 as *mut node_ns;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_ns>() as libc::c_ulong);
    newns = tmp as *mut node_ns;
    (*newns).type_0 = NODE_NS;
    (*newns).name = name;
    (*newns).body = body;
    return newns as *mut node;
}
pub unsafe extern "C" fn node_import_new(mut name: node_string_0) -> *mut node {
    let mut nimp: *mut node_import = 0 as *mut node_import;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_import>() as libc::c_ulong);
    nimp = tmp as *mut node_import;
    (*nimp).type_0 = NODE_IMPORT;
    (*nimp).name = name;
    return nimp as *mut node;
}
pub unsafe extern "C" fn node_let_new(
    mut lhs: node_string_0,
    mut rhs: *mut node,
) -> *mut node {
    let mut nlet: *mut node_let = 0 as *mut node_let;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_let>() as libc::c_ulong);
    nlet = tmp as *mut node_let;
    (*nlet).type_0 = NODE_LET;
    (*nlet).lhs = lhs;
    (*nlet).rhs = rhs;
    return nlet as *mut node;
}
pub unsafe extern "C" fn node_op_new(
    mut op: *const libc::c_char,
    mut lhs: *mut node,
    mut rhs: *mut node,
) -> *mut node {
    let mut nop: *mut node_op = 0 as *mut node_op;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: size_t = 0;
    tmp = malloc(::std::mem::size_of::<node_op>() as libc::c_ulong);
    nop = tmp as *mut node_op;
    (*nop).type_0 = NODE_OP;
    (*nop).lhs = lhs;
    tmp___0 = strlen(op);
    (*nop).op = node_str_new(op, tmp___0 as strm_int);
    (*nop).rhs = rhs;
    return nop as *mut node;
}
pub unsafe extern "C" fn node_lambda_alloc(
    mut args: *mut node,
    mut compstmt: *mut node,
    mut block: libc::c_int,
) -> *mut node {
    let mut lambda: *mut node_lambda = 0 as *mut node_lambda;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_lambda>() as libc::c_ulong);
    lambda = tmp as *mut node_lambda;
    (*lambda).type_0 = NODE_LAMBDA;
    (*lambda).args = args;
    (*lambda).body = compstmt;
    (*lambda).block = block;
    if !compstmt.is_null() {
        (*lambda).fname = (*compstmt).fname;
    } else {
        (*lambda).fname = 0 as *mut libc::c_void as *const libc::c_char;
    }
    if !compstmt.is_null() {
        (*lambda).lineno = (*compstmt).lineno;
    } else {
        (*lambda).lineno = 0 as libc::c_int;
    }
    return lambda as *mut node;
}
pub unsafe extern "C" fn node_lambda_new(
    mut args: *mut node,
    mut compstmt: *mut node,
) -> *mut node {
    let mut tmp: *mut node = 0 as *mut node;
    tmp = node_lambda_alloc(args, compstmt, 0 as libc::c_int);
    return tmp;
}
pub unsafe extern "C" fn node_block_new(mut compstmt: *mut node) -> *mut node {
    let mut tmp: *mut node = 0 as *mut node;
    tmp = node_lambda_alloc(
        0 as *mut libc::c_void as *mut node,
        compstmt,
        1 as libc::c_int,
    );
    return tmp;
}
pub unsafe extern "C" fn node_method_new(
    mut args: *mut node,
    mut compstmt: *mut node,
) -> *mut node {
    let mut lambda: *mut node_lambda = 0 as *mut node_lambda;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: node_string_0 = 0 as *mut node_string;
    let mut tmp___1: node_string_0 = 0 as *mut node_string;
    tmp = malloc(::std::mem::size_of::<node_lambda>() as libc::c_ulong);
    lambda = tmp as *mut node_lambda;
    (*lambda).type_0 = NODE_LAMBDA;
    if !args.is_null() {
        tmp___0 = node_str_new(
            b"self\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int,
        );
        node_args_prepend(args, tmp___0);
    } else {
        args = node_args_new();
        tmp___1 = node_str_new(
            b"self\0" as *const u8 as *const libc::c_char,
            4 as libc::c_int,
        );
        node_args_add(args, tmp___1);
    }
    (*lambda).args = args;
    (*lambda).body = compstmt;
    return lambda as *mut node;
}
pub unsafe extern "C" fn node_call_new(
    mut ident: node_string_0,
    mut recv: *mut node,
    mut args: *mut node,
    mut blk: *mut node,
) -> *mut node {
    let mut ncall: *mut node_call = 0 as *mut node_call;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_call>() as libc::c_ulong);
    ncall = tmp as *mut node_call;
    (*ncall).type_0 = NODE_CALL;
    (*ncall).ident = ident;
    if args.is_null() {
        args = node_array_new();
    }
    if !recv.is_null() {
        node_nodes_prepend(args, recv);
    }
    if !blk.is_null() {
        node_nodes_add(args, blk);
    }
    (*ncall).args = args;
    return ncall as *mut node;
}
pub unsafe extern "C" fn node_fcall_new(
    mut func: *mut node,
    mut args: *mut node,
    mut blk: *mut node,
) -> *mut node {
    let mut ncall: *mut node_fcall = 0 as *mut node_fcall;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_fcall>() as libc::c_ulong);
    ncall = tmp as *mut node_fcall;
    (*ncall).type_0 = NODE_FCALL;
    (*ncall).func = func;
    if args.is_null() {
        args = node_array_new();
    }
    if !blk.is_null() {
        node_nodes_add(args, blk);
    }
    (*ncall).args = args;
    return ncall as *mut node;
}
pub unsafe extern "C" fn node_genfunc_new(mut id: node_string_0) -> *mut node {
    let mut ngf: *mut node_genfunc = 0 as *mut node_genfunc;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_genfunc>() as libc::c_ulong);
    ngf = tmp as *mut node_genfunc;
    (*ngf).type_0 = NODE_GENFUNC;
    (*ngf).id = id;
    return ngf as *mut node;
}
pub unsafe extern "C" fn node_int_new(mut i: libc::c_long) -> *mut node {
    let mut ni: *mut node_int = 0 as *mut node_int;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_int>() as libc::c_ulong);
    ni = tmp as *mut node_int;
    (*ni).type_0 = NODE_INT;
    (*ni).value = i as int32_t;
    return ni as *mut node;
}
pub unsafe extern "C" fn node_float_new(mut d: libc::c_double) -> *mut node {
    let mut nf: *mut node_float = 0 as *mut node_float;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_float>() as libc::c_ulong);
    nf = tmp as *mut node_float;
    (*nf).type_0 = NODE_FLOAT;
    (*nf).value = d;
    return nf as *mut node;
}
pub unsafe extern "C" fn node_time_new(
    mut s: *const libc::c_char,
    mut len: strm_int,
) -> *mut node {
    let mut sec: libc::c_long = 0;
    let mut usec: libc::c_long = 0;
    let mut utc_offset: libc::c_int = 0;
    let mut ns: *mut node_time = 0 as *mut node_time;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strm_time_parse_time(s, len, &mut sec, &mut usec, &mut utc_offset);
    if tmp < 0 as libc::c_int {
        return 0 as *mut libc::c_void as *mut node;
    }
    tmp___0 = malloc(::std::mem::size_of::<node_time>() as libc::c_ulong);
    ns = tmp___0 as *mut node_time;
    (*ns).type_0 = NODE_TIME;
    (*ns).sec = sec;
    (*ns).usec = usec;
    (*ns).utc_offset = utc_offset;
    return ns as *mut node;
}
unsafe extern "C" fn string_escape(
    mut s: *mut libc::c_char,
    mut len: strm_int,
) -> strm_int {
    let mut t: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___3: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut c: libc::c_uchar = 0;
    let mut xend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___4: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___5: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___6: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___7: *mut libc::c_char = 0 as *mut libc::c_char;
    t = s;
    tend = t.offset(len as isize);
    p = s;
    while (t as libc::c_ulong) < tend as libc::c_ulong {
        match *t as libc::c_int {
            92 => {
                t = t.offset(1);
                if !(t as libc::c_ulong == tend as libc::c_ulong) {
                    match *t as libc::c_int {
                        110 => {
                            tmp = p;
                            p = p.offset(1);
                            *tmp = '\n' as i32 as libc::c_char;
                        }
                        114 => {
                            tmp___0 = p;
                            p = p.offset(1);
                            *tmp___0 = '\r' as i32 as libc::c_char;
                        }
                        116 => {
                            tmp___1 = p;
                            p = p.offset(1);
                            *tmp___1 = '\t' as i32 as libc::c_char;
                        }
                        101 => {
                            tmp___2 = p;
                            p = p.offset(1);
                            *tmp___2 = 27 as libc::c_int as libc::c_char;
                        }
                        48 => {
                            tmp___3 = p;
                            p = p.offset(1);
                            *tmp___3 = '\u{0}' as i32 as libc::c_char;
                        }
                        120 => {
                            c = 0 as libc::c_int as libc::c_uchar;
                            xend = t.offset(3 as libc::c_int as isize);
                            t = t.offset(1);
                            while (t as libc::c_ulong) < tend as libc::c_ulong {
                                if !((t as libc::c_ulong) < xend as libc::c_ulong) {
                                    break;
                                }
                                match *t as libc::c_int {
                                    57 | 56 | 55 | 54 | 53 | 52 | 51 | 50 | 49 | 48 => {
                                        c = (c as libc::c_int * 16 as libc::c_int) as libc::c_uchar;
                                        c = (c as libc::c_int
                                            + (*t as libc::c_int - 48 as libc::c_int)) as libc::c_uchar;
                                    }
                                    102 | 101 | 100 | 99 | 98 | 97 => {
                                        c = (c as libc::c_int * 16 as libc::c_int) as libc::c_uchar;
                                        c = (c as libc::c_int
                                            + (*t as libc::c_int - 97 as libc::c_int
                                                + 10 as libc::c_int)) as libc::c_uchar;
                                    }
                                    _ => {
                                        xend = t;
                                    }
                                }
                                t = t.offset(1);
                            }
                            tmp___4 = p;
                            p = p.offset(1);
                            *tmp___4 = c as libc::c_char;
                            t = t.offset(-1);
                        }
                        _ => {
                            tmp___5 = p;
                            p = p.offset(1);
                            *tmp___5 = *t;
                        }
                    }
                    t = t.offset(1);
                }
            }
            _ => {
                tmp___6 = p;
                p = p.offset(1);
                tmp___7 = t;
                t = t.offset(1);
                *tmp___6 = *tmp___7;
            }
        }
    }
    return p.offset_from(s) as libc::c_long as strm_int;
}
pub unsafe extern "C" fn node_string_new(
    mut s: *const libc::c_char,
    mut len: strm_int,
) -> *mut node {
    let mut ns: *mut node_str = 0 as *mut node_str;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_str>() as libc::c_ulong);
    ns = tmp as *mut node_str;
    (*ns).type_0 = NODE_STR;
    len = string_escape(s as *mut libc::c_char, len);
    (*ns).value = node_str_new(s, len);
    return ns as *mut node;
}
pub unsafe extern "C" fn node_ident_new(mut name: node_string_0) -> *mut node {
    let mut ni: *mut node_ident = 0 as *mut node_ident;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_ident>() as libc::c_ulong);
    ni = tmp as *mut node_ident;
    (*ni).type_0 = NODE_IDENT;
    (*ni).name = name;
    return ni as *mut node;
}
pub unsafe extern "C" fn node_str_new(
    mut s: *const libc::c_char,
    mut len: strm_int,
) -> node_string_0 {
    let mut str: node_string_0 = 0 as *mut node_string;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(
        (::std::mem::size_of::<node_string>() as libc::c_ulong)
            .wrapping_add(len as libc::c_ulong)
            .wrapping_add(1 as libc::c_ulong),
    );
    str = tmp as node_string_0;
    (*str).len = len;
    memcpy(
        ((*str).buf).as_mut_ptr() as *mut libc::c_void,
        s as *const libc::c_void,
        len as size_t,
    );
    *((*str).buf).as_mut_ptr().offset(len as isize) = '\u{0}' as i32 as libc::c_char;
    return str;
}
pub unsafe extern "C" fn node_str_escaped(
    mut s: *const libc::c_char,
    mut len: strm_int,
) -> node_string_0 {
    let mut tmp: node_string_0 = 0 as *mut node_string;
    len = string_escape(s as *mut libc::c_char, len);
    tmp = node_str_new(s, len);
    return tmp;
}
static mut nd: node = {
    let mut init = node {
        type_0: NODE_NIL,
        fname: 0 as *const libc::c_char,
        lineno: 0 as libc::c_int,
    };
    init
};
pub unsafe extern "C" fn node_nil() -> *mut node {
    return &mut nd;
}
static mut nd___0: node_bool = {
    let mut init = __anonstruct_node_bool_164879216 {
        type_0: NODE_BOOL,
        fname: 0 as *const libc::c_char,
        lineno: 0 as libc::c_int,
        value: 1 as libc::c_int,
    };
    init
};
pub unsafe extern "C" fn node_true() -> *mut node {
    return &mut nd___0 as *mut node_bool as *mut node;
}
static mut nd___1: node_bool = {
    let mut init = __anonstruct_node_bool_164879216 {
        type_0: NODE_BOOL,
        fname: 0 as *const libc::c_char,
        lineno: 0 as libc::c_int,
        value: 0 as libc::c_int,
    };
    init
};
pub unsafe extern "C" fn node_false() -> *mut node {
    return &mut nd___1 as *mut node_bool as *mut node;
}
unsafe extern "C" fn cond_body(mut body: *mut node) -> *mut node {
    let mut lambda: *mut node_lambda = 0 as *mut node_lambda;
    if body as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 0 as *mut libc::c_void as *mut node;
    }
    if (*body).type_0 as libc::c_uint == 9 as libc::c_uint {
        lambda = body as *mut node_lambda;
        if (*lambda).block != 0 {
            return (*lambda).body;
        }
    }
    return body;
}
pub unsafe extern "C" fn node_if_new(
    mut cond: *mut node,
    mut then: *mut node,
    mut opt_else: *mut node,
) -> *mut node {
    let mut nif: *mut node_if = 0 as *mut node_if;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_if>() as libc::c_ulong);
    nif = tmp as *mut node_if;
    (*nif).type_0 = NODE_IF;
    (*nif).cond = cond;
    (*nif).then = cond_body(then);
    (*nif).opt_else = cond_body(opt_else);
    return nif as *mut node;
}
pub unsafe extern "C" fn node_emit_new(mut value: *mut node) -> *mut node {
    let mut ne: *mut node_emit = 0 as *mut node_emit;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_emit>() as libc::c_ulong);
    ne = tmp as *mut node_emit;
    (*ne).type_0 = NODE_EMIT;
    (*ne).emit = value;
    return ne as *mut node;
}
static mut nd___2: node = {
    let mut init = node {
        type_0: NODE_SKIP,
        fname: 0 as *const libc::c_char,
        lineno: 0 as libc::c_int,
    };
    init
};
pub unsafe extern "C" fn node_skip_new() -> *mut node {
    return &mut nd___2;
}
pub unsafe extern "C" fn node_return_new(mut value: *mut node) -> *mut node {
    let mut nreturn: *mut node_return = 0 as *mut node_return;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<node_return>() as libc::c_ulong);
    nreturn = tmp as *mut node_return;
    (*nreturn).type_0 = NODE_RETURN;
    (*nreturn).rv = value;
    return nreturn as *mut node;
}
pub unsafe extern "C" fn node_parse_init(mut p: *mut parser_state) {
    (*p).nerr = 0 as libc::c_int;
    (*p).lval = 0 as *mut libc::c_void;
    (*p).fname = 0 as *mut libc::c_void as *const libc::c_char;
    (*p).lineno = 1 as libc::c_int;
    (*p).tline = 1 as libc::c_int;
}
pub unsafe extern "C" fn node_parse_file(
    mut p: *mut parser_state,
    mut fname: *const libc::c_char,
) -> libc::c_int {
    let mut r: libc::c_int = 0;
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut tmp: *mut FILE = 0 as *mut FILE;
    tmp = fopen(fname, b"rb\0" as *const u8 as *const libc::c_char);
    fp = tmp;
    if fp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        perror(b"fopen\0" as *const u8 as *const libc::c_char);
        return 0 as libc::c_int;
    }
    (*p).fname = fname;
    r = node_parse_input(p, fp, fname);
    fclose(fp);
    return r;
}
pub unsafe extern "C" fn node_parse_input(
    mut p: *mut parser_state,
    mut f: *mut FILE,
    mut fname: *const libc::c_char,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    yyrestart(f);
    n = yyparse(p);
    if n == 0 as libc::c_int {
        if (*p).nerr == 0 as libc::c_int {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
pub unsafe extern "C" fn node_parse_string(
    mut p: *mut parser_state,
    mut prog: *const libc::c_char,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    (*p).fname = b"-e\0" as *const u8 as *const libc::c_char;
    yy_scan_string(prog);
    n = yyparse(p);
    if n == 0 as libc::c_int {
        if (*p).nerr == 0 as libc::c_int {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
pub unsafe extern "C" fn node_free(mut np: *mut node) {
    if np.is_null() {
        return;
    }
    match (*np).type_0 as libc::c_uint {
        6 => {
            node_args_free(np);
        }
        17 => {
            node_free((*(np as *mut node_if)).cond);
            node_free((*(np as *mut node_if)).then);
            node_free((*(np as *mut node_if)).opt_else);
            free(np as *mut libc::c_void);
        }
        18 => {
            node_free((*(np as *mut node_emit)).emit);
            free(np as *mut libc::c_void);
        }
        23 => {
            node_free((*(np as *mut node_op)).lhs);
            node_free((*(np as *mut node_op)).rhs);
            free(np as *mut libc::c_void);
        }
        9 => {
            node_args_free((*(np as *mut node_lambda)).args);
            node_free((*(np as *mut node_lambda)).body);
            free(np as *mut libc::c_void);
        }
        24 => {
            node_free((*(np as *mut node_call)).args);
            free(np as *mut libc::c_void);
        }
        20 => {
            node_free(np);
            free(np as *mut libc::c_void);
        }
        15 => {
            free((*(np as *mut node_ident)).name as *mut libc::c_void);
            free(np as *mut libc::c_void);
        }
        27 => {
            node_array_free(np as *mut node_array);
        }
        1 | 0 => {
            free(np as *mut libc::c_void);
        }
        5 => return,
        3 => {
            free((*(np as *mut node_str)).value as *mut libc::c_void);
            free(np as *mut libc::c_void);
        }
        _ => {}
    };
}
pub unsafe extern "C" fn node_parse_free(mut p: *mut parser_state) {
    node_free((*p).lval as *mut node);
}
static mut khash_ac_HASH_UPPER___2: libc::c_double = 0.77f64;
#[inline]
unsafe extern "C" fn kh_init_ns() -> *mut kh_ns_t {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<kh_ns_t>() as libc::c_ulong,
    );
    return tmp as *mut kh_ns_t;
}
#[inline]
unsafe extern "C" fn kh_get_ns(mut h: *const kh_ns_t, mut key: khint64_t) -> khint_t {
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp: khint_t = 0;
    if (*h).n_buckets != 0 {
        step = 0 as libc::c_int as khint_t;
        mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
        k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
        i = k & mask;
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if i == last {
                return (*h).n_buckets;
            }
        }
        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint != 0
        {
            tmp = (*h).n_buckets;
        } else {
            tmp = i;
        }
        return tmp;
    } else {
        return 0 as libc::c_int as khint_t
    };
}
#[inline]
unsafe extern "C" fn kh_resize_ns(
    mut h: *mut kh_ns_t,
    mut new_n_buckets: khint_t,
) -> libc::c_int {
    let mut new_flags: *mut khint32_t = 0 as *mut khint32_t;
    let mut j: khint_t = 0;
    let mut tmp: khint_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: khint_t = 0;
    let mut new_keys: *mut khint64_t = 0 as *mut khint64_t;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut new_vals: *mut *mut strm_state = 0 as *mut *mut strm_state;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut key: khint64_t = 0;
    let mut val: *mut strm_state = 0 as *mut strm_state;
    let mut new_mask: khint_t = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp___4: khint64_t = 0;
    let mut tmp___5: *mut strm_state = 0 as *mut strm_state;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    new_flags = 0 as *mut khint32_t;
    j = 1 as libc::c_int as khint_t;
    new_n_buckets = new_n_buckets.wrapping_sub(1);
    new_n_buckets |= new_n_buckets >> 1 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 2 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 4 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 8 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 16 as libc::c_int;
    new_n_buckets = new_n_buckets.wrapping_add(1);
    if new_n_buckets < 4 as libc::c_uint {
        new_n_buckets = 4 as libc::c_int as khint_t;
    }
    if (*h).size
        >= (new_n_buckets as libc::c_double * khash_ac_HASH_UPPER___2 + 0.5f64)
            as khint_t
    {
        j = 0 as libc::c_int as khint_t;
    } else {
        if new_n_buckets < 16 as libc::c_uint {
            tmp = 1 as libc::c_int as khint_t;
        } else {
            tmp = new_n_buckets >> 4 as libc::c_int;
        }
        tmp___0 = malloc(
            (tmp as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        new_flags = tmp___0 as *mut khint32_t;
        if new_flags.is_null() {
            return -(1 as libc::c_int);
        }
        if new_n_buckets < 16 as libc::c_uint {
            tmp___1 = 1 as libc::c_int as khint_t;
        } else {
            tmp___1 = new_n_buckets >> 4 as libc::c_int;
        }
        memset(
            new_flags as *mut libc::c_void,
            170 as libc::c_int,
            (tmp___1 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        if (*h).n_buckets < new_n_buckets {
            tmp___2 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<khint64_t>() as libc::c_ulong),
            );
            new_keys = tmp___2 as *mut khint64_t;
            if new_keys.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).keys = new_keys;
            tmp___3 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<*mut strm_state>() as libc::c_ulong,
                    ),
            );
            new_vals = tmp___3 as *mut *mut strm_state;
            if new_vals.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).vals = new_vals;
        }
    }
    if j != 0 {
        j = 0 as libc::c_int as khint_t;
        while j != (*h).n_buckets {
            if *((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                >> ((j & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint
                == 0 as libc::c_uint
            {
                key = *((*h).keys).offset(j as isize);
                new_mask = new_n_buckets.wrapping_sub(1 as libc::c_uint);
                val = *((*h).vals).offset(j as isize);
                *((*h).flags)
                    .offset(
                        (j >> 4 as libc::c_int) as isize,
                    ) = (*((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                    as libc::c_ulong
                    | (1 as libc::c_ulong)
                        << ((j & 15 as libc::c_uint) << 1 as libc::c_int)) as khint32_t;
                loop {
                    step = 0 as libc::c_int as khint_t;
                    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int)
                        as khint32_t;
                    i = k & new_mask;
                    while *new_flags.offset((i >> 4 as libc::c_int) as isize)
                        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                        & 2 as libc::c_uint == 0
                    {
                        step = step.wrapping_add(1);
                        i = i.wrapping_add(step) & new_mask;
                    }
                    *new_flags
                        .offset(
                            (i >> 4 as libc::c_int) as isize,
                        ) = (*new_flags.offset((i >> 4 as libc::c_int) as isize)
                        as libc::c_ulong
                        & !((2 as libc::c_ulong)
                            << ((i & 15 as libc::c_uint) << 1 as libc::c_int)))
                        as khint32_t;
                    if i < (*h).n_buckets {
                        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                            & 3 as libc::c_uint == 0 as libc::c_uint
                        {
                            tmp___4 = *((*h).keys).offset(i as isize);
                            *((*h).keys).offset(i as isize) = key;
                            key = tmp___4;
                            tmp___5 = *((*h).vals).offset(i as isize);
                            let ref mut fresh12 = *((*h).vals).offset(i as isize);
                            *fresh12 = val;
                            val = tmp___5;
                            *((*h).flags)
                                .offset(
                                    (i >> 4 as libc::c_int) as isize,
                                ) = (*((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                                as libc::c_ulong
                                | (1 as libc::c_ulong)
                                    << ((i & 15 as libc::c_uint) << 1 as libc::c_int))
                                as khint32_t;
                        } else {
                            *((*h).keys).offset(i as isize) = key;
                            let ref mut fresh13 = *((*h).vals).offset(i as isize);
                            *fresh13 = val;
                            break;
                        }
                    } else {
                        *((*h).keys).offset(i as isize) = key;
                        let ref mut fresh14 = *((*h).vals).offset(i as isize);
                        *fresh14 = val;
                        break;
                    }
                }
            }
            j = j.wrapping_add(1);
        }
        if (*h).n_buckets > new_n_buckets {
            tmp___6 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<khint64_t>() as libc::c_ulong),
            );
            (*h).keys = tmp___6 as *mut khint64_t;
            tmp___7 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<*mut strm_state>() as libc::c_ulong,
                    ),
            );
            (*h).vals = tmp___7 as *mut *mut strm_state;
        }
        free((*h).flags as *mut libc::c_void);
        (*h).flags = new_flags;
        (*h).n_buckets = new_n_buckets;
        (*h).n_occupied = (*h).size;
        (*h)
            .upper_bound = ((*h).n_buckets as libc::c_double * khash_ac_HASH_UPPER___2
            + 0.5f64) as khint_t;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn kh_put_ns(
    mut h: *mut kh_ns_t,
    mut key: khint64_t,
    mut ret: *mut libc::c_int,
) -> khint_t {
    let mut x: khint_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut site: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    if (*h).n_occupied >= (*h).upper_bound {
        if (*h).n_buckets > (*h).size << 1 as libc::c_int {
            tmp = kh_resize_ns(h, ((*h).n_buckets).wrapping_sub(1 as libc::c_uint));
            if tmp < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        } else {
            tmp___0 = kh_resize_ns(h, ((*h).n_buckets).wrapping_add(1 as libc::c_uint));
            if tmp___0 < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        }
    }
    mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
    step = 0 as libc::c_int as khint_t;
    site = (*h).n_buckets;
    x = site;
    k = (key >> 33 as libc::c_int ^ key ^ key << 11 as libc::c_int) as khint32_t;
    i = k & mask;
    if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        x = i;
    } else {
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                if *((*h).keys).offset(i as isize) == key {
                    break;
                }
            }
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                != 0
            {
                site = i;
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if !(i == last) {
                continue;
            }
            x = site;
            break;
        }
        if x == (*h).n_buckets {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint
                != 0
            {
                if site != (*h).n_buckets {
                    x = site;
                } else {
                    x = i;
                }
            } else {
                x = i;
            }
        }
    }
    if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
        >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        (*h).n_occupied = ((*h).n_occupied).wrapping_add(1);
        *ret = 1 as libc::c_int;
    } else if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
            >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint != 0
        {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        *ret = 2 as libc::c_int;
    } else {
        *ret = 0 as libc::c_int;
    }
    return x;
}
static mut nstbl: *mut kh_ns_t = 0 as *const kh_ns_t as *mut kh_ns_t;
static mut szero: strm_state = {
    let mut init = strm_state {
        env: 0 as *const libc::c_void as *mut libc::c_void,
        prev: 0 as *const strm_state as *mut strm_state,
        flags: 0 as libc::c_uint,
    };
    init
};
pub unsafe extern "C" fn strm_ns_name(mut state: *mut strm_state) -> strm_string {
    let mut k: khiter_t = 0;
    if nstbl.is_null() {
        return 0 as libc::c_int as strm_string;
    }
    k = 0 as libc::c_int as khint_t;
    while k != (*nstbl).n_buckets {
        if *((*nstbl).flags).offset((k >> 4 as libc::c_int) as isize)
            >> ((k & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint == 0
        {
            if *((*nstbl).vals).offset(k as isize) as libc::c_ulong
                == state as libc::c_ulong
            {
                return *((*nstbl).keys).offset(k as isize);
            }
        }
        k = k.wrapping_add(1);
    }
    return 0 as libc::c_int as strm_string;
}
pub unsafe extern "C" fn strm_ns_get(mut name: strm_string) -> *mut strm_state {
    let mut k: khiter_t = 0;
    if nstbl.is_null() {
        return 0 as *mut libc::c_void as *mut strm_state;
    }
    k = kh_get_ns(nstbl as *const kh_ns_t, name as intptr_t as khint64_t);
    if k == (*nstbl).n_buckets {
        return 0 as *mut libc::c_void as *mut strm_state;
    }
    return *((*nstbl).vals).offset(k as isize);
}
pub unsafe extern "C" fn strm_ns_create(
    mut state: *mut strm_state,
    mut name: strm_string,
) -> *mut strm_state {
    let mut s: *mut strm_state = 0 as *mut strm_state;
    let mut tmp: *mut strm_state = 0 as *mut strm_state;
    let mut r: libc::c_int = 0;
    let mut k: khiter_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strm_ns_get(name);
    s = tmp;
    if s.is_null() {
        if nstbl.is_null() {
            nstbl = kh_init_ns();
        }
        k = kh_put_ns(nstbl, name as intptr_t as khint64_t, &mut r);
        if r < 0 as libc::c_int {
            return 0 as *mut libc::c_void as *mut strm_state;
        }
        if r == 0 as libc::c_int {
            if !(*((*nstbl).vals).offset(k as isize)).is_null() {
                return 0 as *mut libc::c_void as *mut strm_state;
            }
        }
        tmp___0 = malloc(::std::mem::size_of::<strm_state>() as libc::c_ulong);
        s = tmp___0 as *mut strm_state;
        if !s.is_null() {
            *s = szero;
            (*s).prev = state;
        }
        let ref mut fresh15 = *((*nstbl).vals).offset(k as isize);
        *fresh15 = s;
    }
    return s;
}
pub unsafe extern "C" fn strm_ns_new(
    mut state: *mut strm_state,
    mut name: *const libc::c_char,
) -> *mut strm_state {
    let mut s: strm_string = 0;
    let mut tmp: size_t = 0;
    let mut tmp___0: strm_string = 0;
    let mut tmp___1: *mut strm_state = 0 as *mut strm_state;
    tmp = strlen(name);
    tmp___0 = strm_str_new(name, tmp as strm_int);
    s = tmp___0;
    tmp___1 = strm_ns_create(state, s);
    return tmp___1;
}
unsafe extern "C" fn math_sqrt(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = sqrt(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_sin(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = sin(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_sinh(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = sinh(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_cos(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = cos(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_cosh(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = cosh(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_tan(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = tan(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_tanh(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = tanh(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_pow(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = pow(x, y);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn GCD(mut a: libc::c_int, mut b: libc::c_int) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    if b != 0 {
        tmp = GCD(b, a % b);
        tmp___0 = tmp;
    } else {
        tmp___0 = a;
    }
    return tmp___0;
}
unsafe extern "C" fn math_gcd(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_int = 0;
    let mut y: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ii\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_int,
        &mut y as *mut libc::c_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = GCD(x, y);
    *ret = strm_float_value(tmp___0 as libc::c_double);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_fabs(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = abs(f as libc::c_int);
    *ret = strm_float_value(tmp___0 as libc::c_double);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_acosh(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = acosh(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_asinh(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = asinh(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_atanh(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = atanh(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_acos(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = acos(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_asin(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = asin(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_atan(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = atan(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_log(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = log(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_log10(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = log10(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_exp(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = exp(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_log2(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = log2(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_erfc(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = erfc(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_cbrt(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f\0" as *const u8 as *const libc::c_char,
        &mut f as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = cbrt(f);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_hypot(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = hypot(x, y);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_frexp(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = frexp(x, &mut y);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_ldexp(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = ldexp(x, y);
    *ret = strm_float_value(tmp___0);
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_round(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut d: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut f: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    d = 0 as libc::c_int;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f|i\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut d as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if argc == 1 as libc::c_int {
        tmp___0 = round(x);
        *ret = strm_float_value(tmp___0);
    } else {
        tmp___1 = pow(10 as libc::c_int as libc::c_double, d as libc::c_double);
        f = tmp___1;
        tmp___2 = round(x * f);
        *ret = strm_float_value(tmp___2 / f);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_ceil(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut d: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut f: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    d = 0 as libc::c_int;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f|i\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut d as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if argc == 1 as libc::c_int {
        tmp___0 = ceil(x);
        *ret = strm_float_value(tmp___0);
    } else {
        tmp___1 = pow(10 as libc::c_int as libc::c_double, d as libc::c_double);
        f = tmp___1;
        tmp___2 = ceil(x * f);
        *ret = strm_float_value(tmp___2 / f);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_floor(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut d: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut f: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    d = 0 as libc::c_int;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f|i\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut d as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if argc == 1 as libc::c_int {
        tmp___0 = floor(x);
        *ret = strm_float_value(tmp___0);
    } else {
        tmp___1 = pow(10 as libc::c_int as libc::c_double, d as libc::c_double);
        f = tmp___1;
        tmp___2 = floor(x * f);
        *ret = strm_float_value(tmp___2 / f);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn math_trunc(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut d: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_double = 0.;
    let mut f: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_double = 0.;
    d = 0 as libc::c_int;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"f|i\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut d as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if argc == 1 as libc::c_int {
        tmp___0 = trunc(x);
        *ret = strm_float_value(tmp___0);
    } else {
        tmp___1 = pow(10 as libc::c_int as libc::c_double, d as libc::c_double);
        f = tmp___1;
        tmp___2 = trunc(x * f);
        *ret = strm_float_value(tmp___2 / f);
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_math_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: strm_value = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: strm_value = 0;
    let mut tmp___7: strm_value = 0;
    let mut tmp___8: strm_value = 0;
    let mut tmp___9: strm_value = 0;
    let mut tmp___10: strm_value = 0;
    let mut tmp___11: strm_value = 0;
    let mut tmp___12: strm_value = 0;
    let mut tmp___13: strm_value = 0;
    let mut tmp___14: strm_value = 0;
    let mut tmp___15: strm_value = 0;
    let mut tmp___16: strm_value = 0;
    let mut tmp___17: strm_value = 0;
    let mut tmp___18: strm_value = 0;
    let mut tmp___19: strm_value = 0;
    let mut tmp___20: strm_value = 0;
    let mut tmp___21: strm_value = 0;
    let mut tmp___22: strm_value = 0;
    let mut tmp___23: strm_value = 0;
    let mut tmp___24: strm_value = 0;
    let mut tmp___25: strm_value = 0;
    let mut tmp___26: strm_value = 0;
    let mut tmp___27: strm_value = 0;
    let mut tmp___28: strm_value = 0;
    let mut tmp___29: strm_value = 0;
    let mut tmp___30: strm_value = 0;
    tmp = strm_float_value(3.14159265358979323846f64);
    strm_var_def(state, b"PI\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_float_value(2.7182818284590452354f64);
    strm_var_def(state, b"E\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_cfunc_value(
        Some(
            math_sqrt
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"sqrt\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            math_sin
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"sin\0" as *const u8 as *const libc::c_char, tmp___2);
    tmp___3 = strm_cfunc_value(
        Some(
            math_cos
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"cos\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = strm_cfunc_value(
        Some(
            math_tan
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"tan\0" as *const u8 as *const libc::c_char, tmp___4);
    tmp___5 = strm_cfunc_value(
        Some(
            math_sinh
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"sinh\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = strm_cfunc_value(
        Some(
            math_cosh
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"cosh\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = strm_cfunc_value(
        Some(
            math_asin
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"asin\0" as *const u8 as *const libc::c_char, tmp___7);
    tmp___8 = strm_cfunc_value(
        Some(
            math_acos
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"acos\0" as *const u8 as *const libc::c_char, tmp___8);
    tmp___9 = strm_cfunc_value(
        Some(
            math_atan
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"atan\0" as *const u8 as *const libc::c_char, tmp___9);
    tmp___10 = strm_cfunc_value(
        Some(
            math_asinh
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"asinh\0" as *const u8 as *const libc::c_char, tmp___10);
    tmp___11 = strm_cfunc_value(
        Some(
            math_acosh
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"acosh\0" as *const u8 as *const libc::c_char, tmp___11);
    tmp___12 = strm_cfunc_value(
        Some(
            math_atanh
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"atanh\0" as *const u8 as *const libc::c_char, tmp___12);
    tmp___13 = strm_cfunc_value(
        Some(
            math_tanh
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"tanh\0" as *const u8 as *const libc::c_char, tmp___13);
    tmp___14 = strm_cfunc_value(
        Some(
            math_pow
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"pow\0" as *const u8 as *const libc::c_char, tmp___14);
    tmp___15 = strm_cfunc_value(
        Some(
            math_round
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"round\0" as *const u8 as *const libc::c_char, tmp___15);
    tmp___16 = strm_cfunc_value(
        Some(
            math_ceil
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"ceil\0" as *const u8 as *const libc::c_char, tmp___16);
    tmp___17 = strm_cfunc_value(
        Some(
            math_floor
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"floor\0" as *const u8 as *const libc::c_char, tmp___17);
    tmp___18 = strm_cfunc_value(
        Some(
            math_trunc
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"trunc\0" as *const u8 as *const libc::c_char, tmp___18);
    tmp___19 = strm_cfunc_value(
        Some(
            math_trunc
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"int\0" as *const u8 as *const libc::c_char, tmp___19);
    tmp___20 = strm_cfunc_value(
        Some(
            math_fabs
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"fabs\0" as *const u8 as *const libc::c_char, tmp___20);
    tmp___21 = strm_cfunc_value(
        Some(
            math_log
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"log\0" as *const u8 as *const libc::c_char, tmp___21);
    tmp___22 = strm_cfunc_value(
        Some(
            math_log10
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"log10\0" as *const u8 as *const libc::c_char, tmp___22);
    tmp___23 = strm_cfunc_value(
        Some(
            math_log2
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"log2\0" as *const u8 as *const libc::c_char, tmp___23);
    tmp___24 = strm_cfunc_value(
        Some(
            math_exp
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"exp\0" as *const u8 as *const libc::c_char, tmp___24);
    tmp___25 = strm_cfunc_value(
        Some(
            math_erfc
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"erfc\0" as *const u8 as *const libc::c_char, tmp___25);
    tmp___26 = strm_cfunc_value(
        Some(
            math_cbrt
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"cbrt\0" as *const u8 as *const libc::c_char, tmp___26);
    tmp___27 = strm_cfunc_value(
        Some(
            math_hypot
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"hypot\0" as *const u8 as *const libc::c_char, tmp___27);
    tmp___28 = strm_cfunc_value(
        Some(
            math_frexp
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"frexp\0" as *const u8 as *const libc::c_char, tmp___28);
    tmp___29 = strm_cfunc_value(
        Some(
            math_ldexp
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"ldexp\0" as *const u8 as *const libc::c_char, tmp___29);
    tmp___30 = strm_cfunc_value(
        Some(
            math_gcd
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"gcd\0" as *const u8 as *const libc::c_char, tmp___30);
}
static mut refcnt: libc::c_int = 0 as libc::c_int;
static mut winch: libc::c_int = 0 as libc::c_int;
static mut interrupt: libc::c_int = 0 as libc::c_int;
unsafe extern "C" fn sigupdate(mut sig: libc::c_int, mut arg: *mut libc::c_void) {
    let mut var: *mut libc::c_int = 0 as *mut libc::c_int;
    var = arg as *mut libc::c_int;
    *var = 1 as libc::c_int;
}
unsafe extern "C" fn get_winsize(
    mut row: *mut libc::c_int,
    mut col: *mut libc::c_int,
) -> libc::c_int {
    let mut w: winsize = winsize {
        ws_row: 0,
        ws_col: 0,
        ws_xpixel: 0,
        ws_ypixel: 0,
    };
    let mut n: libc::c_int = 0;
    n = ioctl(1 as libc::c_int, 21523 as libc::c_ulong, &mut w as *mut winsize);
    if n < 0 as libc::c_int {
        return 1 as libc::c_int
    } else {
        if w.ws_col as libc::c_int == 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    }
    *row = w.ws_row as libc::c_int;
    *col = w.ws_col as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn move_cursor(mut row: libc::c_int, mut col: libc::c_int) {
    printf(b"\x1B[%d;%dH\0" as *const u8 as *const libc::c_char, row, col);
}
unsafe extern "C" fn clear() {
    printf(b"\x1B[2J\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn erase_cursor() {
    printf(b"\x1B[?25l\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn show_cursor() {
    printf(b"\x1B[?25h\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn show_title(mut d: *mut bar_data) {
    let mut start: libc::c_int = 0;
    erase_cursor();
    clear();
    if (*d).tlen == 0 as libc::c_int {
        return;
    }
    start = ((*d).col - (*d).tlen) / 2 as libc::c_int;
    move_cursor(1 as libc::c_int, start);
    fwrite(
        (*d).title as *const libc::c_void,
        (*d).tlen as size_t,
        1 as libc::c_int as size_t,
        stdout,
    );
}
unsafe extern "C" fn show_yaxis(mut d: *mut bar_data) {
    let mut i: libc::c_int = 0;
    move_cursor(1 as libc::c_int, 2 as libc::c_int);
    printf(b"\x1B[0m\0" as *const u8 as *const libc::c_char);
    i = 0 as libc::c_int;
    while i < (*d).llen {
        move_cursor(i + 2 as libc::c_int, (*d).dlen + 1 as libc::c_int);
        if i == 0 as libc::c_int {
            printf(
                b"\xE2\x94\x9C %d   \0" as *const u8 as *const libc::c_char,
                (*d).max,
            );
        } else if i == (*d).llen - 1 as libc::c_int {
            printf(b"\xE2\x94\x9C 0\0" as *const u8 as *const libc::c_char);
        } else {
            printf(b"|\0" as *const u8 as *const libc::c_char);
        }
        i += 1;
    }
}
unsafe extern "C" fn show_bar(
    mut d: *mut bar_data,
    mut i: libc::c_int,
    mut n: libc::c_int,
) {
    let mut f: libc::c_double = 0.;
    let mut line: libc::c_int = 0;
    f = *((*d).data).offset(i as isize) / (*d).max as libc::c_double
        * (*d).llen as libc::c_double;
    line = 0 as libc::c_int;
    while line < (*d).llen {
        move_cursor((*d).llen + 1 as libc::c_int - line, n);
        if (line as libc::c_double) < f {
            printf(b"\x1B[7m \0" as *const u8 as *const libc::c_char);
        } else if line == 0 as libc::c_int {
            printf(b"\x1B[0m_\0" as *const u8 as *const libc::c_char);
        } else {
            printf(b"\x1B[0m \0" as *const u8 as *const libc::c_char);
        }
        line += 1;
    }
}
unsafe extern "C" fn show_graph(mut d: *mut bar_data) {
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut i___0: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    n = 1 as libc::c_int;
    show_yaxis(d);
    i = (*d).offset;
    while i < (*d).dlen {
        tmp = n;
        n += 1;
        show_bar(d, i, tmp);
        i += 1;
    }
    i___0 = 0 as libc::c_int;
    while i___0 < (*d).offset {
        tmp___0 = n;
        n += 1;
        show_bar(d, i___0, tmp___0);
        i___0 += 1;
    }
}
unsafe extern "C" fn init_bar(mut d: *mut bar_data) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: libc::c_int = 0;
    tmp = get_winsize(&mut (*d).row, &mut (*d).col);
    if tmp != 0 {
        return 1 as libc::c_int;
    }
    (*d).max = 1 as libc::c_int;
    (*d).offset = 0 as libc::c_int;
    (*d).dlen = (*d).col - 6 as libc::c_int;
    (*d).llen = (*d).row - 3 as libc::c_int;
    tmp___0 = malloc(
        ((*d).dlen as libc::c_ulong)
            .wrapping_mul(::std::mem::size_of::<libc::c_double>() as libc::c_ulong),
    );
    (*d).data = tmp___0 as *mut libc::c_double;
    i = 0 as libc::c_int;
    while i < (*d).dlen {
        *((*d).data).offset(i as isize) = 0 as libc::c_int as libc::c_double;
        i += 1;
    }
    show_title(d);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_bar(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut bar_data = 0 as *mut bar_data;
    let mut f: libc::c_double = 0.;
    let mut max: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: strm_int = 0;
    let mut i: libc::c_int = 0;
    d = (*strm).data as *mut bar_data;
    max = 1.0f64;
    if interrupt != 0 {
        interrupt = 0 as libc::c_int;
        strm_unsignal(
            2 as libc::c_int,
            Some(sigupdate as unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> ()),
        );
        move_cursor((*d).row - 1 as libc::c_int, 1 as libc::c_int);
        show_cursor();
        exit(1 as libc::c_int);
    }
    tmp = strm_number_p(data);
    if tmp == 0 {
        strm_raise(strm, b"invalid data\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    if winch != 0 {
        winch = 0 as libc::c_int;
        free((*d).data as *mut libc::c_void);
        tmp___0 = init_bar(d);
        if tmp___0 == 1 as libc::c_int {
            strm_stream_close(strm);
            return 1 as libc::c_int;
        }
    }
    f = strm_value_float(data);
    if f < 0 as libc::c_int as libc::c_double {
        f = 0 as libc::c_int as libc::c_double;
    }
    tmp___1 = (*d).offset;
    (*d).offset += 1;
    *((*d).data).offset(tmp___1 as isize) = f;
    max = 1.0f64;
    i = 0 as libc::c_int;
    while i < (*d).dlen {
        f = *((*d).data).offset(i as isize);
        if f > max {
            max = f;
        }
        i += 1;
    }
    (*d).max = max as strm_int;
    if (*d).offset == (*d).dlen {
        (*d).offset = 0 as libc::c_int;
    }
    show_graph(d);
    return 0 as libc::c_int;
}
unsafe extern "C" fn fin_bar(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut bar_data = 0 as *mut bar_data;
    d = (*strm).data as *mut bar_data;
    move_cursor((*d).row, 1 as libc::c_int);
    if !((*d).title).is_null() {
        free((*d).title as *mut libc::c_void);
    }
    free((*d).data as *mut libc::c_void);
    free(d as *mut libc::c_void);
    show_cursor();
    ::std::intrinsics::atomic_xadd_seqcst(&mut refcnt, 1 as libc::c_int);
    if refcnt <= 0 as libc::c_int {
        strm_unsignal(
            28 as libc::c_int,
            Some(sigupdate as unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> ()),
        );
        strm_unsignal(
            2 as libc::c_int,
            Some(sigupdate as unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> ()),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_bgraph(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut bar_data = 0 as *mut bar_data;
    let mut title: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tlen: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut strm_stream = 0 as *mut strm_stream;
    title = 0 as *mut libc::c_void as *mut libc::c_char;
    tlen = 0 as libc::c_int;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"|s\0" as *const u8 as *const libc::c_char,
        &mut title as *mut *mut libc::c_char,
        &mut tlen as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<bar_data>() as libc::c_ulong);
    d = tmp___0 as *mut bar_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    tmp___1 = malloc(tlen as size_t);
    (*d).title = tmp___1 as *const libc::c_char;
    memcpy(
        (*d).title as *mut libc::c_void,
        title as *const libc::c_void,
        tlen as size_t,
    );
    (*d).tlen = tlen;
    if refcnt == 0 as libc::c_int {
        ::std::intrinsics::atomic_xadd_seqcst(&mut refcnt, 1 as libc::c_int);
        strm_signal(
            28 as libc::c_int,
            Some(
                sigupdate as unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> (),
            ),
            &mut winch as *mut libc::c_int as *mut libc::c_void,
        );
        strm_signal(
            2 as libc::c_int,
            Some(
                sigupdate as unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> (),
            ),
            &mut interrupt as *mut libc::c_int as *mut libc::c_void,
        );
    }
    tmp___2 = init_bar(d);
    if tmp___2 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___3 = strm_stream_new(
        strm_consumer,
        Some(
            iter_bar as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            fin_bar as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___3 as *mut libc::c_void);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_graph_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            exec_bgraph
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"graph_bar\0" as *const u8 as *const libc::c_char, tmp);
}
unsafe extern "C" fn num_cmp(mut x: strm_value, mut y: strm_value) -> libc::c_int {
    let mut a: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    let mut b: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    tmp = strm_value_float(x);
    a = tmp;
    tmp___0 = strm_value_float(y);
    b = tmp___0;
    if a > b {
        return 1 as libc::c_int
    } else {
        if a < b {
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_cmp(mut x: strm_value, mut y: strm_value) -> libc::c_int {
    let mut a: strm_string = 0;
    let mut b: strm_string = 0;
    let mut alen: strm_int = 0;
    let mut tmp: strm_int = 0;
    let mut blen: strm_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut len: strm_int = 0;
    let mut cmp: strm_int = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    a = x;
    b = y;
    tmp = strm_str_len(a);
    alen = tmp;
    tmp___0 = strm_str_len(b);
    blen = tmp___0;
    if alen > blen {
        len = blen;
    } else {
        len = alen;
    }
    tmp___1 = strm_strp_ptr(&mut b);
    tmp___2 = strm_strp_ptr(&mut a);
    cmp = memcmp(
        tmp___2 as *const libc::c_void,
        tmp___1 as *const libc::c_void,
        len as size_t,
    );
    if cmp == 0 as libc::c_int {
        if alen > len {
            return 1 as libc::c_int;
        }
        if blen > len {
            return -(1 as libc::c_int);
        }
    }
    return cmp;
}
unsafe extern "C" fn strm_cmp(mut a: strm_value, mut b: strm_value) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    tmp___1 = strm_number_p(a);
    if tmp___1 != 0 {
        tmp___0 = strm_number_p(b);
        if tmp___0 != 0 {
            tmp = num_cmp(a, b);
            return tmp;
        }
        return -(1 as libc::c_int);
    }
    tmp___5 = strm_string_p(a);
    if tmp___5 != 0 {
        tmp___3 = strm_string_p(b);
        if tmp___3 != 0 {
            tmp___2 = str_cmp(a, b);
            return tmp___2;
        }
        tmp___4 = strm_number_p(b);
        if tmp___4 != 0 {
            return 1 as libc::c_int;
        }
        return 1 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn sort_cmp(
    mut a_p: *const libc::c_void,
    mut b_p: *const libc::c_void,
) -> libc::c_int {
    let mut a: strm_value = 0;
    let mut b: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    a = *(a_p as *mut strm_value);
    b = *(b_p as *mut strm_value);
    tmp = strm_cmp(a, b);
    return tmp;
}
unsafe extern "C" fn sort_cmpf(
    mut a_p: *const libc::c_void,
    mut b_p: *const libc::c_void,
    mut arg: *mut libc::c_void,
) -> libc::c_int {
    let mut args: [strm_value; 2] = [0; 2];
    let mut a: *mut sort_arg = 0 as *mut sort_arg;
    let mut val: strm_value = 0;
    let mut cmp: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    a = arg as *mut sort_arg;
    args[0 as libc::c_int as usize] = *(a_p as *mut strm_value);
    args[1 as libc::c_int as usize] = *(b_p as *mut strm_value);
    tmp = strm_funcall(
        (*a).strm,
        (*a).func,
        2 as libc::c_int,
        args.as_mut_ptr(),
        &mut val,
    );
    if tmp == 1 as libc::c_int {
        return 0 as libc::c_int;
    }
    tmp___0 = strm_number_p(val);
    if tmp___0 == 0 {
        return 0 as libc::c_int;
    }
    cmp = strm_value_int(val);
    if cmp > 0 as libc::c_int {
        return 1 as libc::c_int
    } else {
        if cmp < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn mem_sort(
    mut p: *mut strm_value,
    mut len: strm_int,
    mut arg: *mut sort_arg,
) {
    if !arg.is_null() {
        qsort_r(
            p as *mut libc::c_void,
            len as size_t,
            ::std::mem::size_of::<strm_value>() as libc::c_ulong,
            Some(
                sort_cmpf
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            arg as *mut libc::c_void,
        );
    } else {
        qsort(
            p as *mut libc::c_void,
            len as size_t,
            ::std::mem::size_of::<strm_value>() as libc::c_ulong,
            Some(
                sort_cmp
                    as unsafe extern "C" fn(
                        *const libc::c_void,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        );
    };
}
unsafe extern "C" fn iter_sort(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sort_data = 0 as *mut sort_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: strm_int = 0;
    d = (*strm).data as *mut sort_data;
    if (*d).len >= (*d).capa {
        (*d).capa *= 2 as libc::c_int;
        tmp = realloc(
            (*d).buf as *mut libc::c_void,
            (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                .wrapping_mul((*d).capa as libc::c_ulong),
        );
        (*d).buf = tmp as *mut strm_value;
    }
    tmp___0 = (*d).len;
    (*d).len += 1;
    *((*d).buf).offset(tmp___0 as isize) = data;
    return 0 as libc::c_int;
}
unsafe extern "C" fn finish_sort(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sort_data = 0 as *mut sort_data;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    let mut arg: sort_arg = sort_arg {
        strm: 0 as *mut strm_stream,
        func: 0,
    };
    let mut tmp: libc::c_int = 0;
    d = (*strm).data as *mut sort_data;
    tmp = strm_nil_p((*d).func);
    if tmp != 0 {
        mem_sort((*d).buf, (*d).len, 0 as *mut libc::c_void as *mut sort_arg);
    } else {
        arg.strm = strm;
        arg.func = (*d).func;
        mem_sort((*d).buf, (*d).len, &mut arg);
    }
    i = 0 as libc::c_int;
    len = (*d).len;
    while i < len {
        strm_emit(
            strm,
            *((*d).buf).offset(i as isize),
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        i += 1;
    }
    free((*d).buf as *mut libc::c_void);
    free(d as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_sort(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut sort_data = 0 as *mut sort_data;
    let mut func: strm_value = 0;
    let mut tmp: strm_value = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_nil_value();
    func = tmp;
    tmp___0 = strm_parse_args(
        strm,
        argc,
        args,
        b"|v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp___0 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___1 = malloc(::std::mem::size_of::<sort_data>() as libc::c_ulong);
    d = tmp___1 as *mut sort_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).func = func;
    (*d).len = 0 as libc::c_int;
    (*d).capa = 1024 as libc::c_int;
    tmp___2 = malloc(
        (::std::mem::size_of::<strm_value>() as libc::c_ulong)
            .wrapping_mul(1024 as libc::c_ulong),
    );
    (*d).buf = tmp___2 as *mut strm_value;
    if ((*d).buf).is_null() {
        free(d as *mut libc::c_void);
        return 1 as libc::c_int;
    }
    tmp___3 = strm_stream_new(
        strm_filter,
        Some(
            iter_sort
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            finish_sort
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___3 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_sort(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut ary: strm_array = 0;
    let mut p: *mut strm_value = 0 as *mut strm_value;
    let mut len: strm_int = 0;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut arg: sort_arg = sort_arg {
        strm: 0 as *mut strm_stream,
        func: 0,
    };
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"a|v\0" as *const u8 as *const libc::c_char,
        &mut p as *mut *mut strm_value,
        &mut len as *mut strm_int,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    ary = strm_ary_new(p as *const strm_value, len);
    tmp___0 = strm_ary_struct(ary);
    p = (*tmp___0).ptr;
    if argc == 1 as libc::c_int {
        mem_sort(p, len, 0 as *mut libc::c_void as *mut sort_arg);
    } else {
        arg.strm = strm;
        arg.func = func;
        mem_sort(p, len, &mut arg);
    }
    *ret = ary;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sortby_cmp(
    mut a_p: *const libc::c_void,
    mut b_p: *const libc::c_void,
) -> libc::c_int {
    let mut av: *mut sortby_value = 0 as *mut sortby_value;
    let mut bv: *mut sortby_value = 0 as *mut sortby_value;
    let mut a: libc::c_double = 0.;
    let mut b: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    av = a_p as *mut sortby_value;
    bv = b_p as *mut sortby_value;
    tmp___0 = strm_number_p((*av).v);
    if tmp___0 != 0 {
        a = strm_value_float((*av).v);
    } else {
        tmp = strm_number_p((*bv).v);
        if tmp != 0 {
            return 1 as libc::c_int;
        }
        return 0 as libc::c_int;
    }
    tmp___1 = strm_number_p((*bv).v);
    if tmp___1 != 0 {
        b = strm_value_float((*bv).v);
    } else {
        return -(1 as libc::c_int)
    }
    if a > b {
        return 1 as libc::c_int
    } else {
        if a < b {
            return -(1 as libc::c_int);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_sortby(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sortby_data = 0 as *mut sortby_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_int = 0;
    d = (*strm).data as *mut sortby_data;
    if (*d).len >= (*d).capa {
        (*d).capa *= 2 as libc::c_int;
        tmp = realloc(
            (*d).buf as *mut libc::c_void,
            (::std::mem::size_of::<sortby_value>() as libc::c_ulong)
                .wrapping_mul((*d).capa as libc::c_ulong),
        );
        (*d).buf = tmp as *mut sortby_value;
    }
    (*((*d).buf).offset((*d).len as isize)).o = data;
    tmp___0 = strm_funcall(
        (*d).strm,
        (*d).func,
        1 as libc::c_int,
        &mut data,
        &mut (*((*d).buf).offset((*d).len as isize)).v,
    );
    if tmp___0 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    (*d).len += 1;
    return 0 as libc::c_int;
}
unsafe extern "C" fn finish_sortby(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sortby_data = 0 as *mut sortby_data;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    d = (*strm).data as *mut sortby_data;
    qsort(
        (*d).buf as *mut libc::c_void,
        (*d).len as size_t,
        ::std::mem::size_of::<sortby_value>() as libc::c_ulong,
        Some(
            sortby_cmp
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    i = 0 as libc::c_int;
    len = (*d).len;
    while i < len {
        strm_emit(
            strm,
            (*((*d).buf).offset(i as isize)).o,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        i += 1;
    }
    free((*d).buf as *mut libc::c_void);
    free(d as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_sortby(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut sortby_data = 0 as *mut sortby_data;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___2: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<sortby_data>() as libc::c_ulong);
    d = tmp___0 as *mut sortby_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).strm = strm;
    (*d).func = func;
    (*d).len = 0 as libc::c_int;
    (*d).capa = 1024 as libc::c_int;
    tmp___1 = malloc(
        (::std::mem::size_of::<sortby_value>() as libc::c_ulong)
            .wrapping_mul(1024 as libc::c_ulong),
    );
    (*d).buf = tmp___1 as *mut sortby_value;
    if ((*d).buf).is_null() {
        free(d as *mut libc::c_void);
        return 1 as libc::c_int;
    }
    tmp___2 = strm_stream_new(
        strm_filter,
        Some(
            iter_sortby
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            finish_sortby
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___2 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_sortby(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut buf: *mut sortby_value = 0 as *mut sortby_value;
    let mut p: *mut strm_value = 0 as *mut strm_value;
    let mut len: strm_int = 0;
    let mut func: strm_value = 0;
    let mut ary: strm_array = 0;
    let mut i: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *mut strm_array_0 = 0 as *mut strm_array_0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"av\0" as *const u8 as *const libc::c_char,
        &mut p as *mut *mut strm_value,
        &mut len as *mut strm_int,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(
        (::std::mem::size_of::<sortby_value>() as libc::c_ulong)
            .wrapping_mul(len as libc::c_ulong),
    );
    buf = tmp___0 as *mut sortby_value;
    if buf.is_null() {
        return 1 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < len {
        (*buf.offset(i as isize)).o = *p.offset(i as isize);
        tmp___1 = strm_funcall(
            strm,
            func,
            1 as libc::c_int,
            p.offset(i as isize),
            &mut (*buf.offset(i as isize)).v,
        );
        if tmp___1 == 1 as libc::c_int {
            free(buf as *mut libc::c_void);
            return 1 as libc::c_int;
        }
        i += 1;
    }
    qsort(
        buf as *mut libc::c_void,
        len as size_t,
        ::std::mem::size_of::<sortby_value>() as libc::c_ulong,
        Some(
            sortby_cmp
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    ary = strm_ary_new(0 as *mut libc::c_void as *const strm_value, len);
    tmp___2 = strm_ary_struct(ary);
    p = (*tmp___2).ptr;
    i = 0 as libc::c_int;
    while i < len {
        *p.offset(i as isize) = (*buf.offset(i as isize)).o;
        i += 1;
    }
    free(buf as *mut libc::c_void);
    *ret = ary;
    return 0 as libc::c_int;
}
unsafe extern "C" fn quick_select(
    mut arr: *mut strm_value,
    mut n: libc::c_int,
) -> strm_value {
    let mut low: libc::c_int = 0;
    let mut high: libc::c_int = 0;
    let mut median: libc::c_int = 0;
    let mut middle: libc::c_int = 0;
    let mut ll: libc::c_int = 0;
    let mut hh: libc::c_int = 0;
    let mut t: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut t___0: strm_value = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut t___1: strm_value = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut t___2: strm_value = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut t___3: strm_value = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut t___4: strm_value = 0;
    let mut t___5: strm_value = 0;
    low = 0 as libc::c_int;
    high = n - 1 as libc::c_int;
    median = (low + high) / 2 as libc::c_int;
    loop {
        if high <= low {
            return *arr.offset(median as isize);
        }
        if high == low + 1 as libc::c_int {
            tmp = strm_cmp(*arr.offset(low as isize), *arr.offset(high as isize));
            if tmp > 0 as libc::c_int {
                t = *arr.offset(low as isize);
                *arr.offset(low as isize) = *arr.offset(high as isize);
                *arr.offset(high as isize) = t;
            }
            return *arr.offset(median as isize);
        }
        middle = (low + high) / 2 as libc::c_int;
        tmp___0 = strm_cmp(*arr.offset(middle as isize), *arr.offset(high as isize));
        if tmp___0 > 0 as libc::c_int {
            t___0 = *arr.offset(middle as isize);
            *arr.offset(middle as isize) = *arr.offset(high as isize);
            *arr.offset(high as isize) = t___0;
        }
        tmp___1 = strm_cmp(*arr.offset(low as isize), *arr.offset(high as isize));
        if tmp___1 > 0 as libc::c_int {
            t___1 = *arr.offset(low as isize);
            *arr.offset(low as isize) = *arr.offset(high as isize);
            *arr.offset(high as isize) = t___1;
        }
        tmp___2 = strm_cmp(*arr.offset(middle as isize), *arr.offset(low as isize));
        if tmp___2 > 0 as libc::c_int {
            t___2 = *arr.offset(middle as isize);
            *arr.offset(middle as isize) = *arr.offset(low as isize);
            *arr.offset(low as isize) = t___2;
        }
        t___3 = *arr.offset(middle as isize);
        *arr.offset(middle as isize) = *arr.offset((low + 1 as libc::c_int) as isize);
        *arr.offset((low + 1 as libc::c_int) as isize) = t___3;
        ll = low + 1 as libc::c_int;
        hh = high;
        loop {
            loop {
                ll += 1;
                tmp___3 = strm_cmp(*arr.offset(low as isize), *arr.offset(ll as isize));
                if !(tmp___3 > 0 as libc::c_int) {
                    break;
                }
            }
            loop {
                hh -= 1;
                tmp___4 = strm_cmp(*arr.offset(hh as isize), *arr.offset(low as isize));
                if !(tmp___4 > 0 as libc::c_int) {
                    break;
                }
            }
            if hh < ll {
                break;
            }
            t___4 = *arr.offset(ll as isize);
            *arr.offset(ll as isize) = *arr.offset(hh as isize);
            *arr.offset(hh as isize) = t___4;
        }
        t___5 = *arr.offset(low as isize);
        *arr.offset(low as isize) = *arr.offset(hh as isize);
        *arr.offset(hh as isize) = t___5;
        if hh <= median {
            low = ll;
        }
        if hh >= median {
            high = hh - 1 as libc::c_int;
        }
    };
}
unsafe extern "C" fn quick_median(
    mut p: *mut strm_value,
    mut len: libc::c_int,
) -> strm_value {
    let mut v: strm_value = 0;
    let mut tmp: strm_value = 0;
    let mut next: strm_int = 0;
    let mut x: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut y: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    tmp = quick_select(p, len);
    v = tmp;
    if len % 2 as libc::c_int == 0 as libc::c_int {
        tmp___4 = strm_number_p(v);
        if tmp___4 != 0 {
            next = len / 2 as libc::c_int;
            tmp___3 = strm_number_p(*p.offset(next as isize));
            if tmp___3 != 0 {
                tmp___0 = strm_value_float(v);
                x = tmp___0;
                tmp___1 = strm_value_float(*p.offset(next as isize));
                y = tmp___1;
                tmp___2 = strm_float_value((x + y) / 2 as libc::c_int as libc::c_double);
                return tmp___2;
            }
        }
    }
    return v;
}
unsafe extern "C" fn iter_median(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sort_data = 0 as *mut sort_data;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: strm_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    d = (*strm).data as *mut sort_data;
    if (*d).len >= (*d).capa {
        (*d).capa *= 2 as libc::c_int;
        tmp = realloc(
            (*d).buf as *mut libc::c_void,
            (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                .wrapping_mul((*d).capa as libc::c_ulong),
        );
        (*d).buf = tmp as *mut strm_value;
    }
    tmp___3 = strm_nil_p((*d).func);
    if tmp___3 != 0 {
        tmp___0 = (*d).len;
        (*d).len += 1;
        *((*d).buf).offset(tmp___0 as isize) = data;
    } else {
        tmp___1 = (*d).len;
        (*d).len += 1;
        tmp___2 = strm_funcall(
            strm,
            (*d).func,
            1 as libc::c_int,
            &mut data,
            ((*d).buf).offset(tmp___1 as isize),
        );
        if tmp___2 == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn finish_median(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sort_data = 0 as *mut sort_data;
    let mut v: strm_value = 0;
    d = (*strm).data as *mut sort_data;
    v = quick_median((*d).buf, (*d).len);
    free((*d).buf as *mut libc::c_void);
    strm_emit(
        strm,
        v,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    free(d as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_median(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut sort_data = 0 as *mut sort_data;
    let mut func: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"|v\0" as *const u8 as *const libc::c_char,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<sort_data>() as libc::c_ulong);
    d = tmp___0 as *mut sort_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    if argc == 0 as libc::c_int {
        tmp___1 = strm_nil_value();
        (*d).func = tmp___1;
    } else {
        (*d).func = func;
    }
    (*d).len = 0 as libc::c_int;
    (*d).capa = 1024 as libc::c_int;
    tmp___2 = malloc(
        (::std::mem::size_of::<strm_value>() as libc::c_ulong)
            .wrapping_mul(1024 as libc::c_ulong),
    );
    (*d).buf = tmp___2 as *mut strm_value;
    if ((*d).buf).is_null() {
        free(d as *mut libc::c_void);
        return 1 as libc::c_int;
    }
    tmp___3 = strm_stream_new(
        strm_filter,
        Some(
            iter_median
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            finish_median
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___3 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_median(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut buf: *mut strm_value = 0 as *mut strm_value;
    let mut p: *mut strm_value = 0 as *mut strm_value;
    let mut len: strm_int = 0;
    let mut func: strm_value = 0;
    let mut i: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut func___0: strm_value = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"a|v\0" as *const u8 as *const libc::c_char,
        &mut p as *mut *mut strm_value,
        &mut len as *mut strm_int,
        &mut func as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if len == 0 as libc::c_int {
        strm_raise(strm, b"empty array\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(
        (::std::mem::size_of::<strm_value>() as libc::c_ulong)
            .wrapping_mul(len as libc::c_ulong),
    );
    buf = tmp___0 as *mut strm_value;
    if buf.is_null() {
        return 1 as libc::c_int;
    }
    if argc == 1 as libc::c_int {
        memcpy(
            buf as *mut libc::c_void,
            p as *const libc::c_void,
            (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                .wrapping_mul(len as libc::c_ulong),
        );
    } else {
        func___0 = *args.offset(1 as libc::c_int as isize);
        i = 0 as libc::c_int;
        while i < len {
            tmp___1 = strm_funcall(
                strm,
                func___0,
                1 as libc::c_int,
                p.offset(i as isize),
                buf.offset(i as isize),
            );
            if tmp___1 == 1 as libc::c_int {
                free(buf as *mut libc::c_void);
                return 1 as libc::c_int;
            }
            i += 1;
        }
    }
    *ret = quick_median(buf, len);
    free(buf as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_cmp(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut cmp: strm_int = 0;
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"vv\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    cmp = strm_cmp(x, y);
    *ret = strm_int_value(cmp);
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_lt(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut cmp: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"SS\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    cmp = str_cmp(x, y);
    *ret = strm_bool_value((cmp < 0 as libc::c_int) as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_le(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut cmp: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"SS\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    cmp = str_cmp(x, y);
    *ret = strm_bool_value((cmp <= 0 as libc::c_int) as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_gt(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut cmp: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"SS\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    cmp = str_cmp(x, y);
    *ret = strm_bool_value((cmp > 0 as libc::c_int) as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_ge(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut cmp: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"SS\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    cmp = str_cmp(x, y);
    *ret = strm_bool_value((cmp >= 0 as libc::c_int) as libc::c_int);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_sort_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: strm_value = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: strm_value = 0;
    let mut tmp___7: strm_value = 0;
    let mut tmp___8: strm_value = 0;
    let mut tmp___9: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            ary_sort
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_array, b"sort\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            ary_sortby
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_array,
        b"sort_by\0" as *const u8 as *const libc::c_char,
        tmp___0,
    );
    tmp___1 = strm_cfunc_value(
        Some(
            ary_median
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_array,
        b"median\0" as *const u8 as *const libc::c_char,
        tmp___1,
    );
    tmp___2 = strm_cfunc_value(
        Some(
            exec_cmp
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"cmp\0" as *const u8 as *const libc::c_char, tmp___2);
    tmp___3 = strm_cfunc_value(
        Some(
            exec_sort
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"sort\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = strm_cfunc_value(
        Some(
            exec_sortby
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"sort_by\0" as *const u8 as *const libc::c_char, tmp___4);
    tmp___5 = strm_cfunc_value(
        Some(
            exec_median
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"median\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = strm_cfunc_value(
        Some(
            str_lt
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_string, b"<\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = strm_cfunc_value(
        Some(
            str_le
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_string, b"<=\0" as *const u8 as *const libc::c_char, tmp___7);
    tmp___8 = strm_cfunc_value(
        Some(
            str_gt
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_string, b">\0" as *const u8 as *const libc::c_char, tmp___8);
    tmp___9 = strm_cfunc_value(
        Some(
            str_ge
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_string, b">=\0" as *const u8 as *const libc::c_char, tmp___9);
}
unsafe extern "C" fn fprint_str(mut str: node_string_0, mut f: *mut FILE) {
    fprintf(
        f,
        b"%.*s\0" as *const u8 as *const libc::c_char,
        (*str).len,
        ((*str).buf).as_mut_ptr(),
    );
}
unsafe extern "C" fn print_str(mut name: node_string_0) {
    fprint_str(name, stdout);
    fputs(b"\n\0" as *const u8 as *const libc::c_char, stdout);
}
unsafe extern "C" fn print_id(mut pre: *const libc::c_char, mut name: node_string_0) {
    fputs(pre, stdout);
    print_str(name);
}
unsafe extern "C" fn print_quoted_id(
    mut pre: *const libc::c_char,
    mut name: node_string_0,
) {
    fputs(pre, stdout);
    fputs(b"\"\0" as *const u8 as *const libc::c_char, stdout);
    fprint_str(name, stdout);
    fputs(b"\"\n\0" as *const u8 as *const libc::c_char, stdout);
}
unsafe extern "C" fn dump_node(mut np: *mut node, mut indent: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut args: *mut node_args = 0 as *mut node_args;
    let mut j: libc::c_int = 0;
    let mut s: node_string_0 = 0 as *mut node_string;
    let mut opt_else: *mut node = 0 as *mut node;
    let mut ary: *mut node_nodes = 0 as *mut node_nodes;
    let mut ary___0: *mut node_nodes = 0 as *mut node_nodes;
    let mut cons: *mut node_psplat = 0 as *mut node_psplat;
    let mut splat: *mut node_splat = 0 as *mut node_splat;
    let mut s___0: node_string_0 = 0 as *mut node_string;
    let mut s___1: node_string_0 = 0 as *mut node_string;
    let mut j___0: libc::c_int = 0;
    let mut ary___1: *mut node_array = 0 as *mut node_array;
    let mut h: *mut node_string_0 = 0 as *mut node_string_0;
    let mut ns: node_string_0 = 0 as *mut node_string;
    let mut ary___2: *mut node_nodes = 0 as *mut node_nodes;
    let mut nt: *mut node_time = 0 as *mut node_time;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    i = 0 as libc::c_int;
    while i < indent {
        putchar(' ' as i32);
        i += 1;
    }
    if np.is_null() {
        printf(b"NIL\n\0" as *const u8 as *const libc::c_char);
        return;
    }
    match (*np).type_0 as libc::c_uint {
        6 => {
            args = np as *mut node_args;
            printf(b"ARGS(%d):\n\0" as *const u8 as *const libc::c_char, (*args).len);
            i = 0 as libc::c_int;
            while i < (*args).len {
                s = *((*args).data).offset(i as isize);
                j = 0 as libc::c_int;
                while j < indent + 1 as libc::c_int {
                    putchar(' ' as i32);
                    j += 1;
                }
                print_str(s);
                i += 1;
            }
        }
        17 => {
            printf(b"IF:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*(np as *mut node_if)).cond, indent + 1 as libc::c_int);
            i = 0 as libc::c_int;
            while i < indent {
                putchar(' ' as i32);
                i += 1;
            }
            printf(b"THEN:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*(np as *mut node_if)).then, indent + 1 as libc::c_int);
            opt_else = (*(np as *mut node_if)).opt_else;
            if opt_else as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
                i = 0 as libc::c_int;
                while i < indent {
                    putchar(' ' as i32);
                    i += 1;
                }
                printf(b"ELSE:\n\0" as *const u8 as *const libc::c_char);
                dump_node(opt_else, indent + 1 as libc::c_int);
            }
        }
        18 => {
            printf(b"EMIT:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*(np as *mut node_emit)).emit, indent + 1 as libc::c_int);
        }
        23 => {
            printf(b"OP:\n\0" as *const u8 as *const libc::c_char);
            i = 0 as libc::c_int;
            while i < indent + 1 as libc::c_int {
                putchar(' ' as i32);
                i += 1;
            }
            print_id(
                b"op: \0" as *const u8 as *const libc::c_char,
                (*(np as *mut node_op)).op,
            );
            dump_node((*(np as *mut node_op)).lhs, indent + 1 as libc::c_int);
            dump_node((*(np as *mut node_op)).rhs, indent + 1 as libc::c_int);
        }
        9 => {
            printf(b"LAMBDA:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*(np as *mut node_lambda)).args, indent + 1 as libc::c_int);
            dump_node((*(np as *mut node_lambda)).body, indent + 1 as libc::c_int);
        }
        10 => {
            printf(b"PLAMBDA:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*(np as *mut node_plambda)).pat, indent + 1 as libc::c_int);
            if !((*(np as *mut node_plambda)).cond).is_null() {
                i = 0 as libc::c_int;
                while i < indent + 2 as libc::c_int {
                    putchar(' ' as i32);
                    i += 1;
                }
                printf(b"IF:\n\0" as *const u8 as *const libc::c_char);
                dump_node((*(np as *mut node_plambda)).cond, indent + 2 as libc::c_int);
            }
            dump_node((*(np as *mut node_plambda)).body, indent + 1 as libc::c_int);
            if !((*(np as *mut node_plambda)).next).is_null() {
                dump_node((*(np as *mut node_plambda)).next, indent);
            }
        }
        11 => {
            printf(b"PARRAY:\n\0" as *const u8 as *const libc::c_char);
            ary = np as *mut node_nodes;
            i = 0 as libc::c_int;
            while i < (*ary).len {
                dump_node(*((*ary).data).offset(i as isize), indent + 1 as libc::c_int);
                i += 1;
            }
        }
        12 => {
            printf(b"PSTRUCT:\n\0" as *const u8 as *const libc::c_char);
            ary___0 = np as *mut node_nodes;
            i = 0 as libc::c_int;
            while i < (*ary___0).len {
                dump_node(
                    *((*ary___0).data).offset(i as isize),
                    indent + 1 as libc::c_int,
                );
                i += 1;
            }
        }
        13 => {
            printf(b"PSPLAT:\n\0" as *const u8 as *const libc::c_char);
            cons = np as *mut node_psplat;
            dump_node((*cons).head, indent + 1 as libc::c_int);
            i = 0 as libc::c_int;
            while i < indent + 1 as libc::c_int {
                putchar(' ' as i32);
                i += 1;
            }
            printf(b"REST:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*cons).mid, indent + 2 as libc::c_int);
            i = 0 as libc::c_int;
            while i < indent + 1 as libc::c_int {
                putchar(' ' as i32);
                i += 1;
            }
            printf(b"TAIL:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*cons).tail, indent + 2 as libc::c_int);
        }
        14 => {
            printf(b"SPLAT:\n\0" as *const u8 as *const libc::c_char);
            splat = np as *mut node_splat;
            dump_node((*splat).node, indent + 1 as libc::c_int);
        }
        24 => {
            printf(b"CALL:\n\0" as *const u8 as *const libc::c_char);
            i = 0 as libc::c_int;
            while i < indent + 2 as libc::c_int {
                putchar(' ' as i32);
                i += 1;
            }
            s___0 = (*(np as *mut node_call)).ident;
            print_str(s___0);
            dump_node((*(np as *mut node_call)).args, indent + 2 as libc::c_int);
        }
        25 => {
            printf(b"FCALL:\n\0" as *const u8 as *const libc::c_char);
            i = 0 as libc::c_int;
            while i < indent + 1 as libc::c_int {
                putchar(' ' as i32);
                i += 1;
            }
            printf(b"FUNC:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*(np as *mut node_fcall)).func, indent + 2 as libc::c_int);
            i = 0 as libc::c_int;
            while i < indent + 1 as libc::c_int {
                putchar(' ' as i32);
                i += 1;
            }
            printf(b"ARGS:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*(np as *mut node_fcall)).args, indent + 2 as libc::c_int);
        }
        26 => {
            printf(b"GENFUNC: \0" as *const u8 as *const libc::c_char);
            s___1 = (*(np as *mut node_genfunc)).id;
            print_str(s___1);
        }
        20 => {
            printf(b"RETURN:\n\0" as *const u8 as *const libc::c_char);
            dump_node((*(np as *mut node_return)).rv, indent + 1 as libc::c_int);
        }
        16 => {
            print_id(
                b"LET: \0" as *const u8 as *const libc::c_char,
                (*(np as *mut node_let)).lhs,
            );
            dump_node((*(np as *mut node_let)).rhs, indent + 1 as libc::c_int);
        }
        15 => {
            print_id(
                b"IDENT: \0" as *const u8 as *const libc::c_char,
                (*(np as *mut node_ident)).name,
            );
        }
        27 => {
            printf(b"ARRAY:\n\0" as *const u8 as *const libc::c_char);
            ary___1 = np as *mut node_array;
            if !((*ary___1).headers).is_null() {
                h = (*ary___1).headers;
                i = 0 as libc::c_int;
                while i < (*ary___1).len {
                    j___0 = 0 as libc::c_int;
                    while j___0 < indent + 1 as libc::c_int {
                        putchar(' ' as i32);
                        j___0 += 1;
                    }
                    print_quoted_id(
                        b"key: \0" as *const u8 as *const libc::c_char,
                        *h.offset(i as isize),
                    );
                    dump_node(
                        *((*ary___1).data).offset(i as isize),
                        indent + 1 as libc::c_int,
                    );
                    i += 1;
                }
            } else {
                i = 0 as libc::c_int;
                while i < (*ary___1).len {
                    dump_node(
                        *((*ary___1).data).offset(i as isize),
                        indent + 1 as libc::c_int,
                    );
                    i += 1;
                }
            }
            if !((*ary___1).ns).is_null() {
                ns = (*ary___1).ns;
                j___0 = 0 as libc::c_int;
                while j___0 < indent + 1 as libc::c_int {
                    putchar(' ' as i32);
                    j___0 += 1;
                }
                print_quoted_id(b"class: \0" as *const u8 as *const libc::c_char, ns);
            }
        }
        28 => {
            printf(b"NODES:\n\0" as *const u8 as *const libc::c_char);
            ary___2 = np as *mut node_nodes;
            i = 0 as libc::c_int;
            while i < (*ary___2).len {
                dump_node(
                    *((*ary___2).data).offset(i as isize),
                    indent + 1 as libc::c_int,
                );
                i += 1;
            }
        }
        30 => {
            print_id(
                b"IMPORT: \0" as *const u8 as *const libc::c_char,
                (*(np as *mut node_import)).name,
            );
        }
        29 => {
            print_id(
                b"NAMESPACE: \0" as *const u8 as *const libc::c_char,
                (*(np as *mut node_ns)).name,
            );
            dump_node((*(np as *mut node_ns)).body, indent + 1 as libc::c_int);
        }
        0 => {
            printf(
                b"VALUE(NUMBER): %d\n\0" as *const u8 as *const libc::c_char,
                (*(np as *mut node_int)).value,
            );
        }
        1 => {
            printf(
                b"VALUE(NUMBER): %f\n\0" as *const u8 as *const libc::c_char,
                (*(np as *mut node_float)).value,
            );
        }
        2 => {
            nt = np as *mut node_time;
            printf(
                b"VALUE(TIME): %ld.%ld(%+05d)\n\0" as *const u8 as *const libc::c_char,
                (*nt).sec,
                (*nt).usec,
                (*nt).utc_offset,
            );
        }
        5 => {
            if (*(np as *mut node_bool)).value != 0 {
                tmp = b"true\0" as *const u8 as *const libc::c_char;
            } else {
                tmp = b"false\0" as *const u8 as *const libc::c_char;
            }
            printf(b"VALUE(BOOL): %s\n\0" as *const u8 as *const libc::c_char, tmp);
        }
        3 => {
            print_quoted_id(
                b"VALUE(STRING): \0" as *const u8 as *const libc::c_char,
                (*(np as *mut node_str)).value,
            );
        }
        4 => {
            printf(b"VALUE(NIL): nil\n\0" as *const u8 as *const libc::c_char);
        }
        _ => {
            printf(
                b"UNKNOWN(%d)\n\0" as *const u8 as *const libc::c_char,
                (*np).type_0 as libc::c_uint,
            );
        }
    };
}
pub static mut strm_option_verbose: libc::c_int = 0 as libc::c_int;
unsafe fn main_0(
    mut argc: libc::c_int,
    mut argv: *mut *const libc::c_char,
) -> libc::c_int {
    let mut prog: *const libc::c_char = 0 as *const libc::c_char;
    let mut e_prog: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut verbose: libc::c_int = 0;
    let mut check: libc::c_int = 0;
    let mut state: parser_state = parser_state {
        nerr: 0,
        lval: 0 as *mut libc::c_void,
        fname: 0 as *const libc::c_char,
        lineno: 0,
        tline: 0,
    };
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut av: strm_array = 0;
    let mut tmp___1: strm_array = 0;
    let mut buf: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___2: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i___0: libc::c_int = 0;
    let mut tmp___3: size_t = 0;
    let mut tmp___4: strm_string = 0;
    let mut tmp___5: libc::c_int = 0;
    prog = *argv.offset(0 as libc::c_int as isize);
    e_prog = 0 as *mut libc::c_void as *const libc::c_char;
    n = 0 as libc::c_int;
    verbose = 0 as libc::c_int;
    check = 0 as libc::c_int;
    let mut current_block_19: u64;
    while argc > 1 as libc::c_int {
        if !(*(*argv.offset(1 as libc::c_int as isize)).offset(0 as libc::c_int as isize)
            as libc::c_int == 45 as libc::c_int)
        {
            break;
        }
        s = (*argv.offset(1 as libc::c_int as isize)).offset(1 as libc::c_int as isize);
        while *s != 0 {
            match *s as libc::c_int {
                118 => {
                    verbose = 1 as libc::c_int;
                    current_block_19 = 14079705527621014786;
                }
                119 => {
                    current_block_19 = 14079705527621014786;
                }
                99 => {
                    check = 1 as libc::c_int;
                    current_block_19 = 14648156034262866959;
                }
                101 => {
                    if *s.offset(1 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        e_prog = *argv.offset(2 as libc::c_int as isize);
                        argc -= 1;
                        argv = argv.offset(1);
                    } else {
                        e_prog = s.offset(1 as libc::c_int as isize);
                    }
                    break;
                }
                _ => {
                    fprintf(
                        stderr,
                        b"%s: unknown option -%c\n\0" as *const u8
                            as *const libc::c_char,
                        prog,
                        *s as libc::c_int,
                    );
                    current_block_19 = 14648156034262866959;
                }
            }
            match current_block_19 {
                14079705527621014786 => {
                    strm_option_verbose = 1 as libc::c_int;
                }
                _ => {}
            }
            s = s.offset(1);
        }
        argc -= 1;
        argv = argv.offset(1);
    }
    node_parse_init(&mut state);
    if !e_prog.is_null() {
        tmp = node_parse_string(&mut state, e_prog);
        n += tmp;
    } else if argc == 1 as libc::c_int {
        n = node_parse_input(
            &mut state,
            stdin,
            b"stdin\0" as *const u8 as *const libc::c_char,
        );
    } else {
        i = 1 as libc::c_int;
        while i < argc {
            tmp___0 = node_parse_file(&mut state, *argv.offset(i as isize));
            n += tmp___0;
            i += 1;
        }
    }
    if n == 0 as libc::c_int {
        if verbose != 0 {
            dump_node(state.lval as *mut node, 0 as libc::c_int);
        }
        if check != 0 {
            puts(b"Syntax OK\0" as *const u8 as *const libc::c_char);
        } else {
            tmp___1 = strm_ary_new(0 as *mut libc::c_void as *const strm_value, argc);
            av = tmp___1;
            tmp___2 = strm_ary_struct(av);
            buf = (*tmp___2).ptr;
            i___0 = 0 as libc::c_int;
            while i___0 < argc {
                tmp___3 = strlen(*argv.offset(i___0 as isize));
                tmp___4 = strm_str_new(
                    *argv.offset(i___0 as isize),
                    tmp___3 as strm_int,
                );
                *buf.offset(i___0 as isize) = tmp___4;
                i___0 += 1;
            }
            strm_var_def(
                0 as *mut libc::c_void as *mut strm_state,
                b"ARGV\0" as *const u8 as *const libc::c_char,
                av,
            );
            node_run(&mut state);
            strm_loop();
            node_stop();
        }
    } else if check != 0 {
        puts(b"Syntax NG\0" as *const u8 as *const libc::c_char);
    }
    node_parse_free(&mut state);
    if n > 0 as libc::c_int {
        tmp___5 = 1 as libc::c_int;
    } else {
        tmp___5 = 0 as libc::c_int;
    }
    return tmp___5;
}
unsafe extern "C" fn count_fields(
    mut line: strm_string,
    mut sep: libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ptr: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut pend: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: strm_int = 0;
    let mut cnt: libc::c_int = 0;
    let mut quoted: libc::c_int = 0;
    tmp = strm_strp_ptr(&mut line);
    ptr = tmp;
    tmp___0 = strm_str_len(line);
    pend = ptr.offset(tmp___0 as isize);
    quoted = 0 as libc::c_int;
    cnt = 1 as libc::c_int;
    while (ptr as libc::c_ulong) < pend as libc::c_ulong {
        if quoted != 0 {
            if *ptr.offset(0 as libc::c_int as isize) as libc::c_int == 34 as libc::c_int
            {
                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                    == 34 as libc::c_int
                {
                    ptr = ptr.offset(1);
                } else {
                    quoted = 0 as libc::c_int;
                }
            }
        } else {
            match *ptr as libc::c_int {
                34 => {
                    current_block = 7056156764025611863;
                    match current_block {
                        17780730044932900546 => {
                            if *ptr as libc::c_int == sep as libc::c_int {
                                cnt += 1;
                            }
                        }
                        _ => {
                            quoted = 1 as libc::c_int;
                        }
                    }
                }
                9 | 44 => {
                    current_block = 17780730044932900546;
                    match current_block {
                        17780730044932900546 => {
                            if *ptr as libc::c_int == sep as libc::c_int {
                                cnt += 1;
                            }
                        }
                        _ => {
                            quoted = 1 as libc::c_int;
                        }
                    }
                }
                _ => {}
            }
        }
        ptr = ptr.offset(1);
    }
    if quoted != 0 {
        return -(1 as libc::c_int);
    }
    return cnt;
}
unsafe extern "C" fn csv_string(
    mut p: *const libc::c_char,
    mut len: strm_int,
    mut ftype: csv_type,
) -> strm_value {
    let mut str: strm_string = 0;
    let mut pend: *const libc::c_char = 0 as *const libc::c_char;
    let mut t: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut in_quote: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sec: libc::c_long = 0;
    let mut usec: libc::c_long = 0;
    let mut offset: libc::c_int = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    match ftype as libc::c_uint {
        4 => {
            pend = p.offset(len as isize);
            in_quote = 0 as libc::c_int;
            tmp = malloc((len + 1 as libc::c_int) as size_t);
            s = tmp as *mut libc::c_char;
            t = s;
            while (p as libc::c_ulong) < pend as libc::c_ulong {
                if in_quote != 0 {
                    if *p as libc::c_int == 34 as libc::c_int {
                        if *p.offset(1 as libc::c_int as isize) as libc::c_int
                            == 34 as libc::c_int
                        {
                            p = p.offset(1);
                            tmp___0 = t;
                            t = t.offset(1);
                            *tmp___0 = '"' as i32 as libc::c_char;
                            continue;
                        } else {
                            in_quote = 0 as libc::c_int;
                        }
                    } else {
                        tmp___1 = t;
                        t = t.offset(1);
                        *tmp___1 = *p;
                    }
                } else if *p as libc::c_int == 34 as libc::c_int {
                    in_quote = 1 as libc::c_int;
                } else {
                    tmp___2 = t;
                    t = t.offset(1);
                    *tmp___2 = *p;
                }
                p = p.offset(1);
            }
            str = strm_str_new(
                s as *const libc::c_char,
                t.offset_from(s) as libc::c_long as strm_int,
            );
            free(s as *mut libc::c_void);
        }
        _ => {
            tmp___5 = __ctype_b_loc();
            if *(*tmp___5).offset(*p as libc::c_int as isize) as libc::c_int
                & 2048 as libc::c_int != 0
            {
                tmp___4 = strm_time_parse_time(p, len, &mut sec, &mut usec, &mut offset);
                if tmp___4 == 0 as libc::c_int {
                    tmp___3 = strm_time_new(sec, usec, offset);
                    return tmp___3;
                }
            }
            str = strm_str_new(p, len);
        }
    }
    return str;
}
unsafe extern "C" fn csv_value(
    mut p: *const libc::c_char,
    mut len: strm_int,
    mut ftype: csv_type,
) -> strm_value {
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut send: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_long = 0;
    let mut f: libc::c_double = 0.;
    let mut pow___0: libc::c_double = 0.;
    let mut type_0: csv_type = TYPE_UNSPC;
    let mut tmp: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    s = p;
    send = s.offset(len as isize);
    i = 0 as libc::c_long;
    pow___0 = 1 as libc::c_int as libc::c_double;
    type_0 = TYPE_STR;
    match ftype as libc::c_uint {
        2 | 0 => {
            loop {
                tmp = __ctype_b_loc();
                if *(*tmp).offset(*s as libc::c_int as isize) as libc::c_int
                    & 8192 as libc::c_int == 0
                {
                    break;
                }
                s = s.offset(1);
            }
            while (s as libc::c_ulong) < send as libc::c_ulong {
                match *s as libc::c_int {
                    57 | 56 | 55 | 54 | 53 | 52 | 51 | 50 | 49 | 48 => {
                        if type_0 as libc::c_uint == 1 as libc::c_uint {
                            type_0 = TYPE_INT;
                        }
                        i = i * 10 as libc::c_long
                            + (*s as libc::c_int - 48 as libc::c_int) as libc::c_long;
                        pow___0 *= 10 as libc::c_int as libc::c_double;
                    }
                    46 => {
                        if type_0 as libc::c_uint == 6 as libc::c_uint {
                            type_0 = TYPE_TIME;
                        } else {
                            type_0 = TYPE_FLOAT;
                            f = i as libc::c_double;
                            i = 0 as libc::c_long;
                            pow___0 = 1 as libc::c_int as libc::c_double;
                        }
                    }
                    _ => {
                        type_0 = TYPE_UNSPC;
                    }
                }
                s = s.offset(1);
            }
        }
        _ => {}
    }
    match type_0 as libc::c_uint {
        5 => {
            tmp___0 = strm_int_value(i as strm_int);
            return tmp___0;
        }
        6 => {
            f += i as libc::c_double / pow___0;
            tmp___1 = strm_float_value(f);
            return tmp___1;
        }
        _ => {
            tmp___2 = csv_string(p, len, ftype);
            return tmp___2;
        }
    };
}
pub unsafe extern "C" fn csv_type(mut v: strm_value) -> csv_type {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = strm_number_p(v);
    if tmp != 0 {
        return TYPE_NUM;
    }
    tmp___0 = strm_time_p(v);
    if tmp___0 != 0 { return TYPE_TIME } else { return TYPE_STR };
}
unsafe extern "C" fn sv_accept(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ary: strm_array = 0;
    let mut line: strm_string = 0;
    let mut bp: *mut strm_value = 0 as *mut strm_value;
    let mut fbeg: *const libc::c_char = 0 as *const libc::c_char;
    let mut ptr: *const libc::c_char = 0 as *const libc::c_char;
    let mut pend: *const libc::c_char = 0 as *const libc::c_char;
    let mut fieldcnt: libc::c_int = 0;
    let mut in_quote: libc::c_int = 0;
    let mut all_str: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut ftype: csv_type = TYPE_UNSPC;
    let mut types: *mut csv_type = 0 as *mut csv_type;
    let mut cd: *mut csv_data = 0 as *mut csv_data;
    let mut sep: libc::c_char = 0;
    let mut len: strm_int = 0;
    let mut tmp: strm_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___3: strm_int = 0;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: strm_int = 0;
    let mut tmp___6: strm_int = 0;
    let mut tmp___7: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___8: strm_int = 0;
    let mut tmp___9: strm_int = 0;
    let mut tmp___10: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut h: strm_array = 0;
    let mut p: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___14: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i___0: libc::c_int = 0;
    let mut str: strm_string = 0;
    let mut tmp___15: strm_string = 0;
    let mut tmp___16: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___17: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___18: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___19: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___20: csv_type = TYPE_UNSPC;
    line = data;
    in_quote = 0 as libc::c_int;
    all_str = 1 as libc::c_int;
    i = 0 as libc::c_int;
    cd = (*strm).data as *mut csv_data;
    sep = (*cd).sep;
    if (*cd).prev != 0 {
        tmp = strm_str_len((*cd).prev);
        tmp___0 = strm_str_len(line);
        len = tmp + tmp___0 + 1 as libc::c_int;
        tmp___2 = malloc(len as size_t);
        tmp___1 = tmp___2 as *mut libc::c_char;
        tmp___3 = strm_str_len((*cd).prev);
        tmp___4 = strm_strp_ptr(&mut (*cd).prev);
        memcpy(
            tmp___1 as *mut libc::c_void,
            tmp___4 as *const libc::c_void,
            tmp___3 as size_t,
        );
        tmp___5 = strm_str_len((*cd).prev);
        *tmp___1.offset(tmp___5 as isize) = '\n' as i32 as libc::c_char;
        tmp___6 = strm_str_len(line);
        tmp___7 = strm_strp_ptr(&mut line);
        tmp___8 = strm_str_len((*cd).prev);
        memcpy(
            tmp___1.offset(tmp___8 as isize).offset(1 as libc::c_int as isize)
                as *mut libc::c_void,
            tmp___7 as *const libc::c_void,
            tmp___6 as size_t,
        );
        line = strm_str_new(tmp___1 as *const libc::c_char, len);
        free(tmp___1 as *mut libc::c_void);
        (*cd).prev = 0 as libc::c_int as strm_string;
    }
    fieldcnt = count_fields(line, (*cd).sep);
    if fieldcnt == -(1 as libc::c_int) {
        (*cd).prev = line;
        return 1 as libc::c_int;
    }
    if (*cd).n > 0 as libc::c_int {
        if fieldcnt != (*cd).n {
            return 1 as libc::c_int;
        }
    }
    ptr = strm_strp_ptr(&mut line);
    tmp___9 = strm_str_len(line);
    pend = ptr.offset(tmp___9 as isize);
    ary = strm_ary_new(0 as *mut libc::c_void as *const strm_value, fieldcnt);
    if ary == 0 {
        return 1 as libc::c_int;
    }
    tmp___10 = strm_ary_struct(ary);
    bp = (*tmp___10).ptr;
    types = (*cd).types;
    if !types.is_null() {
        ftype = *types.offset(0 as libc::c_int as isize);
    } else {
        ftype = TYPE_UNSPC;
    }
    fbeg = ptr;
    while (ptr as libc::c_ulong) < pend as libc::c_ulong {
        if in_quote != 0 {
            if *ptr as libc::c_int == 34 as libc::c_int {
                if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                    == 34 as libc::c_int
                {
                    ptr = ptr.offset(1);
                    ftype = TYPE_ESC;
                } else {
                    in_quote = 0 as libc::c_int;
                }
            }
        } else {
            match *ptr as libc::c_int {
                34 => {
                    current_block = 1393633903314574829;
                    match current_block {
                        9644440189028477373 => {
                            if !(*ptr as libc::c_int != sep as libc::c_int) {
                                *bp = csv_value(
                                    fbeg,
                                    ptr.offset_from(fbeg) as libc::c_long as strm_int,
                                    ftype,
                                );
                                tmp___11 = strm_string_p(*bp);
                                if tmp___11 == 0 {
                                    all_str = 0 as libc::c_int;
                                }
                                bp = bp.offset(1);
                                fbeg = ptr.offset(1 as libc::c_int as isize);
                                i += 1;
                                if !types.is_null() {
                                    ftype = *types.offset(i as isize);
                                } else {
                                    ftype = TYPE_UNSPC;
                                }
                            }
                        }
                        _ => {
                            in_quote = 1 as libc::c_int;
                            if ptr as libc::c_ulong == fbeg as libc::c_ulong {
                                ftype = TYPE_STR;
                                fbeg = ptr.offset(1 as libc::c_int as isize);
                            } else {
                                ftype = TYPE_ESC;
                            }
                        }
                    }
                }
                9 | 44 => {
                    current_block = 9644440189028477373;
                    match current_block {
                        9644440189028477373 => {
                            if !(*ptr as libc::c_int != sep as libc::c_int) {
                                *bp = csv_value(
                                    fbeg,
                                    ptr.offset_from(fbeg) as libc::c_long as strm_int,
                                    ftype,
                                );
                                tmp___11 = strm_string_p(*bp);
                                if tmp___11 == 0 {
                                    all_str = 0 as libc::c_int;
                                }
                                bp = bp.offset(1);
                                fbeg = ptr.offset(1 as libc::c_int as isize);
                                i += 1;
                                if !types.is_null() {
                                    ftype = *types.offset(i as isize);
                                } else {
                                    ftype = TYPE_UNSPC;
                                }
                            }
                        }
                        _ => {
                            in_quote = 1 as libc::c_int;
                            if ptr as libc::c_ulong == fbeg as libc::c_ulong {
                                ftype = TYPE_STR;
                                fbeg = ptr.offset(1 as libc::c_int as isize);
                            } else {
                                ftype = TYPE_ESC;
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        ptr = ptr.offset(1);
    }
    if *ptr.offset(-(1 as libc::c_int) as isize) as libc::c_int == 10 as libc::c_int {
        ptr = ptr.offset(-1);
    }
    if *ptr.offset(-(1 as libc::c_int) as isize) as libc::c_int == 13 as libc::c_int {
        ptr = ptr.offset(-1);
    }
    *bp = csv_value(fbeg, ptr.offset_from(fbeg) as libc::c_long as strm_int, ftype);
    tmp___12 = strm_string_p(*bp);
    if tmp___12 == 0 {
        all_str = 0 as libc::c_int;
    }
    if (*cd).headers == 0 {
        if ((*cd).types).is_null() {
            if all_str != 0 {
                (*cd).headers = ary;
                ary = 0 as libc::c_int as strm_array;
            }
            (*cd).n = fieldcnt;
        }
    }
    if ary != 0 {
        if (*cd).headers != 0 {
            tmp___13 = strm_ary_struct(ary);
            (*tmp___13).headers = (*cd).headers;
        }
        if ((*cd).types).is_null() {
            if (*cd).headers != 0 {
                if all_str != 0 {
                    strm_emit(
                        strm,
                        (*cd).headers,
                        ::std::mem::transmute::<
                            *mut libc::c_void,
                            Option::<
                                unsafe extern "C" fn(
                                    *mut strm_stream,
                                    strm_value,
                                ) -> libc::c_int,
                            >,
                        >(0 as *mut libc::c_void),
                    );
                    (*cd).headers = 0 as libc::c_int as strm_array;
                } else {
                    h = (*cd).headers;
                    tmp___14 = strm_ary_struct(h);
                    p = (*tmp___14).ptr;
                    i___0 = 0 as libc::c_int;
                    loop {
                        tmp___16 = strm_ary_struct(h);
                        if !(i___0 < (*tmp___16).len) {
                            break;
                        }
                        str = *p.offset(i___0 as isize);
                        tmp___15 = strm_str_intern_str(str);
                        *p.offset(i___0 as isize) = tmp___15;
                        i___0 += 1;
                    }
                }
            }
            tmp___17 = malloc(
                (::std::mem::size_of::<csv_type>() as libc::c_ulong)
                    .wrapping_mul(fieldcnt as libc::c_ulong),
            );
            (*cd).types = tmp___17 as *mut csv_type;
            if ((*cd).types).is_null() {
                return 1 as libc::c_int;
            }
            i = 0 as libc::c_int;
            while i < fieldcnt {
                tmp___18 = strm_ary_struct(ary);
                *((*cd).types)
                    .offset(
                        i as isize,
                    ) = csv_type(*((*tmp___18).ptr).offset(i as isize));
                i += 1;
            }
        } else {
            i = 0 as libc::c_int;
            while i < fieldcnt {
                tmp___19 = strm_ary_struct(ary);
                tmp___20 = csv_type(*((*tmp___19).ptr).offset(i as isize));
                if *((*cd).types).offset(i as isize) as libc::c_uint
                    != tmp___20 as libc::c_uint
                {
                    strm_raise(
                        strm,
                        b"csv type mismatch\0" as *const u8 as *const libc::c_char,
                    );
                    return 1 as libc::c_int;
                }
                i += 1;
            }
        }
        strm_emit(
            strm,
            ary,
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn sv_finish(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut cd: *mut csv_data = 0 as *mut csv_data;
    cd = (*strm).data as *mut csv_data;
    if (*cd).headers != 0 {
        if (*cd).types as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            strm_emit(
                strm,
                (*cd).headers,
                ::std::mem::transmute::<
                    *mut libc::c_void,
                    Option::<
                        unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                    >,
                >(0 as *mut libc::c_void),
            );
            (*cd).headers = 0 as libc::c_int as strm_array;
        }
    }
    if !((*cd).types).is_null() {
        free((*cd).types as *mut libc::c_void);
        (*cd).types = 0 as *mut libc::c_void as *mut csv_type;
    }
    free(cd as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn sv(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
    mut sep: libc::c_char,
) -> libc::c_int {
    let mut t: *mut strm_stream = 0 as *mut strm_stream;
    let mut cd: *mut csv_data = 0 as *mut csv_data;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strm_parse_args(strm, argc, args, b"\0" as *const u8 as *const libc::c_char);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<csv_data>() as libc::c_ulong);
    cd = tmp___0 as *mut csv_data;
    if cd.is_null() {
        return 1 as libc::c_int;
    }
    (*cd).headers = 0 as libc::c_int as strm_array;
    (*cd).types = 0 as *mut libc::c_void as *mut csv_type;
    (*cd).prev = 0 as libc::c_int as strm_string;
    (*cd).sep = sep;
    (*cd).n = 0 as libc::c_int;
    t = strm_stream_new(
        strm_filter,
        Some(
            sv_accept
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            sv_finish
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        cd as *mut libc::c_void,
    );
    *ret = strm_ptr_value(t as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn csv(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = sv(strm, argc, args, ret, ',' as i32 as libc::c_char);
    return tmp;
}
unsafe extern "C" fn tsv(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = sv(strm, argc, args, ret, '\t' as i32 as libc::c_char);
    return tmp;
}
unsafe extern "C" fn ltsv_accept(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: strm_int = 0;
    let mut tmp___1: strm_int = 0;
    let mut pend: *const libc::c_char = 0 as *const libc::c_char;
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut nval: libc::c_int = 0;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ary: strm_array = 0;
    let mut tmp___3: strm_array = 0;
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___4: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut hdr: strm_array = 0;
    let mut tmp___5: strm_array = 0;
    let mut h: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___6: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut i: libc::c_int = 0;
    let mut str: strm_string = 0;
    let mut rend: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___8: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___9: *mut strm_array_0 = 0 as *mut strm_array_0;
    tmp = strm_string_p(data);
    if tmp == 0 {
        strm_raise(strm, b"ltsv: string required\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___0 = strm_strp_ptr(&mut data);
    p = tmp___0;
    tmp___1 = strm_str_len(data);
    len = tmp___1;
    pend = p.offset(len as isize);
    s = p;
    nval = 0 as libc::c_int;
    while (p as libc::c_ulong) < pend as libc::c_ulong {
        tmp___2 = memchr(
            p as *const libc::c_void,
            '\t' as i32,
            pend.offset_from(p) as libc::c_long as size_t,
        );
        s = tmp___2 as *const libc::c_char;
        nval += 1;
        if s as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            break;
        }
        p = s.offset(1 as libc::c_int as isize);
    }
    tmp___3 = strm_ary_new(0 as *mut libc::c_void as *const strm_value, nval);
    ary = tmp___3;
    tmp___4 = strm_ary_struct(ary);
    v = (*tmp___4).ptr;
    tmp___5 = strm_ary_new(0 as *mut libc::c_void as *const strm_value, nval);
    hdr = tmp___5;
    tmp___6 = strm_ary_struct(hdr);
    h = (*tmp___6).ptr;
    p = strm_strp_ptr(&mut data);
    i = 0 as libc::c_int;
    while i < nval {
        tmp___7 = memchr(
            p as *const libc::c_void,
            '\t' as i32,
            pend.offset_from(p) as libc::c_long as size_t,
        );
        rend = tmp___7 as *const libc::c_char;
        if rend as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            rend = pend;
        }
        tmp___8 = memchr(
            p as *const libc::c_void,
            ':' as i32,
            rend.offset_from(p) as libc::c_long as size_t,
        );
        s = tmp___8 as *const libc::c_char;
        if s as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
            *h.offset(i as isize) = strm_nil_value();
        } else {
            str = strm_str_intern(p, s.offset_from(p) as libc::c_long as strm_int);
            *h.offset(i as isize) = str;
            p = s.offset(1 as libc::c_int as isize);
        }
        if (p as libc::c_ulong) < rend as libc::c_ulong {
            *v
                .offset(
                    i as isize,
                ) = csv_value(
                p,
                rend.offset_from(p) as libc::c_long as strm_int,
                TYPE_UNSPC,
            );
        } else {
            str = strm_str_new(
                0 as *mut libc::c_void as *const libc::c_char,
                0 as libc::c_int,
            );
            *v.offset(i as isize) = str;
        }
        p = rend.offset(1 as libc::c_int as isize);
        i += 1;
    }
    tmp___9 = strm_ary_struct(ary);
    (*tmp___9).headers = hdr;
    strm_emit(
        strm,
        ary,
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn ltsv(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut t: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(strm, argc, args, b"\0" as *const u8 as *const libc::c_char);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    t = strm_stream_new(
        strm_filter,
        Some(
            ltsv_accept
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        0 as *mut libc::c_void,
    );
    *ret = strm_ptr_value(t as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_number(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut s: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"S\0" as *const u8 as *const libc::c_char,
        &mut s as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_str_len(s);
    tmp___1 = strm_strp_ptr(&mut s);
    s = csv_value(tmp___1, tmp___0, TYPE_NUM);
    tmp___2 = strm_number_p(s);
    if tmp___2 == 0 {
        strm_raise(
            strm,
            b"invalid string for number\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    *ret = s;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_csv_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            csv
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"csv\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            tsv
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"tsv\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_cfunc_value(
        Some(
            ltsv
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"ltsv\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            str_number
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_string,
        b"number\0" as *const u8 as *const libc::c_char,
        tmp___2,
    );
}
pub unsafe extern "C" fn cpu_count() -> libc::c_int {
    let mut tmp: libc::c_long = 0;
    tmp = sysconf(84 as libc::c_int);
    return tmp as libc::c_int;
}
pub static mut strm_ns_number: *mut strm_state = 0 as *const strm_state
    as *mut strm_state;
unsafe extern "C" fn num_plus(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: strm_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: libc::c_double = 0.;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"NN\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___2 = strm_int_p(x);
    if tmp___2 != 0 {
        tmp___3 = strm_int_p(y);
        if tmp___3 != 0 {
            tmp___0 = strm_value_int(x);
            tmp___1 = strm_value_int(y);
            *ret = strm_int_value(tmp___0 + tmp___1);
            return 0 as libc::c_int;
        }
    }
    tmp___6 = strm_number_p(x);
    if tmp___6 != 0 {
        tmp___7 = strm_number_p(y);
        if tmp___7 != 0 {
            tmp___4 = strm_value_float(x);
            tmp___5 = strm_value_float(y);
            *ret = strm_float_value(tmp___4 + tmp___5);
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn num_minus(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: strm_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_double = 0.;
    let mut tmp___2: libc::c_int = 0;
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: strm_int = 0;
    let mut tmp___5: strm_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_double = 0.;
    let mut tmp___9: libc::c_double = 0.;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        tmp___0 = strm_int_p(*args.offset(0 as libc::c_int as isize));
        if tmp___0 != 0 {
            tmp = strm_value_int(*args.offset(0 as libc::c_int as isize));
            *ret = strm_int_value(-tmp);
            return 0 as libc::c_int;
        }
        tmp___2 = strm_float_p(*args.offset(0 as libc::c_int as isize));
        if tmp___2 != 0 {
            tmp___1 = strm_value_float(*args.offset(0 as libc::c_int as isize));
            *ret = strm_float_value(-tmp___1);
            return 0 as libc::c_int;
        }
    } else {
        tmp___3 = strm_parse_args(
            strm,
            argc,
            args,
            b"NN\0" as *const u8 as *const libc::c_char,
            &mut x as *mut strm_value,
            &mut y as *mut strm_value,
        );
        if tmp___3 == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
        tmp___6 = strm_int_p(x);
        if tmp___6 != 0 {
            tmp___7 = strm_int_p(y);
            if tmp___7 != 0 {
                tmp___4 = strm_value_int(x);
                tmp___5 = strm_value_int(y);
                *ret = strm_int_value(tmp___4 - tmp___5);
                return 0 as libc::c_int;
            }
        }
        tmp___10 = strm_number_p(x);
        if tmp___10 != 0 {
            tmp___11 = strm_number_p(y);
            if tmp___11 != 0 {
                tmp___8 = strm_value_float(x);
                tmp___9 = strm_value_float(y);
                *ret = strm_float_value(tmp___8 - tmp___9);
                return 0 as libc::c_int;
            }
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn num_mult(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: strm_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_double = 0.;
    let mut tmp___5: libc::c_double = 0.;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"NN\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___2 = strm_int_p(x);
    if tmp___2 != 0 {
        tmp___3 = strm_int_p(y);
        if tmp___3 != 0 {
            tmp___0 = strm_value_int(x);
            tmp___1 = strm_value_int(y);
            *ret = strm_int_value(tmp___0 * tmp___1);
            return 0 as libc::c_int;
        }
    }
    tmp___4 = strm_value_float(x);
    tmp___5 = strm_value_float(y);
    *ret = strm_float_value(tmp___4 * tmp___5);
    return 0 as libc::c_int;
}
unsafe extern "C" fn num_div(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = strm_float_value(x / y);
    return 0 as libc::c_int;
}
unsafe extern "C" fn num_bar(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: strm_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ii\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_value_int(x);
    tmp___1 = strm_value_int(y);
    *ret = strm_int_value(tmp___0 | tmp___1);
    return 0 as libc::c_int;
}
unsafe extern "C" fn num_mod(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: strm_value = 0;
    let mut y: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_double = 0.;
    let mut tmp___3: libc::c_double = 0.;
    let mut tmp___4: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"Ni\0" as *const u8 as *const libc::c_char,
        &mut x as *mut strm_value,
        &mut y as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___1 = strm_int_p(x);
    if tmp___1 != 0 {
        tmp___0 = strm_value_int(x);
        *ret = strm_int_value(tmp___0 % y);
        return 0 as libc::c_int;
    }
    tmp___4 = strm_float_p(x);
    if tmp___4 != 0 {
        tmp___2 = strm_value_float(x);
        tmp___3 = fmod(tmp___2, y as libc::c_double);
        *ret = strm_float_value(tmp___3);
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn num_gt(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = strm_bool_value((x > y) as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn num_ge(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = strm_bool_value((x >= y) as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn num_lt(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = strm_bool_value((x < y) as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn num_le(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut x: libc::c_double = 0.;
    let mut y: libc::c_double = 0.;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"ff\0" as *const u8 as *const libc::c_char,
        &mut x as *mut libc::c_double,
        &mut y as *mut libc::c_double,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = strm_bool_value((x <= y) as libc::c_int);
    return 0 as libc::c_int;
}
unsafe extern "C" fn num_number(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"N\0" as *const u8 as *const libc::c_char,
        ret,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_number_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    let mut tmp___3: strm_value = 0;
    let mut tmp___4: strm_value = 0;
    let mut tmp___5: strm_value = 0;
    let mut tmp___6: strm_value = 0;
    let mut tmp___7: strm_value = 0;
    let mut tmp___8: strm_value = 0;
    let mut tmp___9: strm_value = 0;
    strm_ns_number = strm_ns_new(
        0 as *mut libc::c_void as *mut strm_state,
        b"number\0" as *const u8 as *const libc::c_char,
    );
    tmp = strm_cfunc_value(
        Some(
            num_plus
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b"+\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            num_minus
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b"-\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_cfunc_value(
        Some(
            num_mult
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b"*\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            num_div
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b"/\0" as *const u8 as *const libc::c_char, tmp___2);
    tmp___3 = strm_cfunc_value(
        Some(
            num_mod
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b"%\0" as *const u8 as *const libc::c_char, tmp___3);
    tmp___4 = strm_cfunc_value(
        Some(
            num_bar
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b"|\0" as *const u8 as *const libc::c_char, tmp___4);
    tmp___5 = strm_cfunc_value(
        Some(
            num_lt
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b"<\0" as *const u8 as *const libc::c_char, tmp___5);
    tmp___6 = strm_cfunc_value(
        Some(
            num_le
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b"<=\0" as *const u8 as *const libc::c_char, tmp___6);
    tmp___7 = strm_cfunc_value(
        Some(
            num_gt
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b">\0" as *const u8 as *const libc::c_char, tmp___7);
    tmp___8 = strm_cfunc_value(
        Some(
            num_ge
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_number, b">=\0" as *const u8 as *const libc::c_char, tmp___8);
    tmp___9 = strm_cfunc_value(
        Some(
            num_number
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"number\0" as *const u8 as *const libc::c_char, tmp___9);
}
unsafe extern "C" fn xorshift128init(mut seed: *mut uint32_t) {
    let mut tv: timeval = timeval { tv_sec: 0, tv_usec: 0 };
    let mut y: uint32_t = 0;
    let mut i: libc::c_int = 0;
    let mut fd: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut statbuf: stat = stat {
        st_dev: 0,
        st_ino: 0,
        st_nlink: 0,
        st_mode: 0,
        st_uid: 0,
        st_gid: 0,
        __pad0: 0,
        st_rdev: 0,
        st_size: 0,
        st_blksize: 0,
        st_blocks: 0,
        st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
        st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
        __glibc_reserved: [0; 3],
    };
    let mut ret: ssize_t = 0;
    let mut size: size_t = 0;
    let mut tmp___0: libc::c_int = 0;
    tmp = open(
        b"/dev/urandom\0" as *const u8 as *const libc::c_char,
        2304 as libc::c_int,
        0 as libc::c_int,
    );
    fd = tmp;
    if fd > 0 as libc::c_int {
        ret = 0 as libc::c_int as ssize_t;
        size = (::std::mem::size_of::<uint64_t>() as libc::c_ulong)
            .wrapping_mul(2 as libc::c_ulong);
        tmp___0 = fstat(fd, &mut statbuf);
        if tmp___0 == 0 as libc::c_int {
            if statbuf.st_mode & 61440 as libc::c_uint == 8192 as libc::c_uint {
                ret = read(fd, seed as *mut libc::c_void, size);
            }
        }
        close(fd);
        if ret as size_t == size {
            return;
        }
    }
    y = 2463534242 as libc::c_long as uint32_t;
    gettimeofday(&mut tv as *mut timeval, 0 as *mut libc::c_void);
    y ^= tv.tv_usec as uint32_t;
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        y ^= y << 13 as libc::c_int;
        y ^= y >> 17 as libc::c_int;
        y ^= y << 5 as libc::c_int;
        *seed.offset(i as isize) = y;
        i += 1;
    }
}
unsafe extern "C" fn xorshift128(mut seed: *mut uint32_t) -> uint32_t {
    let mut x: uint32_t = 0;
    let mut y: uint32_t = 0;
    let mut z: uint32_t = 0;
    let mut w: uint32_t = 0;
    let mut t: uint32_t = 0;
    x = *seed.offset(0 as libc::c_int as isize);
    y = *seed.offset(1 as libc::c_int as isize);
    z = *seed.offset(2 as libc::c_int as isize);
    w = *seed.offset(3 as libc::c_int as isize);
    t = x ^ x << 11 as libc::c_int;
    x = y;
    y = z;
    z = w;
    w = w ^ w >> 19 as libc::c_int ^ (t ^ t >> 8 as libc::c_int);
    *seed.offset(0 as libc::c_int as isize) = x;
    *seed.offset(1 as libc::c_int as isize) = y;
    *seed.offset(2 as libc::c_int as isize) = z;
    *seed.offset(3 as libc::c_int as isize) = w;
    return w;
}
unsafe extern "C" fn rand_float(mut seed: *mut uint32_t) -> libc::c_double {
    let mut tmp: uint32_t = 0;
    tmp = xorshift128(seed);
    return tmp as libc::c_double * (1.0f64 / 4294967295.0f64);
}
unsafe extern "C" fn gen_rand(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut rand_data = 0 as *mut rand_data;
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: strm_value = 0;
    d = (*strm).data as *mut rand_data;
    tmp = rand_float(((*d).seed).as_mut_ptr());
    f = tmp;
    tmp___0 = strm_float_value(f);
    strm_emit(
        strm,
        tmp___0,
        Some(
            gen_rand as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_rand(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut rand_data = 0 as *mut rand_data;
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"|s\0" as *const u8 as *const libc::c_char,
        &mut s as *mut *const libc::c_char,
        &mut len as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<rand_data>() as libc::c_ulong);
    d = tmp___0 as *mut rand_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    if argc == 2 as libc::c_int {
        if len as libc::c_ulong
            != ::std::mem::size_of::<[uint32_t; 4]>() as libc::c_ulong
        {
            strm_raise(strm, b"seed size differ\0" as *const u8 as *const libc::c_char);
            free(d as *mut libc::c_void);
            return 1 as libc::c_int;
        }
        memcpy(
            ((*d).seed).as_mut_ptr() as *mut libc::c_void,
            s as *const libc::c_void,
            len as size_t,
        );
    } else {
        xorshift128init(((*d).seed).as_mut_ptr());
    }
    tmp___1 = strm_stream_new(
        strm_producer,
        Some(
            gen_rand as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn rand_seed(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut seed: [uint32_t; 4] = [0; 4];
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(strm, argc, args, b"\0" as *const u8 as *const libc::c_char);
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    xorshift128init(seed.as_mut_ptr());
    *ret = strm_str_new(
        seed.as_mut_ptr() as *const libc::c_char,
        ::std::mem::size_of::<[uint32_t; 4]>() as libc::c_ulong as strm_int,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn rand_normal(mut d: *mut rnorm_data) -> libc::c_double {
    let mut u: libc::c_double = 0.;
    let mut v: libc::c_double = 0.;
    let mut s: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: libc::c_double = 0.;
    let mut tmp___1: libc::c_double = 0.;
    if (*d).has_spare != 0 {
        (*d).has_spare = 0 as libc::c_int;
        return (*d).spare;
    }
    (*d).has_spare = 1 as libc::c_int;
    loop {
        tmp = rand_float(((*d).seed).as_mut_ptr());
        u = tmp * 2.0f64 - 1.0f64;
        tmp___0 = rand_float(((*d).seed).as_mut_ptr());
        v = tmp___0 * 2.0f64 - 1.0f64;
        s = u * u + v * v;
        if s >= 1.0f64 {
            continue;
        }
        if !(s == 0.0f64) {
            break;
        }
    }
    tmp___1 = log(s);
    s = sqrt(-2.0f64 * tmp___1 / s);
    (*d).spare = v * s;
    return u * s;
}
unsafe extern "C" fn gen_rnorm(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut rnorm_data = 0 as *mut rnorm_data;
    let mut f: libc::c_double = 0.;
    let mut tmp: libc::c_double = 0.;
    let mut tmp___0: strm_value = 0;
    d = (*strm).data as *mut rnorm_data;
    tmp = rand_normal(d);
    f = tmp;
    tmp___0 = strm_float_value(f);
    strm_emit(
        strm,
        tmp___0,
        Some(
            gen_rnorm
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_rnorm(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut rnorm_data = 0 as *mut rnorm_data;
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut len: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"|s\0" as *const u8 as *const libc::c_char,
        &mut s as *mut *const libc::c_char,
        &mut len as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(::std::mem::size_of::<rnorm_data>() as libc::c_ulong);
    d = tmp___0 as *mut rnorm_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    if argc == 2 as libc::c_int {
        if len as libc::c_ulong
            != ::std::mem::size_of::<[uint32_t; 4]>() as libc::c_ulong
        {
            strm_raise(strm, b"seed size differ\0" as *const u8 as *const libc::c_char);
            free(d as *mut libc::c_void);
            return 1 as libc::c_int;
        }
        memcpy(
            ((*d).seed).as_mut_ptr() as *mut libc::c_void,
            s as *const libc::c_void,
            len as size_t,
        );
    } else {
        xorshift128init(((*d).seed).as_mut_ptr());
    }
    (*d).has_spare = 0 as libc::c_int;
    tmp___1 = strm_stream_new(
        strm_producer,
        Some(
            gen_rnorm
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        ::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int>,
        >(0 as *mut libc::c_void),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn iter_sample(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sample_data = 0 as *mut sample_data;
    let mut r: uint32_t = 0;
    let mut tmp: strm_int = 0;
    let mut tmp___0: uint32_t = 0;
    d = (*strm).data as *mut sample_data;
    if (*d).i < (*d).len {
        tmp = (*d).i;
        (*d).i += 1;
        *((*d).samples).as_mut_ptr().offset(tmp as isize) = data;
        return 0 as libc::c_int;
    }
    tmp___0 = xorshift128(((*d).seed).as_mut_ptr());
    r = tmp___0.wrapping_rem((*d).i as libc::c_uint);
    if r < (*d).len as uint32_t {
        *((*d).samples).as_mut_ptr().offset(r as isize) = data;
    }
    (*d).i += 1;
    return 0 as libc::c_int;
}
unsafe extern "C" fn finish_sample(
    mut strm: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut d: *mut sample_data = 0 as *mut sample_data;
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    d = (*strm).data as *mut sample_data;
    len = (*d).len;
    i = 0 as libc::c_int;
    while i < len {
        strm_emit(
            strm,
            *((*d).samples).as_mut_ptr().offset(i as isize),
            ::std::mem::transmute::<
                *mut libc::c_void,
                Option::<
                    unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
                >,
            >(0 as *mut libc::c_void),
        );
        i += 1;
    }
    free(d as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn exec_sample(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut d: *mut sample_data = 0 as *mut sample_data;
    let mut len: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: *mut strm_stream = 0 as *mut strm_stream;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"i\0" as *const u8 as *const libc::c_char,
        &mut len as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = malloc(
        (::std::mem::size_of::<sample_data>() as libc::c_ulong)
            .wrapping_add(
                (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                    .wrapping_mul(len as libc::c_ulong),
            ),
    );
    d = tmp___0 as *mut sample_data;
    if d.is_null() {
        return 1 as libc::c_int;
    }
    (*d).len = len;
    (*d).i = 0 as libc::c_int;
    xorshift128init(((*d).seed).as_mut_ptr());
    tmp___1 = strm_stream_new(
        strm_filter,
        Some(
            iter_sample
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            finish_sample
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        d as *mut libc::c_void,
    );
    *ret = strm_ptr_value(tmp___1 as *mut libc::c_void);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_rand_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            rand_seed
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"rand_seed\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            exec_rand
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"rand\0" as *const u8 as *const libc::c_char, tmp___0);
    tmp___1 = strm_cfunc_value(
        Some(
            exec_rnorm
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"rand_norm\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            exec_sample
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"sample\0" as *const u8 as *const libc::c_char, tmp___2);
}
pub static mut sig_list: *mut sig_list = 0 as *const sig_list as *mut sig_list;
unsafe extern "C" fn handler(mut sig: libc::c_int) {
    let mut list: *mut sig_list = 0 as *mut sig_list;
    list = sig_list;
    while !list.is_null() {
        if (*list).sig == sig {
            (Some(((*list).func).expect("non-null function pointer")))
                .expect("non-null function pointer")(sig, (*list).arg);
        }
        list = (*list).next;
    }
}
unsafe extern "C" fn sigcall(mut sig: libc::c_int, mut f: *mut libc::c_void) {
    (Some(
        (::std::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
        >(f))
            .expect("non-null function pointer"),
    ))
        .expect("non-null function pointer")(sig);
}
unsafe extern "C" fn add_sig(
    mut sig: libc::c_int,
    mut func: Option::<unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> ()>,
    mut arg: *mut libc::c_void,
) -> libc::c_int {
    let mut node: *mut sig_list = 0 as *mut sig_list;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(::std::mem::size_of::<sig_list>() as libc::c_ulong);
    node = tmp as *mut sig_list;
    if node as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return 1 as libc::c_int;
    }
    (*node).next = sig_list;
    (*node).sig = sig;
    (*node).func = func;
    (*node).arg = arg;
    sig_list = node;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_signal(
    mut sig: libc::c_int,
    mut func: Option::<unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> ()>,
    mut arg: *mut libc::c_void,
) -> libc::c_int {
    let mut r: Option::<unsafe extern "C" fn(libc::c_int) -> ()> = None;
    let mut tmp: __sighandler_t = None;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    tmp = signal(
        sig,
        ::std::mem::transmute::<
            libc::intptr_t,
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
        >(1 as libc::c_int as libc::intptr_t),
    );
    r = tmp;
    if ::std::mem::transmute::<
        Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
        libc::c_ulong,
    >(r)
        == ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
            libc::c_ulong,
        >(
            ::std::mem::transmute::<
                libc::intptr_t,
                Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
            >(-(1 as libc::c_int) as libc::intptr_t),
        )
    {
        return 1 as libc::c_int;
    }
    if r.is_some() {
        if ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
            libc::c_ulong,
        >(r)
            != ::std::mem::transmute::<
                Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
                libc::c_ulong,
            >(Some(handler as unsafe extern "C" fn(libc::c_int) -> ()))
        {
            tmp___0 = add_sig(
                sig,
                Some(
                    sigcall as unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> (),
                ),
                ::std::mem::transmute::<
                    Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
                    *mut libc::c_void,
                >(r),
            );
            if tmp___0 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
        }
    }
    tmp___1 = add_sig(sig, func, arg);
    if tmp___1 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    r = signal(sig, Some(handler as unsafe extern "C" fn(libc::c_int) -> ()));
    if ::std::mem::transmute::<
        Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
        libc::c_ulong,
    >(r)
        == ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
            libc::c_ulong,
        >(
            ::std::mem::transmute::<
                libc::intptr_t,
                Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
            >(-(1 as libc::c_int) as libc::intptr_t),
        )
    {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_unsignal(
    mut sig: libc::c_int,
    mut func: Option::<unsafe extern "C" fn(libc::c_int, *mut libc::c_void) -> ()>,
) -> libc::c_int {
    let mut r: Option::<unsafe extern "C" fn(libc::c_int) -> ()> = None;
    let mut tmp: __sighandler_t = None;
    let mut list: *mut sig_list = 0 as *mut sig_list;
    let mut tmp___0: *mut sig_list = 0 as *mut sig_list;
    tmp = signal(
        sig,
        ::std::mem::transmute::<
            libc::intptr_t,
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
        >(1 as libc::c_int as libc::intptr_t),
    );
    r = tmp;
    tmp___0 = 0 as *mut libc::c_void as *mut sig_list;
    if ::std::mem::transmute::<
        Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
        libc::c_ulong,
    >(r)
        == ::std::mem::transmute::<
            Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
            libc::c_ulong,
        >(
            ::std::mem::transmute::<
                libc::intptr_t,
                Option::<unsafe extern "C" fn(libc::c_int) -> ()>,
            >(-(1 as libc::c_int) as libc::intptr_t),
        )
    {
        return 1 as libc::c_int;
    }
    list = sig_list;
    while !list.is_null() {
        if (*list).sig == sig {
            if tmp___0 as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
                sig_list = (*list).next;
            } else {
                (*tmp___0).next = (*list).next;
                tmp___0 = list;
            }
        }
        list = (*list).next;
    }
    signal(sig, Some(handler as unsafe extern "C" fn(libc::c_int) -> ()));
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_parse_args(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut argv: *mut strm_value,
    mut format: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut c: libc::c_char = 0;
    let mut i: libc::c_int = 0;
    let mut ap: ::std::ffi::VaListImpl;
    let mut arg_i: libc::c_int = 0;
    let mut opt: strm_int = 0;
    let mut given: strm_int = 0;
    let mut p: *mut strm_value = 0 as *mut strm_value;
    let mut tmp: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___0: libc::c_int = 0;
    let mut p___0: *mut strm_value = 0 as *mut strm_value;
    let mut tmp___1: *mut strm_value = 0 as *mut strm_value;
    let mut nn: strm_value = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut ss: strm_value = 0;
    let mut p___1: *mut strm_string = 0 as *mut strm_string;
    let mut tmp___4: *mut strm_string = 0 as *mut strm_string;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut ss___0: strm_value = 0;
    let mut ps: *mut *const libc::c_char = 0 as *mut *const libc::c_char;
    let mut pl: *mut strm_int = 0 as *mut strm_int;
    let mut tmp___7: *mut *const libc::c_char = 0 as *mut *const libc::c_char;
    let mut tmp___8: *mut strm_int = 0 as *mut strm_int;
    let mut tmp___9: libc::c_int = 0;
    let mut p___2: *mut strm_array = 0 as *mut strm_array;
    let mut v: strm_value = 0;
    let mut tmp___10: *mut strm_array = 0 as *mut strm_array;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut aa: strm_array = 0;
    let mut pb: *mut *mut strm_value = 0 as *mut *mut strm_value;
    let mut pl___0: *mut strm_int = 0 as *mut strm_int;
    let mut tmp___13: *mut *mut strm_value = 0 as *mut *mut strm_value;
    let mut tmp___14: *mut strm_int = 0 as *mut strm_int;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___19: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut p___3: *mut libc::c_double = 0 as *mut libc::c_double;
    let mut ff: strm_value = 0;
    let mut tmp___20: *mut libc::c_double = 0 as *mut libc::c_double;
    let mut tmp___21: libc::c_int = 0;
    let mut tmp___22: libc::c_int = 0;
    let mut p___4: *mut strm_int = 0 as *mut strm_int;
    let mut ff___0: strm_value = 0;
    let mut tmp___23: *mut strm_int = 0 as *mut strm_int;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: libc::c_int = 0;
    let mut p___5: *mut strm_int = 0 as *mut strm_int;
    let mut bb: strm_int = 0;
    let mut tmp___26: *mut strm_int = 0 as *mut strm_int;
    let mut tmp___27: libc::c_int = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut p___6: *mut strm_int = 0 as *mut strm_int;
    let mut tmp___29: *mut strm_int = 0 as *mut strm_int;
    let mut tmp___30: *const libc::c_char = 0 as *const libc::c_char;
    i = 0 as libc::c_int;
    arg_i = 0 as libc::c_int;
    opt = 0 as libc::c_int;
    given = 1 as libc::c_int;
    ap = args.clone();
    loop {
        tmp___30 = format;
        format = format.offset(1);
        c = *tmp___30;
        if c == 0 {
            break;
        }
        match c as libc::c_int {
            63 | 38 | 42 | 124 => {}
            _ => {
                if argc <= i {
                    if opt != 0 {
                        given = 0 as libc::c_int;
                    } else {
                        strm_raise(
                            strm,
                            b"wrong number of arguments\0" as *const u8
                                as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                }
            }
        }
        match c as libc::c_int {
            118 => {
                tmp = ap.arg::<*mut strm_value>();
                p = tmp;
                if i < argc {
                    tmp___0 = arg_i;
                    arg_i += 1;
                    *p = *argv.offset(tmp___0 as isize);
                    i += 1;
                }
            }
            78 => {
                tmp___1 = ap.arg::<*mut strm_value>();
                p___0 = tmp___1;
                if i < argc {
                    tmp___2 = arg_i;
                    arg_i += 1;
                    nn = *argv.offset(tmp___2 as isize);
                    tmp___3 = strm_number_p(nn);
                    if tmp___3 == 0 {
                        strm_raise(
                            strm,
                            b"number required\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    *p___0 = nn;
                    i += 1;
                }
            }
            83 => {
                tmp___4 = ap.arg::<*mut strm_string>();
                p___1 = tmp___4;
                if i < argc {
                    tmp___5 = arg_i;
                    arg_i += 1;
                    ss = *argv.offset(tmp___5 as isize);
                    i += 1;
                    tmp___6 = strm_string_p(ss);
                    if tmp___6 == 0 {
                        strm_raise(
                            strm,
                            b"string required\0" as *const u8 as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                    *p___1 = ss;
                }
            }
            115 => {
                tmp___7 = ap.arg::<*mut *const libc::c_char>();
                ps = tmp___7;
                tmp___8 = ap.arg::<*mut strm_int>();
                pl = tmp___8;
                if i < argc {
                    ss___0 = *argv.offset(arg_i as isize);
                    tmp___9 = strm_string_p(ss___0);
                    if tmp___9 == 0 {
                        strm_raise(
                            strm,
                            b"string required\0" as *const u8 as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                    *ps = strm_strp_ptr(argv.offset(arg_i as isize));
                    *pl = strm_str_len(ss___0);
                    i += 1;
                    arg_i += 1;
                }
            }
            65 => {
                tmp___10 = ap.arg::<*mut strm_array>();
                p___2 = tmp___10;
                if i < argc {
                    tmp___11 = arg_i;
                    arg_i += 1;
                    v = *argv.offset(tmp___11 as isize);
                    i += 1;
                    tmp___12 = strm_array_p(v);
                    if tmp___12 == 0 {
                        strm_raise(
                            strm,
                            b"array required\0" as *const u8 as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                    *p___2 = v;
                }
            }
            97 => {
                tmp___13 = ap.arg::<*mut *mut strm_value>();
                pb = tmp___13;
                tmp___14 = ap.arg::<*mut strm_int>();
                pl___0 = tmp___14;
                if i < argc {
                    tmp___15 = arg_i;
                    arg_i += 1;
                    aa = *argv.offset(tmp___15 as isize);
                    i += 1;
                    tmp___16 = strm_nil_p(aa);
                    if tmp___16 != 0 {
                        *pb = 0 as *mut libc::c_void as *mut strm_value;
                        *pl___0 = 0 as libc::c_int;
                    } else {
                        tmp___17 = strm_array_p(aa);
                        if tmp___17 == 0 {
                            strm_raise(
                                strm,
                                b"array required\0" as *const u8 as *const libc::c_char,
                            );
                            return 1 as libc::c_int;
                        }
                        tmp___18 = strm_ary_struct(aa);
                        *pb = (*tmp___18).ptr;
                        tmp___19 = strm_ary_struct(aa);
                        *pl___0 = (*tmp___19).len;
                    }
                }
            }
            102 => {
                tmp___20 = ap.arg::<*mut libc::c_double>();
                p___3 = tmp___20;
                if i < argc {
                    tmp___21 = arg_i;
                    arg_i += 1;
                    ff = *argv.offset(tmp___21 as isize);
                    i += 1;
                    tmp___22 = strm_number_p(ff);
                    if tmp___22 == 0 {
                        strm_raise(
                            strm,
                            b"number required\0" as *const u8 as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                    *p___3 = strm_value_float(ff);
                }
            }
            105 => {
                tmp___23 = ap.arg::<*mut strm_int>();
                p___4 = tmp___23;
                if i < argc {
                    tmp___24 = arg_i;
                    arg_i += 1;
                    ff___0 = *argv.offset(tmp___24 as isize);
                    i += 1;
                    tmp___25 = strm_number_p(ff___0);
                    if tmp___25 == 0 {
                        strm_raise(
                            strm,
                            b"number required\0" as *const u8 as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                    *p___4 = strm_value_int(ff___0);
                }
            }
            98 => {
                tmp___26 = ap.arg::<*mut strm_int>();
                p___5 = tmp___26;
                if i < argc {
                    tmp___27 = arg_i;
                    arg_i += 1;
                    bb = *argv.offset(tmp___27 as isize) as strm_int;
                    i += 1;
                    tmp___28 = strm_bool_p(bb as strm_value);
                    if tmp___28 == 0 {
                        strm_raise(
                            strm,
                            b"boolean required\0" as *const u8 as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                    *p___5 = strm_value_bool(bb as strm_value);
                }
            }
            124 => {
                opt = 1 as libc::c_int;
            }
            63 => {
                tmp___29 = ap.arg::<*mut strm_int>();
                p___6 = tmp___29;
                *p___6 = given;
            }
            _ => {
                strm_raise(
                    strm,
                    b"invalid argument specifier\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    if c == 0 {
        if argc > i {
            strm_raise(
                strm,
                b"wrong number of arguments\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn accept_cb(
    mut task: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut sd: *mut socket_data = 0 as *mut socket_data;
    let mut writer_addr: sockaddr_in = sockaddr_in {
        sin_family: 0,
        sin_port: 0,
        sin_addr: in_addr { s_addr: 0 },
        sin_zero: [0; 8],
    };
    let mut writer_len: socklen_t = 0;
    let mut sock: libc::c_int = 0;
    let mut tmp: strm_value = 0;
    sd = (*task).data as *mut socket_data;
    memset(
        &mut writer_addr as *mut sockaddr_in as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong,
    );
    writer_len = ::std::mem::size_of::<sockaddr_in>() as libc::c_ulong as socklen_t;
    sock = accept(
        (*sd).sock,
        &mut writer_addr as *mut sockaddr_in as *mut sockaddr,
        &mut writer_len as *mut socklen_t,
    );
    if sock < 0 as libc::c_int {
        close(sock);
        strm_raise(task, b"socket error: listen\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp = strm_io_new(sock, 7 as libc::c_int);
    strm_io_emit(
        task,
        tmp,
        (*sd).sock,
        Some(
            accept_cb
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn server_accept(
    mut task: *mut strm_stream,
    mut data: strm_value,
) -> libc::c_int {
    let mut sd: *mut socket_data = 0 as *mut socket_data;
    sd = (*task).data as *mut socket_data;
    strm_io_start_read(
        task,
        (*sd).sock,
        Some(
            accept_cb
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn server_close(
    mut task: *mut strm_stream,
    mut d: strm_value,
) -> libc::c_int {
    let mut sd: *mut socket_data = 0 as *mut socket_data;
    sd = (*task).data as *mut socket_data;
    close((*sd).sock);
    free(sd as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn tcp_server(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut hints: addrinfo = addrinfo {
        ai_flags: 0,
        ai_family: 0,
        ai_socktype: 0,
        ai_protocol: 0,
        ai_addrlen: 0,
        ai_addr: 0 as *mut sockaddr,
        ai_canonname: 0 as *mut libc::c_char,
        ai_next: 0 as *mut addrinfo,
    };
    let mut result: *mut addrinfo = 0 as *mut addrinfo;
    let mut rp: *mut addrinfo = 0 as *mut addrinfo;
    let mut sock: libc::c_int = 0;
    let mut s: libc::c_int = 0;
    let mut srv: strm_value = 0;
    let mut service: *const libc::c_char = 0 as *const libc::c_char;
    let mut buf: [libc::c_char; 12] = [0; 12];
    let mut sd: *mut socket_data = 0 as *mut socket_data;
    let mut t: *mut strm_stream = 0 as *mut strm_stream;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut str: strm_string = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"v\0" as *const u8 as *const libc::c_char,
        &mut srv as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___1 = strm_number_p(srv);
    if tmp___1 != 0 {
        tmp___0 = strm_value_int(srv);
        sprintf(buf.as_mut_ptr(), b"%d\0" as *const u8 as *const libc::c_char, tmp___0);
        service = buf.as_mut_ptr() as *const libc::c_char;
    } else {
        str = srv;
        service = strm_str_cstr(str, buf.as_mut_ptr());
    }
    memset(
        &mut hints as *mut addrinfo as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<addrinfo>() as libc::c_ulong,
    );
    hints.ai_family = 0 as libc::c_int;
    hints.ai_socktype = 1 as libc::c_int;
    hints.ai_flags = 1 as libc::c_int;
    hints.ai_protocol = 0 as libc::c_int;
    loop {
        s = getaddrinfo(
            0 as *mut libc::c_void as *const libc::c_char,
            service,
            &mut hints as *mut addrinfo as *const addrinfo,
            &mut result as *mut *mut addrinfo,
        );
        if !(s != 0 as libc::c_int) {
            break;
        }
        if s == -(3 as libc::c_int) {
            continue;
        }
        tmp___2 = gai_strerror(s);
        strm_raise(strm, tmp___2);
        return 1 as libc::c_int;
    }
    rp = result;
    while rp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        sock = socket((*rp).ai_family, (*rp).ai_socktype, (*rp).ai_protocol);
        if !(sock == -(1 as libc::c_int)) {
            tmp___3 = bind(sock, (*rp).ai_addr as *const sockaddr, (*rp).ai_addrlen);
            if tmp___3 == 0 as libc::c_int {
                break;
            }
            close(sock);
        }
        rp = (*rp).ai_next;
    }
    freeaddrinfo(result);
    if rp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        strm_raise(strm, b"socket error: bind\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___4 = listen(sock, 5 as libc::c_int);
    if tmp___4 < 0 as libc::c_int {
        close(sock);
        strm_raise(strm, b"socket error: listen\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    tmp___5 = malloc(::std::mem::size_of::<socket_data>() as libc::c_ulong);
    sd = tmp___5 as *mut socket_data;
    (*sd).sock = sock;
    t = strm_stream_new(
        strm_producer,
        Some(
            server_accept
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        Some(
            server_close
                as unsafe extern "C" fn(*mut strm_stream, strm_value) -> libc::c_int,
        ),
        sd as *mut libc::c_void,
    );
    *ret = strm_ptr_value(t as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn tcp_socket(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut hints: addrinfo = addrinfo {
        ai_flags: 0,
        ai_family: 0,
        ai_socktype: 0,
        ai_protocol: 0,
        ai_addrlen: 0,
        ai_addr: 0 as *mut sockaddr,
        ai_canonname: 0 as *mut libc::c_char,
        ai_next: 0 as *mut addrinfo,
    };
    let mut result: *mut addrinfo = 0 as *mut addrinfo;
    let mut rp: *mut addrinfo = 0 as *mut addrinfo;
    let mut sock: libc::c_int = 0;
    let mut s: libc::c_int = 0;
    let mut service: *const libc::c_char = 0 as *const libc::c_char;
    let mut sbuf: [libc::c_char; 12] = [0; 12];
    let mut hbuf: [libc::c_char; 7] = [0; 7];
    let mut host: strm_string = 0;
    let mut srv: strm_value = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut str: strm_string = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"Sv\0" as *const u8 as *const libc::c_char,
        &mut host as *mut strm_string,
        &mut srv as *mut strm_value,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___1 = strm_number_p(srv);
    if tmp___1 != 0 {
        tmp___0 = strm_value_int(srv);
        sprintf(sbuf.as_mut_ptr(), b"%d\0" as *const u8 as *const libc::c_char, tmp___0);
        service = sbuf.as_mut_ptr() as *const libc::c_char;
    } else {
        str = srv;
        service = strm_str_cstr(str, sbuf.as_mut_ptr());
    }
    memset(
        &mut hints as *mut addrinfo as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<addrinfo>() as libc::c_ulong,
    );
    hints.ai_family = 0 as libc::c_int;
    hints.ai_socktype = 1 as libc::c_int;
    hints.ai_protocol = 0 as libc::c_int;
    tmp___2 = strm_str_cstr(host, hbuf.as_mut_ptr());
    s = getaddrinfo(
        tmp___2,
        service,
        &mut hints as *mut addrinfo as *const addrinfo,
        &mut result as *mut *mut addrinfo,
    );
    if s != 0 as libc::c_int {
        tmp___3 = gai_strerror(s);
        strm_raise(strm, tmp___3);
        return 1 as libc::c_int;
    }
    rp = result;
    while rp as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong {
        sock = socket((*rp).ai_family, (*rp).ai_socktype, (*rp).ai_protocol);
        if !(sock == -(1 as libc::c_int)) {
            tmp___4 = connect(sock, (*rp).ai_addr as *const sockaddr, (*rp).ai_addrlen);
            if tmp___4 != -(1 as libc::c_int) {
                break;
            }
            close(sock);
        }
        rp = (*rp).ai_next;
    }
    freeaddrinfo(result);
    if rp as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        strm_raise(strm, b"socket error: connect\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    }
    *ret = strm_io_new(sock, 7 as libc::c_int);
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_socket_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    tmp = strm_cfunc_value(
        Some(
            tcp_server
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"tcp_server\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            tcp_socket
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(state, b"tcp_socket\0" as *const u8 as *const libc::c_char, tmp___0);
}
pub static mut strm_ns_string: *mut strm_state = 0 as *const strm_state
    as *mut strm_state;
static mut khash_ac_HASH_UPPER___3: libc::c_double = 0.77f64;
#[inline]
unsafe extern "C" fn readonly_data_p(mut p: *const libc::c_char) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    if (_etext.as_mut_ptr() as libc::c_ulong) < p as libc::c_ulong {
        if (p as libc::c_ulong)
            < &mut __init_array_start as *mut [libc::c_char; 0] as *mut libc::c_char
                as libc::c_ulong
        {
            tmp = 1 as libc::c_int;
        } else {
            tmp = 0 as libc::c_int;
        }
    } else {
        tmp = 0 as libc::c_int;
    }
    return tmp;
}
unsafe extern "C" fn sym_hash(mut key: sym_key) -> khint_t {
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut h: khint_t = 0;
    let mut len: strm_int = 0;
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___0: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___1: strm_int = 0;
    s = key.ptr;
    len = key.len;
    tmp = s;
    s = s.offset(1);
    h = *tmp as khint_t;
    loop {
        tmp___1 = len;
        len -= 1;
        if tmp___1 == 0 {
            break;
        }
        tmp___0 = s;
        s = s.offset(1);
        h = (h << 5 as libc::c_int).wrapping_sub(h).wrapping_add(*tmp___0 as khint_t);
    }
    return h;
}
unsafe extern "C" fn sym_eq(mut a: sym_key, mut b: sym_key) -> khint_t {
    let mut tmp: libc::c_int = 0;
    if a.len != b.len {
        return 0 as libc::c_int as khint_t;
    }
    tmp = memcmp(
        a.ptr as *const libc::c_void,
        b.ptr as *const libc::c_void,
        a.len as size_t,
    );
    if tmp == 0 as libc::c_int {
        return 1 as libc::c_int as khint_t;
    }
    return 0 as libc::c_int as khint_t;
}
#[inline]
unsafe extern "C" fn kh_init_sym() -> *mut kh_sym_t {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = calloc(
        1 as libc::c_int as size_t,
        ::std::mem::size_of::<kh_sym_t>() as libc::c_ulong,
    );
    return tmp as *mut kh_sym_t;
}
#[inline]
unsafe extern "C" fn kh_resize_sym(
    mut h: *mut kh_sym_t,
    mut new_n_buckets: khint_t,
) -> libc::c_int {
    let mut new_flags: *mut khint32_t = 0 as *mut khint32_t;
    let mut j: khint_t = 0;
    let mut tmp: khint_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: khint_t = 0;
    let mut new_keys: *mut sym_key = 0 as *mut sym_key;
    let mut tmp___2: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut new_vals: *mut strm_string = 0 as *mut strm_string;
    let mut tmp___3: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut key: sym_key = sym_key {
        ptr: 0 as *const libc::c_char,
        len: 0,
    };
    let mut val: strm_string = 0;
    let mut new_mask: khint_t = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp___4: sym_key = sym_key {
        ptr: 0 as *const libc::c_char,
        len: 0,
    };
    let mut tmp___5: strm_string = 0;
    let mut tmp___6: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___7: *mut libc::c_void = 0 as *mut libc::c_void;
    new_flags = 0 as *mut khint32_t;
    j = 1 as libc::c_int as khint_t;
    new_n_buckets = new_n_buckets.wrapping_sub(1);
    new_n_buckets |= new_n_buckets >> 1 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 2 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 4 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 8 as libc::c_int;
    new_n_buckets |= new_n_buckets >> 16 as libc::c_int;
    new_n_buckets = new_n_buckets.wrapping_add(1);
    if new_n_buckets < 4 as libc::c_uint {
        new_n_buckets = 4 as libc::c_int as khint_t;
    }
    if (*h).size
        >= (new_n_buckets as libc::c_double * khash_ac_HASH_UPPER___3 + 0.5f64)
            as khint_t
    {
        j = 0 as libc::c_int as khint_t;
    } else {
        if new_n_buckets < 16 as libc::c_uint {
            tmp = 1 as libc::c_int as khint_t;
        } else {
            tmp = new_n_buckets >> 4 as libc::c_int;
        }
        tmp___0 = malloc(
            (tmp as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        new_flags = tmp___0 as *mut khint32_t;
        if new_flags.is_null() {
            return -(1 as libc::c_int);
        }
        if new_n_buckets < 16 as libc::c_uint {
            tmp___1 = 1 as libc::c_int as khint_t;
        } else {
            tmp___1 = new_n_buckets >> 4 as libc::c_int;
        }
        memset(
            new_flags as *mut libc::c_void,
            170 as libc::c_int,
            (tmp___1 as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<khint32_t>() as libc::c_ulong),
        );
        if (*h).n_buckets < new_n_buckets {
            tmp___2 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<sym_key>() as libc::c_ulong),
            );
            new_keys = tmp___2 as *mut sym_key;
            if new_keys.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).keys = new_keys;
            tmp___3 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_string>() as libc::c_ulong),
            );
            new_vals = tmp___3 as *mut strm_string;
            if new_vals.is_null() {
                free(new_flags as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            (*h).vals = new_vals;
        }
    }
    if j != 0 {
        j = 0 as libc::c_int as khint_t;
        while j != (*h).n_buckets {
            if *((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                >> ((j & 15 as libc::c_uint) << 1 as libc::c_int) & 3 as libc::c_uint
                == 0 as libc::c_uint
            {
                key = *((*h).keys).offset(j as isize);
                new_mask = new_n_buckets.wrapping_sub(1 as libc::c_uint);
                val = *((*h).vals).offset(j as isize);
                *((*h).flags)
                    .offset(
                        (j >> 4 as libc::c_int) as isize,
                    ) = (*((*h).flags).offset((j >> 4 as libc::c_int) as isize)
                    as libc::c_ulong
                    | (1 as libc::c_ulong)
                        << ((j & 15 as libc::c_uint) << 1 as libc::c_int)) as khint32_t;
                loop {
                    step = 0 as libc::c_int as khint_t;
                    k = sym_hash(key);
                    i = k & new_mask;
                    while *new_flags.offset((i >> 4 as libc::c_int) as isize)
                        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                        & 2 as libc::c_uint == 0
                    {
                        step = step.wrapping_add(1);
                        i = i.wrapping_add(step) & new_mask;
                    }
                    *new_flags
                        .offset(
                            (i >> 4 as libc::c_int) as isize,
                        ) = (*new_flags.offset((i >> 4 as libc::c_int) as isize)
                        as libc::c_ulong
                        & !((2 as libc::c_ulong)
                            << ((i & 15 as libc::c_uint) << 1 as libc::c_int)))
                        as khint32_t;
                    if i < (*h).n_buckets {
                        if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int)
                            & 3 as libc::c_uint == 0 as libc::c_uint
                        {
                            tmp___4 = *((*h).keys).offset(i as isize);
                            *((*h).keys).offset(i as isize) = key;
                            key = tmp___4;
                            tmp___5 = *((*h).vals).offset(i as isize);
                            *((*h).vals).offset(i as isize) = val;
                            val = tmp___5;
                            *((*h).flags)
                                .offset(
                                    (i >> 4 as libc::c_int) as isize,
                                ) = (*((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                                as libc::c_ulong
                                | (1 as libc::c_ulong)
                                    << ((i & 15 as libc::c_uint) << 1 as libc::c_int))
                                as khint32_t;
                        } else {
                            *((*h).keys).offset(i as isize) = key;
                            *((*h).vals).offset(i as isize) = val;
                            break;
                        }
                    } else {
                        *((*h).keys).offset(i as isize) = key;
                        *((*h).vals).offset(i as isize) = val;
                        break;
                    }
                }
            }
            j = j.wrapping_add(1);
        }
        if (*h).n_buckets > new_n_buckets {
            tmp___6 = realloc(
                (*h).keys as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<sym_key>() as libc::c_ulong),
            );
            (*h).keys = tmp___6 as *mut sym_key;
            tmp___7 = realloc(
                (*h).vals as *mut libc::c_void,
                (new_n_buckets as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<strm_string>() as libc::c_ulong),
            );
            (*h).vals = tmp___7 as *mut strm_string;
        }
        free((*h).flags as *mut libc::c_void);
        (*h).flags = new_flags;
        (*h).n_buckets = new_n_buckets;
        (*h).n_occupied = (*h).size;
        (*h)
            .upper_bound = ((*h).n_buckets as libc::c_double * khash_ac_HASH_UPPER___3
            + 0.5f64) as khint_t;
    }
    return 0 as libc::c_int;
}
#[inline]
unsafe extern "C" fn kh_put_sym(
    mut h: *mut kh_sym_t,
    mut key: sym_key,
    mut ret: *mut libc::c_int,
) -> khint_t {
    let mut x: khint_t = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut k: khint_t = 0;
    let mut i: khint_t = 0;
    let mut site: khint_t = 0;
    let mut last: khint_t = 0;
    let mut mask: khint_t = 0;
    let mut step: khint_t = 0;
    let mut tmp___1: khint_t = 0;
    if (*h).n_occupied >= (*h).upper_bound {
        if (*h).n_buckets > (*h).size << 1 as libc::c_int {
            tmp = kh_resize_sym(h, ((*h).n_buckets).wrapping_sub(1 as libc::c_uint));
            if tmp < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        } else {
            tmp___0 = kh_resize_sym(h, ((*h).n_buckets).wrapping_add(1 as libc::c_uint));
            if tmp___0 < 0 as libc::c_int {
                *ret = -(1 as libc::c_int);
                return (*h).n_buckets;
            }
        }
    }
    mask = ((*h).n_buckets).wrapping_sub(1 as libc::c_uint);
    step = 0 as libc::c_int as khint_t;
    site = (*h).n_buckets;
    x = site;
    k = sym_hash(key);
    i = k & mask;
    if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
        >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        x = i;
    } else {
        last = i;
        while *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
            >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint == 0
        {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                == 0
            {
                tmp___1 = sym_eq(*((*h).keys).offset(i as isize), key);
                if tmp___1 != 0 {
                    break;
                }
            }
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint
                != 0
            {
                site = i;
            }
            step = step.wrapping_add(1);
            i = i.wrapping_add(step) & mask;
            if !(i == last) {
                continue;
            }
            x = site;
            break;
        }
        if x == (*h).n_buckets {
            if *((*h).flags).offset((i >> 4 as libc::c_int) as isize)
                >> ((i & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint
                != 0
            {
                if site != (*h).n_buckets {
                    x = site;
                } else {
                    x = i;
                }
            } else {
                x = i;
            }
        }
    }
    if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
        >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 2 as libc::c_uint != 0
    {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        (*h).n_occupied = ((*h).n_occupied).wrapping_add(1);
        *ret = 1 as libc::c_int;
    } else if *((*h).flags).offset((x >> 4 as libc::c_int) as isize)
            >> ((x & 15 as libc::c_uint) << 1 as libc::c_int) & 1 as libc::c_uint != 0
        {
        *((*h).keys).offset(x as isize) = key;
        *((*h).flags)
            .offset(
                (x >> 4 as libc::c_int) as isize,
            ) = (*((*h).flags).offset((x >> 4 as libc::c_int) as isize) as libc::c_ulong
            & !((3 as libc::c_ulong) << ((x & 15 as libc::c_uint) << 1 as libc::c_int)))
            as khint32_t;
        (*h).size = ((*h).size).wrapping_add(1);
        *ret = 2 as libc::c_int;
    } else {
        *ret = 0 as libc::c_int;
    }
    return x;
}
static mut sym_mutex: pthread_mutex_t = __anonunion_pthread_mutex_t_335460617 {
    __data: {
        let mut init = __pthread_mutex_s {
            __lock: 0 as libc::c_int,
            __count: 0 as libc::c_uint,
            __owner: 0 as libc::c_int,
            __nusers: 0 as libc::c_uint,
            __kind: 0 as libc::c_int,
            __spins: 0 as libc::c_int as libc::c_short,
            __elision: 0 as libc::c_int as libc::c_short,
            __list: {
                let mut init = __pthread_internal_list {
                    __prev: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                    __next: 0 as *const __pthread_internal_list
                        as *mut __pthread_internal_list,
                };
                init
            },
        };
        init
    },
};
static mut sym_table: *mut kh_sym_t = 0 as *const kh_sym_t as *mut kh_sym_t;
unsafe extern "C" fn str_new(
    mut p: *const libc::c_char,
    mut len: strm_int,
    mut foreign: libc::c_int,
) -> strm_string {
    let mut current_block: u64;
    let mut tag: strm_value = 0;
    let mut val: strm_value = 0;
    let mut s: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut str: *mut strm_string_0 = 0 as *mut strm_string_0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___1: libc::c_int = 0;
    if p.is_null() {
        current_block = 6907553884265689116;
    } else if len < 6 as libc::c_int {
        tag = 18444210798919155712 as libc::c_ulonglong as strm_value;
        val = 0 as libc::c_int as strm_value;
        s = (&mut val as *mut strm_value as *mut libc::c_char)
            .offset(1 as libc::c_int as isize);
        memcpy(s as *mut libc::c_void, p as *const libc::c_void, len as size_t);
        *s.offset(-(1 as libc::c_int) as isize) = len as libc::c_char;
        current_block = 17184638872671510253;
    } else if len == 6 as libc::c_int {
        tag = 18444492273895866368 as libc::c_ulonglong as strm_value;
        val = 0 as libc::c_int as strm_value;
        s = &mut val as *mut strm_value as *mut libc::c_char;
        memcpy(s as *mut libc::c_void, p as *const libc::c_void, len as size_t);
        current_block = 17184638872671510253;
    } else if !p.is_null() {
        if foreign != 0 {
            tag = 18445055223849287680 as libc::c_ulonglong as strm_value;
            tmp = malloc(::std::mem::size_of::<strm_string_0>() as libc::c_ulong);
            str = tmp as *mut strm_string_0;
            (*str).ptr = p;
            current_block = 8704759739624374314;
        } else {
            tmp___1 = readonly_data_p(p);
            if tmp___1 != 0 {
                tag = 18445055223849287680 as libc::c_ulonglong as strm_value;
                tmp = malloc(::std::mem::size_of::<strm_string_0>() as libc::c_ulong);
                str = tmp as *mut strm_string_0;
                (*str).ptr = p;
                current_block = 8704759739624374314;
            } else {
                current_block = 6907553884265689116;
            }
        }
    } else {
        current_block = 6907553884265689116;
    }
    match current_block {
        6907553884265689116 => {
            tag = 18444773748872577024 as libc::c_ulonglong as strm_value;
            tmp___0 = malloc(
                (::std::mem::size_of::<strm_string_0>() as libc::c_ulong)
                    .wrapping_add(len as libc::c_ulong)
                    .wrapping_add(1 as libc::c_ulong),
            );
            str = tmp___0 as *mut strm_string_0;
            buf = str.offset(1 as libc::c_int as isize) as *mut libc::c_char;
            if !p.is_null() {
                memcpy(
                    buf as *mut libc::c_void,
                    p as *const libc::c_void,
                    len as size_t,
                );
            } else {
                memset(buf as *mut libc::c_void, 0 as libc::c_int, len as size_t);
            }
            *buf.offset(len as isize) = '\u{0}' as i32 as libc::c_char;
            (*str).ptr = buf as *const libc::c_char;
            current_block = 8704759739624374314;
        }
        _ => {}
    }
    match current_block {
        8704759739624374314 => {
            (*str).len = len;
            val = str as intptr_t as strm_value
                & !((65535 as libc::c_ulong) << 48 as libc::c_int);
        }
        _ => {}
    }
    return tag | val & !((65535 as libc::c_ulong) << 48 as libc::c_int);
}
unsafe extern "C" fn str_intern(
    mut p: *const libc::c_char,
    mut len: strm_int,
    mut foreign: libc::c_int,
) -> strm_string {
    let mut k: khiter_t = 0;
    let mut key: sym_key = sym_key {
        ptr: 0 as *const libc::c_char,
        len: 0,
    };
    let mut ret: libc::c_int = 0;
    let mut str: strm_string = 0;
    let mut tmp: strm_string = 0;
    if len <= 6 as libc::c_int {
        tmp = str_new(p, len, foreign);
        return tmp;
    }
    if sym_table.is_null() {
        sym_table = kh_init_sym();
    }
    key.ptr = p;
    key.len = len;
    k = kh_put_sym(sym_table, key, &mut ret);
    if ret == 0 as libc::c_int {
        return *((*sym_table).vals).offset(k as isize);
    }
    str = str_new(p, len, foreign);
    let ref mut fresh16 = (*((*sym_table).keys).offset(k as isize)).ptr;
    *fresh16 = strm_strp_ptr(&mut str);
    *((*sym_table).vals).offset(k as isize) = str;
    return str;
}
pub unsafe extern "C" fn strm_str_new(
    mut p: *const libc::c_char,
    mut len: strm_int,
) -> strm_string {
    let mut tmp: strm_string = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: strm_string = 0;
    if strm_event_loop_started == 0 {
        if !p.is_null() {
            if len < 64 as libc::c_int {
                tmp = str_intern(p, len, 0 as libc::c_int);
                return tmp;
            } else {
                tmp___0 = readonly_data_p(p);
                if tmp___0 != 0 {
                    tmp = str_intern(p, len, 0 as libc::c_int);
                    return tmp;
                }
            }
        }
    }
    tmp___1 = str_new(p, len, 0 as libc::c_int);
    return tmp___1;
}
pub unsafe extern "C" fn strm_str_static(
    mut p: *const libc::c_char,
    mut len: strm_int,
) -> strm_string {
    let mut tmp: strm_string = 0;
    tmp = str_new(p, len, 1 as libc::c_int);
    return tmp;
}
pub unsafe extern "C" fn strm_str_intern(
    mut p: *const libc::c_char,
    mut len: strm_int,
) -> strm_string {
    let mut str: strm_string = 0;
    let mut tmp___0: strm_string = 0;
    if !(p as libc::c_ulong != 0 as *mut libc::c_void as libc::c_ulong) {
        __assert_fail(
            b"p!=NULL\0" as *const u8 as *const libc::c_char,
            b"string.c\0" as *const u8 as *const libc::c_char,
            182 as libc::c_uint,
            b"strm_str_intern\0" as *const u8 as *const libc::c_char,
        );
    }
    if strm_event_loop_started == 0 {
        tmp___0 = str_intern(p, len, 0 as libc::c_int);
        return tmp___0;
    }
    pthread_mutex_lock(&mut sym_mutex);
    str = str_intern(p, len, 0 as libc::c_int);
    pthread_mutex_unlock(&mut sym_mutex);
    return str;
}
pub unsafe extern "C" fn strm_str_intern_str(mut str: strm_string) -> strm_string {
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___2: strm_string = 0;
    let mut tmp___3: strm_int = 0;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    tmp = strm_str_intern_p(str);
    if tmp != 0 {
        return str;
    }
    if strm_event_loop_started == 0 {
        tmp___0 = strm_str_len(str);
        tmp___1 = strm_strp_ptr(&mut str);
        tmp___2 = str_intern(tmp___1, tmp___0, 0 as libc::c_int);
        return tmp___2;
    }
    pthread_mutex_lock(&mut sym_mutex);
    tmp___3 = strm_str_len(str);
    tmp___4 = strm_strp_ptr(&mut str);
    str = str_intern(tmp___4, tmp___3, 0 as libc::c_int);
    pthread_mutex_unlock(&mut sym_mutex);
    return str;
}
pub unsafe extern "C" fn strm_str_intern_static(
    mut p: *const libc::c_char,
    mut len: strm_int,
) -> strm_string {
    let mut tmp: strm_string = 0;
    tmp = str_intern(p, len, 1 as libc::c_int);
    return tmp;
}
pub unsafe extern "C" fn strm_str_intern_p(mut s: strm_string) -> libc::c_int {
    match s & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18445055223849287680 | 18444492273895866368 | 18444210798919155712 => {
            return 1 as libc::c_int;
        }
        _ => return 0 as libc::c_int,
    };
}
pub unsafe extern "C" fn strm_str_eq(
    mut a: strm_string,
    mut b: strm_string,
) -> libc::c_int {
    let mut tmp: strm_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: strm_int = 0;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___4: libc::c_int = 0;
    if a == b {
        return 1 as libc::c_int;
    }
    if (a & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
        == 18445055223849287680 as libc::c_ulonglong
    {
        if (b & (65535 as libc::c_ulong) << 48 as libc::c_int) as libc::c_ulonglong
            == 18445055223849287680 as libc::c_ulonglong
        {
            return 0 as libc::c_int;
        }
    }
    tmp = strm_str_len(a);
    tmp___0 = strm_str_len(b);
    if tmp != tmp___0 {
        return 0 as libc::c_int;
    }
    tmp___1 = strm_str_len(a);
    tmp___2 = strm_strp_ptr(&mut b);
    tmp___3 = strm_strp_ptr(&mut a);
    tmp___4 = memcmp(
        tmp___3 as *const libc::c_void,
        tmp___2 as *const libc::c_void,
        tmp___1 as size_t,
    );
    if tmp___4 == 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_str_p(mut v: strm_value) -> libc::c_int {
    match v & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18444773748872577024 | 18445055223849287680 | 18444492273895866368
        | 18444210798919155712 => return 1 as libc::c_int,
        _ => return 0 as libc::c_int,
    };
}
pub unsafe extern "C" fn strm_strp_ptr(mut s: *mut strm_string) -> *const libc::c_char {
    let mut str: *mut strm_string_0 = 0 as *mut strm_string_0;
    match *s & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18444210798919155712 => {
            return (s as *mut libc::c_char).offset(1 as libc::c_int as isize)
                as *const libc::c_char;
        }
        18444492273895866368 => return s as *mut libc::c_char as *const libc::c_char,
        18445055223849287680 | 18444773748872577024 => {
            str = (*s & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
                as *mut libc::c_void as *mut strm_string_0;
            return (*str).ptr;
        }
        _ => return 0 as *mut libc::c_void as *const libc::c_char,
    };
}
pub unsafe extern "C" fn strm_str_cstr(
    mut s: strm_string,
    mut buf: *mut libc::c_char,
) -> *const libc::c_char {
    let mut len: strm_int = 0;
    let mut str: *mut strm_string_0 = 0 as *mut strm_string_0;
    match s & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18444210798919155712 => {
            len = *(&mut s as *mut strm_string as *mut libc::c_char)
                .offset(0 as libc::c_int as isize) as strm_int;
            memcpy(
                buf as *mut libc::c_void,
                (&mut s as *mut strm_string as *mut libc::c_char)
                    .offset(1 as libc::c_int as isize) as *const libc::c_void,
                len as size_t,
            );
            *buf.offset(len as isize) = '\u{0}' as i32 as libc::c_char;
            return buf as *const libc::c_char;
        }
        18444492273895866368 => {
            memcpy(
                buf as *mut libc::c_void,
                &mut s as *mut strm_string as *mut libc::c_char as *const libc::c_void,
                6 as libc::c_int as size_t,
            );
            *buf.offset(6 as libc::c_int as isize) = '\u{0}' as i32 as libc::c_char;
            return buf as *const libc::c_char;
        }
        18445055223849287680 | 18444773748872577024 => {
            str = (s & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
                as *mut libc::c_void as *mut strm_string_0;
            return (*str).ptr;
        }
        _ => return 0 as *mut libc::c_void as *const libc::c_char,
    };
}
pub unsafe extern "C" fn strm_str_len(mut s: strm_string) -> strm_int {
    let mut str: *mut strm_string_0 = 0 as *mut strm_string_0;
    match s & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18444210798919155712 => {
            return *(&mut s as *mut strm_string as *mut libc::c_char)
                .offset(0 as libc::c_int as isize) as strm_int;
        }
        18444492273895866368 => return 6 as libc::c_int,
        18445055223849287680 | 18444773748872577024 => {
            str = (s & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
                as *mut libc::c_void as *mut strm_string_0;
            return (*str).len;
        }
        _ => return 0 as libc::c_int,
    };
}
pub unsafe extern "C" fn strm_string_p(mut s: libc::c_ulong) -> libc::c_int {
    match s & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18445055223849287680 | 18444773748872577024 | 18444492273895866368
        | 18444210798919155712 => return 1 as libc::c_int,
        _ => return 0 as libc::c_int,
    };
}
unsafe extern "C" fn str_length(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"s\0" as *const u8 as *const libc::c_char,
        &mut p as *mut *mut libc::c_char,
        &mut len as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = strm_int_value(len);
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_split(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut slen: strm_int = 0;
    let mut b: *const libc::c_char = 0 as *const libc::c_char;
    let mut t: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut plen: strm_int = 0;
    let mut pend: *const libc::c_char = 0 as *const libc::c_char;
    let mut c: libc::c_char = 0;
    let mut n: strm_int = 0;
    let mut ary: strm_array = 0;
    let mut sps: *mut strm_value = 0 as *mut strm_value;
    let mut i: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: strm_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: strm_int = 0;
    n = 0 as libc::c_int;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"s|s\0" as *const u8 as *const libc::c_char,
        &mut p as *mut *const libc::c_char,
        &mut plen as *mut strm_int,
        &mut s as *mut *const libc::c_char,
        &mut slen as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if argc == 1 as libc::c_int {
        s = b" \0" as *const u8 as *const libc::c_char;
        slen = 1 as libc::c_int;
    }
    c = *s.offset(0 as libc::c_int as isize);
    t = p;
    b = t;
    pend = p.offset(plen as isize).offset(-(slen as isize));
    n = 0 as libc::c_int;
    while (p as libc::c_ulong) < pend as libc::c_ulong {
        if *p as libc::c_int == c as libc::c_int {
            tmp___0 = memcmp(
                p as *const libc::c_void,
                s as *const libc::c_void,
                slen as size_t,
            );
            if tmp___0 == 0 as libc::c_int {
                if slen == 1 as libc::c_int {
                    if c as libc::c_int == 32 as libc::c_int {
                        if !(p.offset_from(t) as libc::c_long == 0 as libc::c_long) {
                            n += 1;
                        }
                    } else {
                        n += 1;
                    }
                } else {
                    n += 1;
                }
                t = p.offset(slen as isize);
            }
        }
        p = p.offset(1);
    }
    n += 1;
    ary = strm_ary_new(0 as *mut libc::c_void as *const strm_value, n);
    tmp___1 = strm_ary_struct(ary);
    sps = (*tmp___1).ptr;
    c = *s.offset(0 as libc::c_int as isize);
    t = b;
    p = t;
    i = 0 as libc::c_int;
    while (p as libc::c_ulong) < pend as libc::c_ulong {
        if *p as libc::c_int == c as libc::c_int {
            tmp___3 = memcmp(
                p as *const libc::c_void,
                s as *const libc::c_void,
                slen as size_t,
            );
            if tmp___3 == 0 as libc::c_int {
                if slen == 1 as libc::c_int {
                    if c as libc::c_int == 32 as libc::c_int {
                        if !(p.offset_from(t) as libc::c_long == 0 as libc::c_long) {
                            tmp___2 = i;
                            i += 1;
                            *sps
                                .offset(
                                    tmp___2 as isize,
                                ) = strm_str_new(
                                t,
                                p.offset_from(t) as libc::c_long as strm_int,
                            );
                        }
                    } else {
                        tmp___2 = i;
                        i += 1;
                        *sps
                            .offset(
                                tmp___2 as isize,
                            ) = strm_str_new(
                            t,
                            p.offset_from(t) as libc::c_long as strm_int,
                        );
                    }
                } else {
                    tmp___2 = i;
                    i += 1;
                    *sps
                        .offset(
                            tmp___2 as isize,
                        ) = strm_str_new(
                        t,
                        p.offset_from(t) as libc::c_long as strm_int,
                    );
                }
                t = p.offset(slen as isize);
            }
        }
        p = p.offset(1);
    }
    pend = b.offset(plen as isize);
    tmp___4 = i;
    i += 1;
    *sps
        .offset(
            tmp___4 as isize,
        ) = strm_str_new(t, pend.offset_from(t) as libc::c_long as strm_int);
    *ret = ary;
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_plus(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut str1: strm_string = 0;
    let mut str2: strm_string = 0;
    let mut str3: strm_string = 0;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: strm_int = 0;
    let mut tmp___1: strm_int = 0;
    let mut tmp___2: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___3: strm_int = 0;
    let mut tmp___4: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___5: strm_int = 0;
    let mut tmp___6: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp___7: strm_int = 0;
    let mut tmp___8: strm_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"SS\0" as *const u8 as *const libc::c_char,
        &mut str1 as *mut strm_string,
        &mut str2 as *mut strm_string,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    tmp___0 = strm_str_len(str1);
    tmp___1 = strm_str_len(str2);
    str3 = strm_str_new(
        0 as *mut libc::c_void as *const libc::c_char,
        tmp___0 + tmp___1,
    );
    tmp___2 = strm_strp_ptr(&mut str3);
    p = tmp___2 as *mut libc::c_char;
    tmp___3 = strm_str_len(str1);
    tmp___4 = strm_strp_ptr(&mut str1);
    memcpy(p as *mut libc::c_void, tmp___4 as *const libc::c_void, tmp___3 as size_t);
    tmp___5 = strm_str_len(str2);
    tmp___6 = strm_strp_ptr(&mut str2);
    tmp___7 = strm_str_len(str1);
    memcpy(
        p.offset(tmp___7 as isize) as *mut libc::c_void,
        tmp___6 as *const libc::c_void,
        tmp___5 as size_t,
    );
    tmp___8 = strm_str_len(str3);
    *p.offset(tmp___8 as isize) = '\u{0}' as i32 as libc::c_char;
    *ret = str3;
    return 0 as libc::c_int;
}
static mut utf8len_codepage: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    2 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    3 as libc::c_int as libc::c_char,
    4 as libc::c_int as libc::c_char,
    4 as libc::c_int as libc::c_char,
    4 as libc::c_int as libc::c_char,
    4 as libc::c_int as libc::c_char,
    4 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
unsafe extern "C" fn utf8len(
    mut p: *const libc::c_char,
    mut e: *const libc::c_char,
) -> libc::c_int {
    let mut len: strm_int = 0;
    let mut i: strm_int = 0;
    len = utf8len_codepage[*p as libc::c_uchar as usize] as strm_int;
    if p.offset(len as isize) as libc::c_ulong > e as libc::c_ulong {
        return 1 as libc::c_int;
    }
    i = 1 as libc::c_int;
    while i < len {
        if *p.offset(i as isize) as libc::c_int & 192 as libc::c_int
            != 128 as libc::c_int
        {
            return 1 as libc::c_int;
        }
        i += 1;
    }
    return len;
}
unsafe extern "C" fn str_chars(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut prev: *const libc::c_char = 0 as *const libc::c_char;
    let mut slen: strm_int = 0;
    let mut ary: strm_array = 0;
    let mut n: strm_int = 0;
    let mut sps: *mut strm_value = 0 as *mut strm_value;
    let mut i: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: strm_int = 0;
    prev = 0 as *mut libc::c_void as *const libc::c_char;
    n = 0 as libc::c_int;
    i = 0 as libc::c_int;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"s\0" as *const u8 as *const libc::c_char,
        &mut str as *mut *const libc::c_char,
        &mut slen as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    s = str;
    while *s != 0 {
        tmp___0 = utf8len(s, s.offset(slen as isize));
        s = s.offset(tmp___0 as isize);
        n += 1;
    }
    ary = strm_ary_new(0 as *mut libc::c_void as *const strm_value, n);
    tmp___1 = strm_ary_struct(ary);
    sps = (*tmp___1).ptr;
    s = str;
    while *s != 0 {
        prev = s;
        tmp___2 = utf8len(s, s.offset(slen as isize));
        s = s.offset(tmp___2 as isize);
        tmp___3 = i;
        i += 1;
        *sps
            .offset(
                tmp___3 as isize,
            ) = strm_str_new(prev, s.offset_from(prev) as libc::c_long as strm_int);
    }
    *ret = ary;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn strm_string_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    strm_ns_string = strm_ns_new(
        0 as *mut libc::c_void as *mut strm_state,
        b"string\0" as *const u8 as *const libc::c_char,
    );
    tmp = strm_cfunc_value(
        Some(
            str_length
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_string, b"length\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            str_split
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_string,
        b"split\0" as *const u8 as *const libc::c_char,
        tmp___0,
    );
    tmp___1 = strm_cfunc_value(
        Some(
            str_plus
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_string, b"+\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            str_chars
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_string,
        b"chars\0" as *const u8 as *const libc::c_char,
        tmp___2,
    );
}
pub static mut strm_ns_array: *mut strm_state = 0 as *const strm_state
    as *mut strm_state;
pub unsafe extern "C" fn strm_array_p(mut v: strm_value) -> libc::c_int {
    match v & (65535 as libc::c_ulong) << 48 as libc::c_int {
        18443647848965734400 | 18443366373989023744 => return 1 as libc::c_int,
        _ => return 0 as libc::c_int,
    };
}
pub unsafe extern "C" fn strm_ary_new(
    mut p: *const strm_value,
    mut len: strm_int,
) -> strm_array {
    let mut ary: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut buf: *mut strm_value = 0 as *mut strm_value;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(
        (::std::mem::size_of::<strm_array_0>() as libc::c_ulong)
            .wrapping_add(
                (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                    .wrapping_mul(len as libc::c_ulong),
            ),
    );
    ary = tmp as *mut strm_array_0;
    buf = ary.offset(1 as libc::c_int as isize) as *mut strm_value;
    if !p.is_null() {
        memcpy(
            buf as *mut libc::c_void,
            p as *const libc::c_void,
            (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                .wrapping_mul(len as libc::c_ulong),
        );
    } else {
        memset(
            buf as *mut libc::c_void,
            0 as libc::c_int,
            (::std::mem::size_of::<strm_value>() as libc::c_ulong)
                .wrapping_mul(len as libc::c_ulong),
        );
    }
    (*ary).ptr = buf;
    (*ary).len = len;
    (*ary).ns = 0 as *mut libc::c_void as *mut strm_state;
    (*ary).headers = 0 as libc::c_int as strm_array;
    return (18443366373989023744 as libc::c_ulonglong
        | (ary as intptr_t as libc::c_ulong
            & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as libc::c_ulonglong)
        as strm_array;
}
pub unsafe extern "C" fn strm_ary_eq(
    mut a: strm_array,
    mut b: strm_array,
) -> libc::c_int {
    let mut i: strm_int = 0;
    let mut len: strm_int = 0;
    let mut tmp: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___1: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___2: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___3: *mut strm_array_0 = 0 as *mut strm_array_0;
    let mut tmp___4: libc::c_int = 0;
    if a == b {
        return 1 as libc::c_int;
    }
    tmp = strm_ary_struct(a);
    tmp___0 = strm_ary_struct(b);
    if (*tmp).len != (*tmp___0).len {
        return 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    tmp___1 = strm_ary_struct(a);
    len = (*tmp___1).len;
    while i < len {
        tmp___2 = strm_ary_struct(b);
        tmp___3 = strm_ary_struct(a);
        tmp___4 = strm_value_eq(
            *((*tmp___3).ptr).offset(i as isize),
            *((*tmp___2).ptr).offset(i as isize),
        );
        if tmp___4 == 0 {
            return 0 as libc::c_int;
        }
        i += 1;
    }
    return 1 as libc::c_int;
}
pub unsafe extern "C" fn strm_ary_struct(mut v: libc::c_ulong) -> *mut strm_array_0 {
    return (v & !((65535 as libc::c_ulong) << 48 as libc::c_int)) as intptr_t
        as *mut libc::c_void as *mut strm_array_0;
}
unsafe extern "C" fn ary_length(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut len: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"a\0" as *const u8 as *const libc::c_char,
        &mut v as *mut *mut strm_value,
        &mut len as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    *ret = strm_int_value(len);
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_reverse(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut v2: *mut strm_value = 0 as *mut strm_value;
    let mut len: strm_int = 0;
    let mut ary: strm_array = 0;
    let mut i: strm_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut tmp___0: *mut strm_array_0 = 0 as *mut strm_array_0;
    tmp = strm_parse_args(
        strm,
        argc,
        args,
        b"a\0" as *const u8 as *const libc::c_char,
        &mut v as *mut *mut strm_value,
        &mut len as *mut strm_int,
    );
    if tmp == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    ary = strm_ary_new(0 as *mut libc::c_void as *const strm_value, len);
    tmp___0 = strm_ary_struct(ary);
    v2 = (*tmp___0).ptr;
    i = 0 as libc::c_int;
    while i < len {
        *v2.offset((len - i - 1 as libc::c_int) as isize) = *v.offset(i as isize);
        i += 1;
    }
    *ret = ary;
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_minmax(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
    mut min: libc::c_int,
) -> libc::c_int {
    let mut func: strm_value = 0;
    let mut tmp: strm_value = 0;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut v: *mut strm_value = 0 as *mut strm_value;
    let mut e: strm_value = 0;
    let mut val: strm_value = 0;
    let mut num: libc::c_double = 0.;
    let mut f: libc::c_double = 0.;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    tmp = strm_nil_value();
    func = tmp;
    tmp___0 = strm_parse_args(
        strm,
        argc,
        args,
        b"a|v\0" as *const u8 as *const libc::c_char,
        &mut v as *mut *mut strm_value,
        &mut len as *mut libc::c_int,
        &mut func as *mut strm_value,
    );
    if tmp___0 == 1 as libc::c_int {
        return 1 as libc::c_int;
    }
    if len == 0 as libc::c_int {
        *ret = strm_nil_value();
        return 0 as libc::c_int;
    }
    val = *v.offset(0 as libc::c_int as isize);
    if argc == 2 as libc::c_int {
        tmp___1 = strm_funcall(
            strm,
            func,
            1 as libc::c_int,
            v.offset(0 as libc::c_int as isize),
            &mut e,
        );
        if tmp___1 == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
    } else {
        e = *v.offset(0 as libc::c_int as isize);
    }
    num = strm_value_float(e);
    i = 1 as libc::c_int;
    while i < len {
        if argc == 2 as libc::c_int {
            tmp___2 = strm_funcall(
                strm,
                func,
                1 as libc::c_int,
                v.offset(i as isize),
                &mut e,
            );
            if tmp___2 == 1 as libc::c_int {
                return 1 as libc::c_int;
            }
        } else {
            e = *v.offset(0 as libc::c_int as isize);
        }
        f = strm_value_float(e);
        if min != 0 {
            if num > f {
                num = f;
                val = *v.offset(i as isize);
            }
        } else if num < f {
            num = f;
            val = *v.offset(i as isize);
        }
        i += 1;
    }
    *ret = val;
    return 0 as libc::c_int;
}
unsafe extern "C" fn ary_min(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = ary_minmax(strm, argc, args, ret, 1 as libc::c_int);
    return tmp;
}
unsafe extern "C" fn ary_max(
    mut strm: *mut strm_stream,
    mut argc: libc::c_int,
    mut args: *mut strm_value,
    mut ret: *mut strm_value,
) -> libc::c_int {
    let mut tmp: libc::c_int = 0;
    tmp = ary_minmax(strm, argc, args, ret, 0 as libc::c_int);
    return tmp;
}
pub unsafe extern "C" fn strm_array_init(mut state: *mut strm_state) {
    let mut tmp: strm_value = 0;
    let mut tmp___0: strm_value = 0;
    let mut tmp___1: strm_value = 0;
    let mut tmp___2: strm_value = 0;
    strm_ns_array = strm_ns_new(
        0 as *mut libc::c_void as *mut strm_state,
        b"array\0" as *const u8 as *const libc::c_char,
    );
    tmp = strm_cfunc_value(
        Some(
            ary_length
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_array, b"length\0" as *const u8 as *const libc::c_char, tmp);
    tmp___0 = strm_cfunc_value(
        Some(
            ary_reverse
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(
        strm_ns_array,
        b"reverse\0" as *const u8 as *const libc::c_char,
        tmp___0,
    );
    tmp___1 = strm_cfunc_value(
        Some(
            ary_min
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_array, b"min\0" as *const u8 as *const libc::c_char, tmp___1);
    tmp___2 = strm_cfunc_value(
        Some(
            ary_max
                as unsafe extern "C" fn(
                    *mut strm_stream,
                    libc::c_int,
                    *mut strm_value,
                    *mut strm_value,
                ) -> libc::c_int,
        ),
    );
    strm_var_def(strm_ns_array, b"max\0" as *const u8 as *const libc::c_char, tmp___2);
}
unsafe extern "C" fn node_lineinfo(mut p: *mut parser_state, mut node___0: *mut node) {
    if node___0.is_null() {
        return;
    }
    (*node___0).fname = (*p).fname;
    (*node___0).lineno = (*p).lineno;
}
pub static mut yydebug: libc::c_int = 0;
static mut yytranslate: [yytype_int8; 302] = [
    0 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    60 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    46 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    51 as libc::c_int as yytype_int8,
    52 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    54 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    57 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    59 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    53 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    58 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    55 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    56 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    49 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    47 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    6 as libc::c_int as yytype_int8,
    7 as libc::c_int as yytype_int8,
    8 as libc::c_int as yytype_int8,
    9 as libc::c_int as yytype_int8,
    10 as libc::c_int as yytype_int8,
    11 as libc::c_int as yytype_int8,
    12 as libc::c_int as yytype_int8,
    13 as libc::c_int as yytype_int8,
    14 as libc::c_int as yytype_int8,
    15 as libc::c_int as yytype_int8,
    16 as libc::c_int as yytype_int8,
    17 as libc::c_int as yytype_int8,
    18 as libc::c_int as yytype_int8,
    19 as libc::c_int as yytype_int8,
    20 as libc::c_int as yytype_int8,
    21 as libc::c_int as yytype_int8,
    22 as libc::c_int as yytype_int8,
    23 as libc::c_int as yytype_int8,
    24 as libc::c_int as yytype_int8,
    25 as libc::c_int as yytype_int8,
    26 as libc::c_int as yytype_int8,
    27 as libc::c_int as yytype_int8,
    28 as libc::c_int as yytype_int8,
    29 as libc::c_int as yytype_int8,
    30 as libc::c_int as yytype_int8,
    31 as libc::c_int as yytype_int8,
    32 as libc::c_int as yytype_int8,
    33 as libc::c_int as yytype_int8,
    34 as libc::c_int as yytype_int8,
    35 as libc::c_int as yytype_int8,
    36 as libc::c_int as yytype_int8,
    37 as libc::c_int as yytype_int8,
    38 as libc::c_int as yytype_int8,
    39 as libc::c_int as yytype_int8,
    40 as libc::c_int as yytype_int8,
    41 as libc::c_int as yytype_int8,
    42 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    44 as libc::c_int as yytype_int8,
    45 as libc::c_int as yytype_int8,
    48 as libc::c_int as yytype_int8,
];
static mut yyrline: [yytype_int16; 129] = [
    0 as libc::c_int as yytype_int16,
    113 as libc::c_int as yytype_int16,
    113 as libc::c_int as yytype_int16,
    119 as libc::c_int as yytype_int16,
    123 as libc::c_int as yytype_int16,
    127 as libc::c_int as yytype_int16,
    133 as libc::c_int as yytype_int16,
    142 as libc::c_int as yytype_int16,
    163 as libc::c_int as yytype_int16,
    174 as libc::c_int as yytype_int16,
    182 as libc::c_int as yytype_int16,
    197 as libc::c_int as yytype_int16,
    209 as libc::c_int as yytype_int16,
    213 as libc::c_int as yytype_int16,
    216 as libc::c_int as yytype_int16,
    220 as libc::c_int as yytype_int16,
    224 as libc::c_int as yytype_int16,
    230 as libc::c_int as yytype_int16,
    239 as libc::c_int as yytype_int16,
    254 as libc::c_int as yytype_int16,
    264 as libc::c_int as yytype_int16,
    272 as libc::c_int as yytype_int16,
    280 as libc::c_int as yytype_int16,
    284 as libc::c_int as yytype_int16,
    288 as libc::c_int as yytype_int16,
    292 as libc::c_int as yytype_int16,
    296 as libc::c_int as yytype_int16,
    300 as libc::c_int as yytype_int16,
    303 as libc::c_int as yytype_int16,
    306 as libc::c_int as yytype_int16,
    307 as libc::c_int as yytype_int16,
    313 as libc::c_int as yytype_int16,
    317 as libc::c_int as yytype_int16,
    321 as libc::c_int as yytype_int16,
    325 as libc::c_int as yytype_int16,
    329 as libc::c_int as yytype_int16,
    333 as libc::c_int as yytype_int16,
    337 as libc::c_int as yytype_int16,
    341 as libc::c_int as yytype_int16,
    345 as libc::c_int as yytype_int16,
    349 as libc::c_int as yytype_int16,
    353 as libc::c_int as yytype_int16,
    357 as libc::c_int as yytype_int16,
    361 as libc::c_int as yytype_int16,
    365 as libc::c_int as yytype_int16,
    369 as libc::c_int as yytype_int16,
    373 as libc::c_int as yytype_int16,
    377 as libc::c_int as yytype_int16,
    381 as libc::c_int as yytype_int16,
    385 as libc::c_int as yytype_int16,
    389 as libc::c_int as yytype_int16,
    393 as libc::c_int as yytype_int16,
    397 as libc::c_int as yytype_int16,
    401 as libc::c_int as yytype_int16,
    404 as libc::c_int as yytype_int16,
    410 as libc::c_int as yytype_int16,
    414 as libc::c_int as yytype_int16,
    421 as libc::c_int as yytype_int16,
    424 as libc::c_int as yytype_int16,
    431 as libc::c_int as yytype_int16,
    432 as libc::c_int as yytype_int16,
    436 as libc::c_int as yytype_int16,
    442 as libc::c_int as yytype_int16,
    447 as libc::c_int as yytype_int16,
    454 as libc::c_int as yytype_int16,
    455 as libc::c_int as yytype_int16,
    456 as libc::c_int as yytype_int16,
    457 as libc::c_int as yytype_int16,
    458 as libc::c_int as yytype_int16,
    462 as libc::c_int as yytype_int16,
    472 as libc::c_int as yytype_int16,
    476 as libc::c_int as yytype_int16,
    480 as libc::c_int as yytype_int16,
    481 as libc::c_int as yytype_int16,
    485 as libc::c_int as yytype_int16,
    489 as libc::c_int as yytype_int16,
    493 as libc::c_int as yytype_int16,
    497 as libc::c_int as yytype_int16,
    501 as libc::c_int as yytype_int16,
    505 as libc::c_int as yytype_int16,
    509 as libc::c_int as yytype_int16,
    513 as libc::c_int as yytype_int16,
    517 as libc::c_int as yytype_int16,
    524 as libc::c_int as yytype_int16,
    527 as libc::c_int as yytype_int16,
    530 as libc::c_int as yytype_int16,
    534 as libc::c_int as yytype_int16,
    535 as libc::c_int as yytype_int16,
    536 as libc::c_int as yytype_int16,
    540 as libc::c_int as yytype_int16,
    544 as libc::c_int as yytype_int16,
    548 as libc::c_int as yytype_int16,
    552 as libc::c_int as yytype_int16,
    556 as libc::c_int as yytype_int16,
    560 as libc::c_int as yytype_int16,
    564 as libc::c_int as yytype_int16,
    570 as libc::c_int as yytype_int16,
    575 as libc::c_int as yytype_int16,
    582 as libc::c_int as yytype_int16,
    587 as libc::c_int as yytype_int16,
    594 as libc::c_int as yytype_int16,
    595 as libc::c_int as yytype_int16,
    599 as libc::c_int as yytype_int16,
    603 as libc::c_int as yytype_int16,
    607 as libc::c_int as yytype_int16,
    611 as libc::c_int as yytype_int16,
    612 as libc::c_int as yytype_int16,
    618 as libc::c_int as yytype_int16,
    622 as libc::c_int as yytype_int16,
    626 as libc::c_int as yytype_int16,
    630 as libc::c_int as yytype_int16,
    636 as libc::c_int as yytype_int16,
    640 as libc::c_int as yytype_int16,
    646 as libc::c_int as yytype_int16,
    650 as libc::c_int as yytype_int16,
    654 as libc::c_int as yytype_int16,
    658 as libc::c_int as yytype_int16,
    665 as libc::c_int as yytype_int16,
    669 as libc::c_int as yytype_int16,
    676 as libc::c_int as yytype_int16,
    679 as libc::c_int as yytype_int16,
    682 as libc::c_int as yytype_int16,
    687 as libc::c_int as yytype_int16,
    694 as libc::c_int as yytype_int16,
    695 as libc::c_int as yytype_int16,
    698 as libc::c_int as yytype_int16,
    699 as libc::c_int as yytype_int16,
    702 as libc::c_int as yytype_int16,
    703 as libc::c_int as yytype_int16,
];
static mut yytname: [*const libc::c_char; 93] = [
    b"$end\0" as *const u8 as *const libc::c_char,
    b"error\0" as *const u8 as *const libc::c_char,
    b"$undefined\0" as *const u8 as *const libc::c_char,
    b"keyword_if\0" as *const u8 as *const libc::c_char,
    b"keyword_else\0" as *const u8 as *const libc::c_char,
    b"keyword_case\0" as *const u8 as *const libc::c_char,
    b"keyword_emit\0" as *const u8 as *const libc::c_char,
    b"keyword_skip\0" as *const u8 as *const libc::c_char,
    b"keyword_return\0" as *const u8 as *const libc::c_char,
    b"keyword_namespace\0" as *const u8 as *const libc::c_char,
    b"keyword_class\0" as *const u8 as *const libc::c_char,
    b"keyword_import\0" as *const u8 as *const libc::c_char,
    b"keyword_def\0" as *const u8 as *const libc::c_char,
    b"keyword_method\0" as *const u8 as *const libc::c_char,
    b"keyword_new\0" as *const u8 as *const libc::c_char,
    b"keyword_nil\0" as *const u8 as *const libc::c_char,
    b"keyword_true\0" as *const u8 as *const libc::c_char,
    b"keyword_false\0" as *const u8 as *const libc::c_char,
    b"op_lasgn\0" as *const u8 as *const libc::c_char,
    b"op_rasgn\0" as *const u8 as *const libc::c_char,
    b"op_lambda\0" as *const u8 as *const libc::c_char,
    b"op_lambda2\0" as *const u8 as *const libc::c_char,
    b"op_lambda3\0" as *const u8 as *const libc::c_char,
    b"op_plus\0" as *const u8 as *const libc::c_char,
    b"op_minus\0" as *const u8 as *const libc::c_char,
    b"op_mult\0" as *const u8 as *const libc::c_char,
    b"op_div\0" as *const u8 as *const libc::c_char,
    b"op_mod\0" as *const u8 as *const libc::c_char,
    b"op_eq\0" as *const u8 as *const libc::c_char,
    b"op_neq\0" as *const u8 as *const libc::c_char,
    b"op_lt\0" as *const u8 as *const libc::c_char,
    b"op_le\0" as *const u8 as *const libc::c_char,
    b"op_gt\0" as *const u8 as *const libc::c_char,
    b"op_ge\0" as *const u8 as *const libc::c_char,
    b"op_and\0" as *const u8 as *const libc::c_char,
    b"op_or\0" as *const u8 as *const libc::c_char,
    b"op_bar\0" as *const u8 as *const libc::c_char,
    b"op_amper\0" as *const u8 as *const libc::c_char,
    b"op_colon2\0" as *const u8 as *const libc::c_char,
    b"lit_time\0" as *const u8 as *const libc::c_char,
    b"lit_number\0" as *const u8 as *const libc::c_char,
    b"lit_symbol\0" as *const u8 as *const libc::c_char,
    b"lit_string\0" as *const u8 as *const libc::c_char,
    b"identifier\0" as *const u8 as *const libc::c_char,
    b"label\0" as *const u8 as *const libc::c_char,
    b"op_LOWEST\0" as *const u8 as *const libc::c_char,
    b"'!'\0" as *const u8 as *const libc::c_char,
    b"'~'\0" as *const u8 as *const libc::c_char,
    b"op_HIGHEST\0" as *const u8 as *const libc::c_char,
    b"'{'\0" as *const u8 as *const libc::c_char,
    b"'}'\0" as *const u8 as *const libc::c_char,
    b"'('\0" as *const u8 as *const libc::c_char,
    b"')'\0" as *const u8 as *const libc::c_char,
    b"'='\0" as *const u8 as *const libc::c_char,
    b"','\0" as *const u8 as *const libc::c_char,
    b"'['\0" as *const u8 as *const libc::c_char,
    b"']'\0" as *const u8 as *const libc::c_char,
    b"'.'\0" as *const u8 as *const libc::c_char,
    b"'@'\0" as *const u8 as *const libc::c_char,
    b"';'\0" as *const u8 as *const libc::c_char,
    b"'\\n'\0" as *const u8 as *const libc::c_char,
    b"$accept\0" as *const u8 as *const libc::c_char,
    b"program\0" as *const u8 as *const libc::c_char,
    b"topstmts\0" as *const u8 as *const libc::c_char,
    b"topstmt_list\0" as *const u8 as *const libc::c_char,
    b"topstmt\0" as *const u8 as *const libc::c_char,
    b"stmts\0" as *const u8 as *const libc::c_char,
    b"stmt_list\0" as *const u8 as *const libc::c_char,
    b"stmt\0" as *const u8 as *const libc::c_char,
    b"var\0" as *const u8 as *const libc::c_char,
    b"fname\0" as *const u8 as *const libc::c_char,
    b"expr\0" as *const u8 as *const libc::c_char,
    b"condition\0" as *const u8 as *const libc::c_char,
    b"opt_else\0" as *const u8 as *const libc::c_char,
    b"opt_args\0" as *const u8 as *const libc::c_char,
    b"arg\0" as *const u8 as *const libc::c_char,
    b"args\0" as *const u8 as *const libc::c_char,
    b"primary\0" as *const u8 as *const libc::c_char,
    b"opt_block\0" as *const u8 as *const libc::c_char,
    b"pterm\0" as *const u8 as *const libc::c_char,
    b"pary\0" as *const u8 as *const libc::c_char,
    b"pstruct\0" as *const u8 as *const libc::c_char,
    b"pattern\0" as *const u8 as *const libc::c_char,
    b"cparam\0" as *const u8 as *const libc::c_char,
    b"case_body\0" as *const u8 as *const libc::c_char,
    b"block\0" as *const u8 as *const libc::c_char,
    b"bparam\0" as *const u8 as *const libc::c_char,
    b"opt_f_args\0" as *const u8 as *const libc::c_char,
    b"f_args\0" as *const u8 as *const libc::c_char,
    b"opt_terms\0" as *const u8 as *const libc::c_char,
    b"terms\0" as *const u8 as *const libc::c_char,
    b"term\0" as *const u8 as *const libc::c_char,
    0 as *const libc::c_void as *mut libc::c_void as *const libc::c_char,
];
static mut yypact: [yytype_int16; 254] = [
    257 as libc::c_int as yytype_int16,
    -(46 as libc::c_int) as yytype_int16,
    457 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    457 as libc::c_int as yytype_int16,
    -(27 as libc::c_int) as yytype_int16,
    -(12 as libc::c_int) as yytype_int16,
    -(9 as libc::c_int) as yytype_int16,
    98 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    -(2 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(41 as libc::c_int) as yytype_int16,
    -(23 as libc::c_int) as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    315 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    412 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    56 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    126 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(30 as libc::c_int) as yytype_int16,
    82 as libc::c_int as yytype_int16,
    690 as libc::c_int as yytype_int16,
    6 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    257 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    741 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    16 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    33 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    111 as libc::c_int as yytype_int16,
    68 as libc::c_int as yytype_int16,
    71 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    540 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    41 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(18 as libc::c_int) as yytype_int16,
    10 as libc::c_int as yytype_int16,
    365 as libc::c_int as yytype_int16,
    -(8 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    365 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    630 as libc::c_int as yytype_int16,
    136 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    113 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    257 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    457 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    118 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    660 as libc::c_int as yytype_int16,
    615 as libc::c_int as yytype_int16,
    741 as libc::c_int as yytype_int16,
    741 as libc::c_int as yytype_int16,
    457 as libc::c_int as yytype_int16,
    257 as libc::c_int as yytype_int16,
    257 as libc::c_int as yytype_int16,
    118 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    118 as libc::c_int as yytype_int16,
    457 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    185 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    185 as libc::c_int as yytype_int16,
    546 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    108 as libc::c_int as yytype_int16,
    123 as libc::c_int as yytype_int16,
    134 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    365 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    365 as libc::c_int as yytype_int16,
    153 as libc::c_int as yytype_int16,
    540 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    140 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    118 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    499 as libc::c_int as yytype_int16,
    365 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    741 as libc::c_int as yytype_int16,
    142 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    119 as libc::c_int as yytype_int16,
    119 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    317 as libc::c_int as yytype_int16,
    317 as libc::c_int as yytype_int16,
    157 as libc::c_int as yytype_int16,
    157 as libc::c_int as yytype_int16,
    157 as libc::c_int as yytype_int16,
    157 as libc::c_int as yytype_int16,
    367 as libc::c_int as yytype_int16,
    259 as libc::c_int as yytype_int16,
    756 as libc::c_int as yytype_int16,
    645 as libc::c_int as yytype_int16,
    457 as libc::c_int as yytype_int16,
    121 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    499 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    147 as libc::c_int as yytype_int16,
    149 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    151 as libc::c_int as yytype_int16,
    741 as libc::c_int as yytype_int16,
    158 as libc::c_int as yytype_int16,
    156 as libc::c_int as yytype_int16,
    708 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    108 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    166 as libc::c_int as yytype_int16,
    160 as libc::c_int as yytype_int16,
    170 as libc::c_int as yytype_int16,
    2 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    365 as libc::c_int as yytype_int16,
    365 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    741 as libc::c_int as yytype_int16,
    167 as libc::c_int as yytype_int16,
    143 as libc::c_int as yytype_int16,
    171 as libc::c_int as yytype_int16,
    457 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    741 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    20 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    185 as libc::c_int as yytype_int16,
    581 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    185 as libc::c_int as yytype_int16,
    108 as libc::c_int as yytype_int16,
    185 as libc::c_int as yytype_int16,
    185 as libc::c_int as yytype_int16,
    726 as libc::c_int as yytype_int16,
    169 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    143 as libc::c_int as yytype_int16,
    172 as libc::c_int as yytype_int16,
    365 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    365 as libc::c_int as yytype_int16,
    499 as libc::c_int as yytype_int16,
    168 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    174 as libc::c_int as yytype_int16,
    78 as libc::c_int as yytype_int16,
    108 as libc::c_int as yytype_int16,
    108 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    143 as libc::c_int as yytype_int16,
    176 as libc::c_int as yytype_int16,
    741 as libc::c_int as yytype_int16,
    182 as libc::c_int as yytype_int16,
    741 as libc::c_int as yytype_int16,
    185 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    185 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    168 as libc::c_int as yytype_int16,
];
static mut yydefact: [yytype_uint8; 254] = [
    123 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    57 as libc::c_int as yytype_uint8,
    24 as libc::c_int as yytype_uint8,
    57 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    73 as libc::c_int as yytype_uint8,
    74 as libc::c_int as yytype_uint8,
    75 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    67 as libc::c_int as yytype_uint8,
    64 as libc::c_int as yytype_uint8,
    66 as libc::c_int as yytype_uint8,
    65 as libc::c_int as yytype_uint8,
    28 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    119 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    127 as libc::c_int as yytype_uint8,
    128 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    2 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    6 as libc::c_int as yytype_uint8,
    13 as libc::c_int as yytype_uint8,
    68 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    27 as libc::c_int as yytype_uint8,
    53 as libc::c_int as yytype_uint8,
    72 as libc::c_int as yytype_uint8,
    5 as libc::c_int as yytype_uint8,
    124 as libc::c_int as yytype_uint8,
    125 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    68 as libc::c_int as yytype_uint8,
    59 as libc::c_int as yytype_uint8,
    25 as libc::c_int as yytype_uint8,
    62 as libc::c_int as yytype_uint8,
    58 as libc::c_int as yytype_uint8,
    26 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    10 as libc::c_int as yytype_uint8,
    30 as libc::c_int as yytype_uint8,
    29 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    44 as libc::c_int as yytype_uint8,
    45 as libc::c_int as yytype_uint8,
    82 as libc::c_int as yytype_uint8,
    46 as libc::c_int as yytype_uint8,
    47 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    117 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    17 as libc::c_int as yytype_uint8,
    68 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    16 as libc::c_int as yytype_uint8,
    124 as libc::c_int as yytype_uint8,
    68 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    120 as libc::c_int as yytype_uint8,
    71 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    1 as libc::c_int as yytype_uint8,
    3 as libc::c_int as yytype_uint8,
    124 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    57 as libc::c_int as yytype_uint8,
    77 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    126 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    55 as libc::c_int as yytype_uint8,
    61 as libc::c_int as yytype_uint8,
    60 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    119 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    119 as libc::c_int as yytype_uint8,
    57 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    88 as libc::c_int as yytype_uint8,
    89 as libc::c_int as yytype_uint8,
    90 as libc::c_int as yytype_uint8,
    107 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    86 as libc::c_int as yytype_uint8,
    87 as libc::c_int as yytype_uint8,
    28 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    85 as libc::c_int as yytype_uint8,
    96 as libc::c_int as yytype_uint8,
    100 as libc::c_int as yytype_uint8,
    105 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    113 as libc::c_int as yytype_uint8,
    14 as libc::c_int as yytype_uint8,
    124 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    115 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    118 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    69 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    70 as libc::c_int as yytype_uint8,
    7 as libc::c_int as yytype_uint8,
    19 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    23 as libc::c_int as yytype_uint8,
    31 as libc::c_int as yytype_uint8,
    32 as libc::c_int as yytype_uint8,
    33 as libc::c_int as yytype_uint8,
    34 as libc::c_int as yytype_uint8,
    35 as libc::c_int as yytype_uint8,
    42 as libc::c_int as yytype_uint8,
    43 as libc::c_int as yytype_uint8,
    40 as libc::c_int as yytype_uint8,
    41 as libc::c_int as yytype_uint8,
    38 as libc::c_int as yytype_uint8,
    39 as libc::c_int as yytype_uint8,
    48 as libc::c_int as yytype_uint8,
    49 as libc::c_int as yytype_uint8,
    36 as libc::c_int as yytype_uint8,
    37 as libc::c_int as yytype_uint8,
    57 as libc::c_int as yytype_uint8,
    83 as libc::c_int as yytype_uint8,
    4 as libc::c_int as yytype_uint8,
    54 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    52 as libc::c_int as yytype_uint8,
    63 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    121 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    22 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    103 as libc::c_int as yytype_uint8,
    98 as libc::c_int as yytype_uint8,
    91 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    109 as libc::c_int as yytype_uint8,
    111 as libc::c_int as yytype_uint8,
    18 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    114 as libc::c_int as yytype_uint8,
    122 as libc::c_int as yytype_uint8,
    15 as libc::c_int as yytype_uint8,
    50 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    83 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    57 as libc::c_int as yytype_uint8,
    80 as libc::c_int as yytype_uint8,
    84 as libc::c_int as yytype_uint8,
    56 as libc::c_int as yytype_uint8,
    8 as libc::c_int as yytype_uint8,
    9 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    76 as libc::c_int as yytype_uint8,
    108 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    93 as libc::c_int as yytype_uint8,
    95 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    97 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    112 as libc::c_int as yytype_uint8,
    51 as libc::c_int as yytype_uint8,
    78 as libc::c_int as yytype_uint8,
    83 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    123 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    104 as libc::c_int as yytype_uint8,
    92 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    101 as libc::c_int as yytype_uint8,
    106 as libc::c_int as yytype_uint8,
    99 as libc::c_int as yytype_uint8,
    110 as libc::c_int as yytype_uint8,
    116 as libc::c_int as yytype_uint8,
    81 as libc::c_int as yytype_uint8,
    83 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    21 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    12 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    94 as libc::c_int as yytype_uint8,
    0 as libc::c_int as yytype_uint8,
    79 as libc::c_int as yytype_uint8,
    20 as libc::c_int as yytype_uint8,
    11 as libc::c_int as yytype_uint8,
    102 as libc::c_int as yytype_uint8,
];
static mut yypgoto: [yytype_int16; 31] = [
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    93 as libc::c_int as yytype_int16,
    194 as libc::c_int as yytype_int16,
    154 as libc::c_int as yytype_int16,
    -(66 as libc::c_int) as yytype_int16,
    173 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    7 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    3 as libc::c_int as yytype_int16,
    130 as libc::c_int as yytype_int16,
    216 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(189 as libc::c_int) as yytype_int16,
    15 as libc::c_int as yytype_int16,
    -(210 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(125 as libc::c_int) as yytype_int16,
    104 as libc::c_int as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    -(34 as libc::c_int) as yytype_int16,
    -(211 as libc::c_int) as yytype_int16,
    62 as libc::c_int as yytype_int16,
    220 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    -(20 as libc::c_int) as yytype_int16,
];
static mut yydefgoto: [yytype_int16; 31] = [
    -(1 as libc::c_int) as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    67 as libc::c_int as yytype_int16,
    68 as libc::c_int as yytype_int16,
    69 as libc::c_int as yytype_int16,
    46 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    173 as libc::c_int as yytype_int16,
    48 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    205 as libc::c_int as yytype_int16,
    130 as libc::c_int as yytype_int16,
    131 as libc::c_int as yytype_int16,
    132 as libc::c_int as yytype_int16,
    133 as libc::c_int as yytype_int16,
    134 as libc::c_int as yytype_int16,
    71 as libc::c_int as yytype_int16,
    38 as libc::c_int as yytype_int16,
    72 as libc::c_int as yytype_int16,
    78 as libc::c_int as yytype_int16,
    79 as libc::c_int as yytype_int16,
    74 as libc::c_int as yytype_int16,
    75 as libc::c_int as yytype_int16,
    41 as libc::c_int as yytype_int16,
];
static mut yytable: [yytype_int16; 794] = [
    34 as libc::c_int as yytype_int16,
    87 as libc::c_int as yytype_int16,
    -(121 as libc::c_int) as yytype_int16,
    187 as libc::c_int as yytype_int16,
    233 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    141 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    -(30 as libc::c_int) as yytype_int16,
    47 as libc::c_int as yytype_int16,
    -(30 as libc::c_int) as yytype_int16,
    47 as libc::c_int as yytype_int16,
    142 as libc::c_int as yytype_int16,
    226 as libc::c_int as yytype_int16,
    138 as libc::c_int as yytype_int16,
    139 as libc::c_int as yytype_int16,
    52 as libc::c_int as yytype_int16,
    119 as libc::c_int as yytype_int16,
    120 as libc::c_int as yytype_int16,
    121 as libc::c_int as yytype_int16,
    106 as libc::c_int as yytype_int16,
    60 as libc::c_int as yytype_int16,
    61 as libc::c_int as yytype_int16,
    85 as libc::c_int as yytype_int16,
    70 as libc::c_int as yytype_int16,
    76 as libc::c_int as yytype_int16,
    -(29 as libc::c_int) as yytype_int16,
    218 as libc::c_int as yytype_int16,
    -(29 as libc::c_int) as yytype_int16,
    63 as libc::c_int as yytype_int16,
    64 as libc::c_int as yytype_int16,
    53 as libc::c_int as yytype_int16,
    77 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    85 as libc::c_int as yytype_int16,
    -(121 as libc::c_int) as yytype_int16,
    33 as libc::c_int as yytype_int16,
    241 as libc::c_int as yytype_int16,
    253 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    59 as libc::c_int as yytype_int16,
    124 as libc::c_int as yytype_int16,
    39 as libc::c_int as yytype_int16,
    125 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    143 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    220 as libc::c_int as yytype_int16,
    107 as libc::c_int as yytype_int16,
    108 as libc::c_int as yytype_int16,
    109 as libc::c_int as yytype_int16,
    110 as libc::c_int as yytype_int16,
    250 as libc::c_int as yytype_int16,
    191 as libc::c_int as yytype_int16,
    106 as libc::c_int as yytype_int16,
    82 as libc::c_int as yytype_int16,
    128 as libc::c_int as yytype_int16,
    57 as libc::c_int as yytype_int16,
    58 as libc::c_int as yytype_int16,
    140 as libc::c_int as yytype_int16,
    -(121 as libc::c_int) as yytype_int16,
    -(121 as libc::c_int) as yytype_int16,
    104 as libc::c_int as yytype_int16,
    106 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    62 as libc::c_int as yytype_int16,
    221 as libc::c_int as yytype_int16,
    193 as libc::c_int as yytype_int16,
    229 as libc::c_int as yytype_int16,
    111 as libc::c_int as yytype_int16,
    192 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    230 as libc::c_int as yytype_int16,
    83 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    214 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    84 as libc::c_int as yytype_int16,
    231 as libc::c_int as yytype_int16,
    188 as libc::c_int as yytype_int16,
    201 as libc::c_int as yytype_int16,
    112 as libc::c_int as yytype_int16,
    232 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    113 as libc::c_int as yytype_int16,
    55 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    152 as libc::c_int as yytype_int16,
    151 as libc::c_int as yytype_int16,
    235 as libc::c_int as yytype_int16,
    135 as libc::c_int as yytype_int16,
    150 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    -(121 as libc::c_int) as yytype_int16,
    168 as libc::c_int as yytype_int16,
    153 as libc::c_int as yytype_int16,
    154 as libc::c_int as yytype_int16,
    155 as libc::c_int as yytype_int16,
    156 as libc::c_int as yytype_int16,
    157 as libc::c_int as yytype_int16,
    158 as libc::c_int as yytype_int16,
    159 as libc::c_int as yytype_int16,
    160 as libc::c_int as yytype_int16,
    161 as libc::c_int as yytype_int16,
    162 as libc::c_int as yytype_int16,
    163 as libc::c_int as yytype_int16,
    164 as libc::c_int as yytype_int16,
    165 as libc::c_int as yytype_int16,
    166 as libc::c_int as yytype_int16,
    167 as libc::c_int as yytype_int16,
    136 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    177 as libc::c_int as yytype_int16,
    137 as libc::c_int as yytype_int16,
    177 as libc::c_int as yytype_int16,
    106 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    116 as libc::c_int as yytype_int16,
    181 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    179 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    182 as libc::c_int as yytype_int16,
    117 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    223 as libc::c_int as yytype_int16,
    224 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    249 as libc::c_int as yytype_int16,
    86 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    206 as libc::c_int as yytype_int16,
    188 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    183 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    55 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    184 as libc::c_int as yytype_int16,
    198 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    170 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    143 as libc::c_int as yytype_int16,
    84 as libc::c_int as yytype_int16,
    200 as libc::c_int as yytype_int16,
    169 as libc::c_int as yytype_int16,
    39 as libc::c_int as yytype_int16,
    39 as libc::c_int as yytype_int16,
    146 as libc::c_int as yytype_int16,
    147 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    114 as libc::c_int as yytype_int16,
    243 as libc::c_int as yytype_int16,
    115 as libc::c_int as yytype_int16,
    245 as libc::c_int as yytype_int16,
    188 as libc::c_int as yytype_int16,
    111 as libc::c_int as yytype_int16,
    206 as libc::c_int as yytype_int16,
    148 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    203 as libc::c_int as yytype_int16,
    204 as libc::c_int as yytype_int16,
    195 as libc::c_int as yytype_int16,
    194 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    178 as libc::c_int as yytype_int16,
    189 as libc::c_int as yytype_int16,
    180 as libc::c_int as yytype_int16,
    207 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    199 as libc::c_int as yytype_int16,
    190 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    197 as libc::c_int as yytype_int16,
    137 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    206 as libc::c_int as yytype_int16,
    202 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    208 as libc::c_int as yytype_int16,
    222 as libc::c_int as yytype_int16,
    209 as libc::c_int as yytype_int16,
    119 as libc::c_int as yytype_int16,
    120 as libc::c_int as yytype_int16,
    121 as libc::c_int as yytype_int16,
    210 as libc::c_int as yytype_int16,
    219 as libc::c_int as yytype_int16,
    175 as libc::c_int as yytype_int16,
    176 as libc::c_int as yytype_int16,
    228 as libc::c_int as yytype_int16,
    206 as libc::c_int as yytype_int16,
    215 as libc::c_int as yytype_int16,
    211 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    212 as libc::c_int as yytype_int16,
    217 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    216 as libc::c_int as yytype_int16,
    225 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    240 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    247 as libc::c_int as yytype_int16,
    227 as libc::c_int as yytype_int16,
    242 as libc::c_int as yytype_int16,
    124 as libc::c_int as yytype_int16,
    251 as libc::c_int as yytype_int16,
    125 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    248 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    252 as libc::c_int as yytype_int16,
    236 as libc::c_int as yytype_int16,
    105 as libc::c_int as yytype_int16,
    237 as libc::c_int as yytype_int16,
    238 as libc::c_int as yytype_int16,
    244 as libc::c_int as yytype_int16,
    149 as libc::c_int as yytype_int16,
    246 as libc::c_int as yytype_int16,
    128 as libc::c_int as yytype_int16,
    174 as libc::c_int as yytype_int16,
    81 as libc::c_int as yytype_int16,
    196 as libc::c_int as yytype_int16,
    73 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    144 as libc::c_int as yytype_int16,
    129 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    1 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    219 as libc::c_int as yytype_int16,
    2 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    4 as libc::c_int as yytype_int16,
    5 as libc::c_int as yytype_int16,
    6 as libc::c_int as yytype_int16,
    7 as libc::c_int as yytype_int16,
    8 as libc::c_int as yytype_int16,
    9 as libc::c_int as yytype_int16,
    10 as libc::c_int as yytype_int16,
    11 as libc::c_int as yytype_int16,
    12 as libc::c_int as yytype_int16,
    13 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    18 as libc::c_int as yytype_int16,
    19 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    21 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    1 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    65 as libc::c_int as yytype_int16,
    2 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    4 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    8 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    10 as libc::c_int as yytype_int16,
    11 as libc::c_int as yytype_int16,
    12 as libc::c_int as yytype_int16,
    13 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    66 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    -(122 as libc::c_int) as yytype_int16,
    -(122 as libc::c_int) as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    18 as libc::c_int as yytype_int16,
    19 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    21 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    1 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    2 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    4 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    8 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    10 as libc::c_int as yytype_int16,
    11 as libc::c_int as yytype_int16,
    12 as libc::c_int as yytype_int16,
    13 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    18 as libc::c_int as yytype_int16,
    19 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    21 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    1 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    10 as libc::c_int as yytype_int16,
    11 as libc::c_int as yytype_int16,
    12 as libc::c_int as yytype_int16,
    13 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    18 as libc::c_int as yytype_int16,
    19 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    21 as libc::c_int as yytype_int16,
    45 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    1 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    80 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    10 as libc::c_int as yytype_int16,
    11 as libc::c_int as yytype_int16,
    12 as libc::c_int as yytype_int16,
    13 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    18 as libc::c_int as yytype_int16,
    19 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    21 as libc::c_int as yytype_int16,
    45 as libc::c_int as yytype_int16,
    1 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    10 as libc::c_int as yytype_int16,
    11 as libc::c_int as yytype_int16,
    12 as libc::c_int as yytype_int16,
    13 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    18 as libc::c_int as yytype_int16,
    19 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    21 as libc::c_int as yytype_int16,
    118 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    119 as libc::c_int as yytype_int16,
    120 as libc::c_int as yytype_int16,
    121 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    122 as libc::c_int as yytype_int16,
    119 as libc::c_int as yytype_int16,
    120 as libc::c_int as yytype_int16,
    121 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    123 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    123 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    124 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    125 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    127 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    124 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    125 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    127 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    128 as libc::c_int as yytype_int16,
    119 as libc::c_int as yytype_int16,
    120 as libc::c_int as yytype_int16,
    121 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    128 as libc::c_int as yytype_int16,
    185 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    186 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    123 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    172 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    124 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    125 as libc::c_int as yytype_int16,
    126 as libc::c_int as yytype_int16,
    127 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    128 as libc::c_int as yytype_int16,
    234 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    102 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    102 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    145 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    102 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    88 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    171 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    102 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
    213 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    102 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
    239 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    102 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    102 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
];
static mut yycheck: [yytype_int16; 794] = [
    0 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    128 as libc::c_int as yytype_int16,
    214 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    72 as libc::c_int as yytype_int16,
    4 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    2 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    4 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    202 as libc::c_int as yytype_int16,
    4 as libc::c_int as yytype_int16,
    5 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    53 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    53 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    227 as libc::c_int as yytype_int16,
    249 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    45 as libc::c_int as yytype_int16,
    242 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    75 as libc::c_int as yytype_int16,
    0 as libc::c_int as yytype_int16,
    55 as libc::c_int as yytype_int16,
    8 as libc::c_int as yytype_int16,
    9 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    21 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    57 as libc::c_int as yytype_int16,
    84 as libc::c_int as yytype_int16,
    65 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    134 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    72 as libc::c_int as yytype_int16,
    53 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    75 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    58 as libc::c_int as yytype_int16,
    147 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    53 as libc::c_int as yytype_int16,
    84 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    88 as libc::c_int as yytype_int16,
    86 as libc::c_int as yytype_int16,
    215 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    85 as libc::c_int as yytype_int16,
    86 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    89 as libc::c_int as yytype_int16,
    90 as libc::c_int as yytype_int16,
    91 as libc::c_int as yytype_int16,
    92 as libc::c_int as yytype_int16,
    93 as libc::c_int as yytype_int16,
    94 as libc::c_int as yytype_int16,
    95 as libc::c_int as yytype_int16,
    96 as libc::c_int as yytype_int16,
    97 as libc::c_int as yytype_int16,
    98 as libc::c_int as yytype_int16,
    99 as libc::c_int as yytype_int16,
    100 as libc::c_int as yytype_int16,
    101 as libc::c_int as yytype_int16,
    102 as libc::c_int as yytype_int16,
    103 as libc::c_int as yytype_int16,
    68 as libc::c_int as yytype_int16,
    112 as libc::c_int as yytype_int16,
    113 as libc::c_int as yytype_int16,
    114 as libc::c_int as yytype_int16,
    68 as libc::c_int as yytype_int16,
    116 as libc::c_int as yytype_int16,
    137 as libc::c_int as yytype_int16,
    111 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    117 as libc::c_int as yytype_int16,
    84 as libc::c_int as yytype_int16,
    115 as libc::c_int as yytype_int16,
    123 as libc::c_int as yytype_int16,
    117 as libc::c_int as yytype_int16,
    118 as libc::c_int as yytype_int16,
    55 as libc::c_int as yytype_int16,
    127 as libc::c_int as yytype_int16,
    128 as libc::c_int as yytype_int16,
    195 as libc::c_int as yytype_int16,
    196 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    134 as libc::c_int as yytype_int16,
    169 as libc::c_int as yytype_int16,
    58 as libc::c_int as yytype_int16,
    137 as libc::c_int as yytype_int16,
    123 as libc::c_int as yytype_int16,
    139 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    127 as libc::c_int as yytype_int16,
    143 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    147 as libc::c_int as yytype_int16,
    105 as libc::c_int as yytype_int16,
    112 as libc::c_int as yytype_int16,
    113 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    105 as libc::c_int as yytype_int16,
    146 as libc::c_int as yytype_int16,
    104 as libc::c_int as yytype_int16,
    112 as libc::c_int as yytype_int16,
    113 as libc::c_int as yytype_int16,
    21 as libc::c_int as yytype_int16,
    22 as libc::c_int as yytype_int16,
    112 as libc::c_int as yytype_int16,
    113 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    229 as libc::c_int as yytype_int16,
    53 as libc::c_int as yytype_int16,
    231 as libc::c_int as yytype_int16,
    58 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    202 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    168 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    137 as libc::c_int as yytype_int16,
    168 as libc::c_int as yytype_int16,
    114 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    116 as libc::c_int as yytype_int16,
    172 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    59 as libc::c_int as yytype_int16,
    60 as libc::c_int as yytype_int16,
    144 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    189 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    144 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    227 as libc::c_int as yytype_int16,
    52 as libc::c_int as yytype_int16,
    195 as libc::c_int as yytype_int16,
    196 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    191 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    52 as libc::c_int as yytype_int16,
    189 as libc::c_int as yytype_int16,
    112 as libc::c_int as yytype_int16,
    113 as libc::c_int as yytype_int16,
    204 as libc::c_int as yytype_int16,
    242 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    52 as libc::c_int as yytype_int16,
    204 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    214 as libc::c_int as yytype_int16,
    215 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    218 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    220 as libc::c_int as yytype_int16,
    221 as libc::c_int as yytype_int16,
    54 as libc::c_int as yytype_int16,
    52 as libc::c_int as yytype_int16,
    52 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    229 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    231 as libc::c_int as yytype_int16,
    50 as libc::c_int as yytype_int16,
    218 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    220 as libc::c_int as yytype_int16,
    221 as libc::c_int as yytype_int16,
    230 as libc::c_int as yytype_int16,
    84 as libc::c_int as yytype_int16,
    232 as libc::c_int as yytype_int16,
    55 as libc::c_int as yytype_int16,
    111 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    139 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    247 as libc::c_int as yytype_int16,
    75 as libc::c_int as yytype_int16,
    249 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    3 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    247 as libc::c_int as yytype_int16,
    6 as libc::c_int as yytype_int16,
    7 as libc::c_int as yytype_int16,
    8 as libc::c_int as yytype_int16,
    9 as libc::c_int as yytype_int16,
    10 as libc::c_int as yytype_int16,
    11 as libc::c_int as yytype_int16,
    12 as libc::c_int as yytype_int16,
    13 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    39 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    41 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    46 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    49 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    51 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    59 as libc::c_int as yytype_int16,
    60 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    5 as libc::c_int as yytype_int16,
    6 as libc::c_int as yytype_int16,
    7 as libc::c_int as yytype_int16,
    8 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    12 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    20 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    37 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    39 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    41 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    46 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    49 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    51 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    3 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    6 as libc::c_int as yytype_int16,
    7 as libc::c_int as yytype_int16,
    8 as libc::c_int as yytype_int16,
    59 as libc::c_int as yytype_int16,
    60 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    12 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    37 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    39 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    41 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    46 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    49 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    51 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    59 as libc::c_int as yytype_int16,
    60 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    37 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    39 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    41 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    46 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    49 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    51 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    37 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    39 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    41 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    46 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    49 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    51 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    14 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    37 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    39 as libc::c_int as yytype_int16,
    40 as libc::c_int as yytype_int16,
    41 as libc::c_int as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    3 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    46 as libc::c_int as yytype_int16,
    47 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    49 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    51 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    20 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    25 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    25 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    40 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    40 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    15 as libc::c_int as yytype_int16,
    16 as libc::c_int as yytype_int16,
    17 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    58 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    25 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    4 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    40 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    42 as libc::c_int as yytype_int16,
    43 as libc::c_int as yytype_int16,
    44 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    55 as libc::c_int as yytype_int16,
    56 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    52 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    19 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    52 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    20 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    36 as libc::c_int as yytype_int16,
    37 as libc::c_int as yytype_int16,
    23 as libc::c_int as yytype_int16,
    24 as libc::c_int as yytype_int16,
    25 as libc::c_int as yytype_int16,
    26 as libc::c_int as yytype_int16,
    27 as libc::c_int as yytype_int16,
    28 as libc::c_int as yytype_int16,
    29 as libc::c_int as yytype_int16,
    30 as libc::c_int as yytype_int16,
    31 as libc::c_int as yytype_int16,
    32 as libc::c_int as yytype_int16,
    33 as libc::c_int as yytype_int16,
    34 as libc::c_int as yytype_int16,
    35 as libc::c_int as yytype_int16,
    -(1 as libc::c_int) as yytype_int16,
    37 as libc::c_int as yytype_int16,
];
static mut yystos: [yytype_int8; 254] = [
    0 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    6 as libc::c_int as yytype_int8,
    7 as libc::c_int as yytype_int8,
    8 as libc::c_int as yytype_int8,
    9 as libc::c_int as yytype_int8,
    10 as libc::c_int as yytype_int8,
    11 as libc::c_int as yytype_int8,
    12 as libc::c_int as yytype_int8,
    13 as libc::c_int as yytype_int8,
    14 as libc::c_int as yytype_int8,
    15 as libc::c_int as yytype_int8,
    16 as libc::c_int as yytype_int8,
    17 as libc::c_int as yytype_int8,
    23 as libc::c_int as yytype_int8,
    24 as libc::c_int as yytype_int8,
    37 as libc::c_int as yytype_int8,
    39 as libc::c_int as yytype_int8,
    40 as libc::c_int as yytype_int8,
    41 as libc::c_int as yytype_int8,
    42 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    46 as libc::c_int as yytype_int8,
    47 as libc::c_int as yytype_int8,
    49 as libc::c_int as yytype_int8,
    51 as libc::c_int as yytype_int8,
    55 as libc::c_int as yytype_int8,
    59 as libc::c_int as yytype_int8,
    60 as libc::c_int as yytype_int8,
    62 as libc::c_int as yytype_int8,
    63 as libc::c_int as yytype_int8,
    64 as libc::c_int as yytype_int8,
    65 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    70 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    85 as libc::c_int as yytype_int8,
    89 as libc::c_int as yytype_int8,
    90 as libc::c_int as yytype_int8,
    91 as libc::c_int as yytype_int8,
    51 as libc::c_int as yytype_int8,
    72 as libc::c_int as yytype_int8,
    25 as libc::c_int as yytype_int8,
    44 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    74 as libc::c_int as yytype_int8,
    75 as libc::c_int as yytype_int8,
    76 as libc::c_int as yytype_int8,
    74 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    42 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    70 as libc::c_int as yytype_int8,
    70 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    70 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    20 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    67 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    84 as libc::c_int as yytype_int8,
    86 as libc::c_int as yytype_int8,
    88 as libc::c_int as yytype_int8,
    89 as libc::c_int as yytype_int8,
    90 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    87 as libc::c_int as yytype_int8,
    88 as libc::c_int as yytype_int8,
    56 as libc::c_int as yytype_int8,
    76 as libc::c_int as yytype_int8,
    0 as libc::c_int as yytype_int8,
    89 as libc::c_int as yytype_int8,
    90 as libc::c_int as yytype_int8,
    53 as libc::c_int as yytype_int8,
    51 as libc::c_int as yytype_int8,
    85 as libc::c_int as yytype_int8,
    19 as libc::c_int as yytype_int8,
    23 as libc::c_int as yytype_int8,
    24 as libc::c_int as yytype_int8,
    25 as libc::c_int as yytype_int8,
    26 as libc::c_int as yytype_int8,
    27 as libc::c_int as yytype_int8,
    28 as libc::c_int as yytype_int8,
    29 as libc::c_int as yytype_int8,
    30 as libc::c_int as yytype_int8,
    31 as libc::c_int as yytype_int8,
    32 as libc::c_int as yytype_int8,
    33 as libc::c_int as yytype_int8,
    34 as libc::c_int as yytype_int8,
    35 as libc::c_int as yytype_int8,
    36 as libc::c_int as yytype_int8,
    37 as libc::c_int as yytype_int8,
    57 as libc::c_int as yytype_int8,
    64 as libc::c_int as yytype_int8,
    91 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    54 as libc::c_int as yytype_int8,
    49 as libc::c_int as yytype_int8,
    49 as libc::c_int as yytype_int8,
    51 as libc::c_int as yytype_int8,
    53 as libc::c_int as yytype_int8,
    51 as libc::c_int as yytype_int8,
    55 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    15 as libc::c_int as yytype_int8,
    16 as libc::c_int as yytype_int8,
    17 as libc::c_int as yytype_int8,
    20 as libc::c_int as yytype_int8,
    25 as libc::c_int as yytype_int8,
    40 as libc::c_int as yytype_int8,
    42 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    44 as libc::c_int as yytype_int8,
    55 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    80 as libc::c_int as yytype_int8,
    81 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    83 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    89 as libc::c_int as yytype_int8,
    90 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    20 as libc::c_int as yytype_int8,
    54 as libc::c_int as yytype_int8,
    67 as libc::c_int as yytype_int8,
    52 as libc::c_int as yytype_int8,
    21 as libc::c_int as yytype_int8,
    22 as libc::c_int as yytype_int8,
    56 as libc::c_int as yytype_int8,
    65 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    74 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    51 as libc::c_int as yytype_int8,
    70 as libc::c_int as yytype_int8,
    89 as libc::c_int as yytype_int8,
    52 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    73 as libc::c_int as yytype_int8,
    75 as libc::c_int as yytype_int8,
    63 as libc::c_int as yytype_int8,
    63 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    87 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    87 as libc::c_int as yytype_int8,
    74 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    56 as libc::c_int as yytype_int8,
    58 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    58 as libc::c_int as yytype_int8,
    54 as libc::c_int as yytype_int8,
    54 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    20 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    20 as libc::c_int as yytype_int8,
    83 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    89 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    52 as libc::c_int as yytype_int8,
    74 as libc::c_int as yytype_int8,
    51 as libc::c_int as yytype_int8,
    78 as libc::c_int as yytype_int8,
    85 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    52 as libc::c_int as yytype_int8,
    52 as libc::c_int as yytype_int8,
    56 as libc::c_int as yytype_int8,
    20 as libc::c_int as yytype_int8,
    54 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    56 as libc::c_int as yytype_int8,
    43 as libc::c_int as yytype_int8,
    25 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    25 as libc::c_int as yytype_int8,
    44 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    78 as libc::c_int as yytype_int8,
    52 as libc::c_int as yytype_int8,
    74 as libc::c_int as yytype_int8,
    49 as libc::c_int as yytype_int8,
    53 as libc::c_int as yytype_int8,
    49 as libc::c_int as yytype_int8,
    53 as libc::c_int as yytype_int8,
    80 as libc::c_int as yytype_int8,
    56 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    20 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    78 as libc::c_int as yytype_int8,
    52 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    54 as libc::c_int as yytype_int8,
    56 as libc::c_int as yytype_int8,
    54 as libc::c_int as yytype_int8,
    78 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    50 as libc::c_int as yytype_int8,
    80 as libc::c_int as yytype_int8,
];
static mut yyr1: [yytype_int8; 129] = [
    0 as libc::c_int as yytype_int8,
    61 as libc::c_int as yytype_int8,
    62 as libc::c_int as yytype_int8,
    63 as libc::c_int as yytype_int8,
    63 as libc::c_int as yytype_int8,
    63 as libc::c_int as yytype_int8,
    64 as libc::c_int as yytype_int8,
    64 as libc::c_int as yytype_int8,
    65 as libc::c_int as yytype_int8,
    65 as libc::c_int as yytype_int8,
    65 as libc::c_int as yytype_int8,
    65 as libc::c_int as yytype_int8,
    65 as libc::c_int as yytype_int8,
    65 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    66 as libc::c_int as yytype_int8,
    67 as libc::c_int as yytype_int8,
    67 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    68 as libc::c_int as yytype_int8,
    69 as libc::c_int as yytype_int8,
    70 as libc::c_int as yytype_int8,
    70 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    71 as libc::c_int as yytype_int8,
    72 as libc::c_int as yytype_int8,
    73 as libc::c_int as yytype_int8,
    73 as libc::c_int as yytype_int8,
    74 as libc::c_int as yytype_int8,
    74 as libc::c_int as yytype_int8,
    75 as libc::c_int as yytype_int8,
    75 as libc::c_int as yytype_int8,
    75 as libc::c_int as yytype_int8,
    76 as libc::c_int as yytype_int8,
    76 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    77 as libc::c_int as yytype_int8,
    78 as libc::c_int as yytype_int8,
    78 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    79 as libc::c_int as yytype_int8,
    80 as libc::c_int as yytype_int8,
    80 as libc::c_int as yytype_int8,
    81 as libc::c_int as yytype_int8,
    81 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    82 as libc::c_int as yytype_int8,
    83 as libc::c_int as yytype_int8,
    83 as libc::c_int as yytype_int8,
    83 as libc::c_int as yytype_int8,
    83 as libc::c_int as yytype_int8,
    84 as libc::c_int as yytype_int8,
    84 as libc::c_int as yytype_int8,
    85 as libc::c_int as yytype_int8,
    85 as libc::c_int as yytype_int8,
    85 as libc::c_int as yytype_int8,
    85 as libc::c_int as yytype_int8,
    86 as libc::c_int as yytype_int8,
    86 as libc::c_int as yytype_int8,
    87 as libc::c_int as yytype_int8,
    87 as libc::c_int as yytype_int8,
    88 as libc::c_int as yytype_int8,
    88 as libc::c_int as yytype_int8,
    89 as libc::c_int as yytype_int8,
    89 as libc::c_int as yytype_int8,
    90 as libc::c_int as yytype_int8,
    90 as libc::c_int as yytype_int8,
    91 as libc::c_int as yytype_int8,
    91 as libc::c_int as yytype_int8,
];
static mut yyr2: [yytype_int8; 129] = [
    0 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    8 as libc::c_int as yytype_int8,
    7 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    8 as libc::c_int as yytype_int8,
    7 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    0 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    0 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    7 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    6 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    0 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    5 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    6 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    4 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    6 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    0 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    3 as libc::c_int as yytype_int8,
    0 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    2 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
    1 as libc::c_int as yytype_int8,
];
unsafe extern "C" fn yy_symbol_value_print(
    mut yyo: *mut FILE,
    mut yytype: libc::c_int,
    yyvaluep: *const YYSTYPE,
    mut p: *mut parser_state,
) {
    let mut yyoutput: *mut FILE = 0 as *mut FILE;
    yyoutput = yyo;
    if yyvaluep.is_null() {
        return;
    }
}
unsafe extern "C" fn yy_symbol_print(
    mut yyo: *mut FILE,
    mut yytype: libc::c_int,
    yyvaluep: *const YYSTYPE,
    mut p: *mut parser_state,
) {
    let mut tmp: *const libc::c_char = 0 as *const libc::c_char;
    if yytype < 61 as libc::c_int {
        tmp = b"token\0" as *const u8 as *const libc::c_char;
    } else {
        tmp = b"nterm\0" as *const u8 as *const libc::c_char;
    }
    fprintf(
        yyo,
        b"%s %s (\0" as *const u8 as *const libc::c_char,
        tmp,
        yytname[yytype as usize],
    );
    yy_symbol_value_print(yyo, yytype, yyvaluep, p);
    fprintf(yyo, b")\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn yy_stack_print(
    mut yybottom: *mut yy_state_t,
    mut yytop: *mut yy_state_t,
) {
    let mut yybot: libc::c_int = 0;
    fprintf(stderr, b"Stack now\0" as *const u8 as *const libc::c_char);
    while yybottom as libc::c_ulong <= yytop as libc::c_ulong {
        yybot = *yybottom as libc::c_int;
        fprintf(stderr, b" %d\0" as *const u8 as *const libc::c_char, yybot);
        yybottom = yybottom.offset(1);
    }
    fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn yy_reduce_print(
    mut yyssp: *mut yy_state_t,
    mut yyvsp: *mut YYSTYPE,
    mut yyrule: libc::c_int,
    mut p: *mut parser_state,
) {
    let mut yylno: libc::c_int = 0;
    let mut yynrhs: libc::c_int = 0;
    let mut yyi: libc::c_int = 0;
    yylno = yyrline[yyrule as usize] as libc::c_int;
    yynrhs = yyr2[yyrule as usize] as libc::c_int;
    fprintf(
        stderr,
        b"Reducing stack by rule %d (line %d):\n\0" as *const u8 as *const libc::c_char,
        yyrule - 1 as libc::c_int,
        yylno,
    );
    yyi = 0 as libc::c_int;
    while yyi < yynrhs {
        fprintf(
            stderr,
            b"   $%d = \0" as *const u8 as *const libc::c_char,
            yyi + 1 as libc::c_int,
        );
        yy_symbol_print(
            stderr,
            yystos[*yyssp.offset((yyi + 1 as libc::c_int - yynrhs) as isize) as usize]
                as libc::c_int,
            yyvsp.offset((yyi + 1 as libc::c_int - yynrhs) as isize) as *const YYSTYPE,
            p,
        );
        fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
        yyi += 1;
    }
}
unsafe extern "C" fn yystpcpy(
    mut yydest: *mut libc::c_char,
    mut yysrc: *const libc::c_char,
) -> *mut libc::c_char {
    let mut yyd: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut yys: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: libc::c_char = 0;
    let mut tmp___1: *const libc::c_char = 0 as *const libc::c_char;
    yyd = yydest;
    yys = yysrc;
    loop {
        tmp = yyd;
        yyd = yyd.offset(1);
        tmp___1 = yys;
        yys = yys.offset(1);
        tmp___0 = *tmp___1;
        *tmp = tmp___0;
        if !(tmp___0 as libc::c_int != 0 as libc::c_int) {
            break;
        }
    }
    return yyd.offset(-(1 as libc::c_int as isize));
}
unsafe extern "C" fn yytnamerr(
    mut yyres: *mut libc::c_char,
    mut yystr: *const libc::c_char,
) -> libc::c_long {
    let mut yyn: libc::c_long = 0;
    let mut yyp: *const libc::c_char = 0 as *const libc::c_char;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: size_t = 0;
    if *yystr as libc::c_int == 34 as libc::c_int {
        yyn = 0 as libc::c_long;
        yyp = yystr;
        loop {
            yyp = yyp.offset(1);
            match *yyp as libc::c_int {
                44 | 39 => {
                    break;
                }
                92 => {
                    yyp = yyp.offset(1);
                    if *yyp as libc::c_int != 92 as libc::c_int {
                        break;
                    }
                }
                34 => {
                    if !yyres.is_null() {
                        *yyres.offset(yyn as isize) = '\u{0}' as i32 as libc::c_char;
                    }
                    return yyn;
                }
                _ => {}
            }
            if !yyres.is_null() {
                *yyres.offset(yyn as isize) = *yyp;
            }
            yyn += 1;
        }
    }
    if !yyres.is_null() {
        tmp = yystpcpy(yyres, yystr);
        return tmp.offset_from(yyres) as libc::c_long;
    } else {
        tmp___0 = strlen(yystr);
        return tmp___0 as libc::c_long;
    };
}
unsafe extern "C" fn yysyntax_error(
    mut yymsg_alloc: *mut libc::c_long,
    mut yymsg: *mut *mut libc::c_char,
    mut yyssp: *mut yy_state_t,
    mut yytoken: libc::c_int,
) -> libc::c_int {
    let mut yyformat: *const libc::c_char = 0 as *const libc::c_char;
    let mut yyarg: [*const libc::c_char; 5] = [0 as *const libc::c_char; 5];
    let mut yycount: libc::c_int = 0;
    let mut yysize: libc::c_long = 0;
    let mut yyn: libc::c_int = 0;
    let mut yysize0: libc::c_long = 0;
    let mut tmp: libc::c_long = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut yyxbegin: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut yychecklim: libc::c_int = 0;
    let mut yyxend: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut yyx: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut yysize1: libc::c_long = 0;
    let mut tmp___4: libc::c_long = 0;
    let mut yysize1___0: libc::c_long = 0;
    let mut tmp___5: size_t = 0;
    let mut yyp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut yyi: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_long = 0;
    let mut tmp___8: libc::c_char = 0;
    yyformat = 0 as *mut libc::c_void as *const libc::c_char;
    yycount = 0 as libc::c_int;
    yysize = 0 as libc::c_long;
    if yytoken != -(2 as libc::c_int) {
        yyn = yypact[*yyssp as usize] as libc::c_int;
        tmp = yytnamerr(
            0 as *mut libc::c_void as *mut libc::c_char,
            yytname[yytoken as usize],
        );
        yysize0 = tmp;
        yysize = yysize0;
        tmp___0 = yycount;
        yycount += 1;
        yyarg[tmp___0 as usize] = yytname[yytoken as usize];
        if !(yyn == -(211 as libc::c_int)) {
            if yyn < 0 as libc::c_int {
                tmp___1 = -yyn;
            } else {
                tmp___1 = 0 as libc::c_int;
            }
            yyxbegin = tmp___1;
            yychecklim = 793 as libc::c_int - yyn + 1 as libc::c_int;
            if yychecklim < 61 as libc::c_int {
                tmp___2 = yychecklim;
            } else {
                tmp___2 = 61 as libc::c_int;
            }
            yyxend = tmp___2;
            yyx = yyxbegin;
            while yyx < yyxend {
                if yycheck[(yyx + yyn) as usize] as libc::c_int == yyx {
                    if yyx != 1 as libc::c_int {
                        if !(yytable[(yyx + yyn) as usize] as libc::c_int
                            == -(122 as libc::c_int))
                        {
                            if yycount == 5 as libc::c_int {
                                yycount = 1 as libc::c_int;
                                yysize = yysize0;
                                break;
                            } else {
                                tmp___3 = yycount;
                                yycount += 1;
                                yyarg[tmp___3 as usize] = yytname[yyx as usize];
                                tmp___4 = yytnamerr(
                                    0 as *mut libc::c_void as *mut libc::c_char,
                                    yytname[yyx as usize],
                                );
                                yysize1 = yysize + tmp___4;
                                if yysize <= yysize1 {
                                    if yysize1 <= 9223372036854775807 as libc::c_long {
                                        yysize = yysize1;
                                    } else {
                                        return 2 as libc::c_int
                                    }
                                } else {
                                    return 2 as libc::c_int
                                }
                            }
                        }
                    }
                }
                yyx += 1;
            }
        }
    }
    match yycount {
        1 => {
            yyformat = b"syntax error, unexpected %s\0" as *const u8
                as *const libc::c_char;
        }
        2 => {
            yyformat = b"syntax error, unexpected %s, expecting %s\0" as *const u8
                as *const libc::c_char;
        }
        3 => {
            yyformat = b"syntax error, unexpected %s, expecting %s or %s\0" as *const u8
                as *const libc::c_char;
        }
        4 => {
            yyformat = b"syntax error, unexpected %s, expecting %s or %s or %s\0"
                as *const u8 as *const libc::c_char;
        }
        5 => {
            yyformat = b"syntax error, unexpected %s, expecting %s or %s or %s or %s\0"
                as *const u8 as *const libc::c_char;
        }
        _ => {
            yyformat = b"syntax error\0" as *const u8 as *const libc::c_char;
        }
    }
    tmp___5 = strlen(yyformat);
    yysize1___0 = yysize
        + (tmp___5 as libc::c_long - (2 as libc::c_int * yycount) as libc::c_long)
        + 1 as libc::c_long;
    if yysize <= yysize1___0 {
        if yysize1___0 <= 9223372036854775807 as libc::c_long {
            yysize = yysize1___0;
        } else {
            return 2 as libc::c_int
        }
    } else {
        return 2 as libc::c_int
    }
    if *yymsg_alloc < yysize {
        *yymsg_alloc = 2 as libc::c_long * yysize;
        if yysize <= *yymsg_alloc {
            if !(*yymsg_alloc <= 9223372036854775807 as libc::c_long) {
                *yymsg_alloc = 9223372036854775807 as libc::c_long;
            }
        } else {
            *yymsg_alloc = 9223372036854775807 as libc::c_long;
        }
        return 1 as libc::c_int;
    }
    yyp = *yymsg;
    yyi = 0 as libc::c_int;
    loop {
        tmp___8 = *yyformat;
        *yyp = tmp___8;
        if !(tmp___8 as libc::c_int != 0 as libc::c_int) {
            break;
        }
        if *yyp as libc::c_int == 37 as libc::c_int {
            if *yyformat.offset(1 as libc::c_int as isize) as libc::c_int
                == 115 as libc::c_int
            {
                if yyi < yycount {
                    tmp___6 = yyi;
                    yyi += 1;
                    tmp___7 = yytnamerr(yyp, yyarg[tmp___6 as usize]);
                    yyp = yyp.offset(tmp___7 as isize);
                    yyformat = yyformat.offset(2 as libc::c_int as isize);
                } else {
                    yyp = yyp.offset(1);
                    yyformat = yyformat.offset(1);
                }
            } else {
                yyp = yyp.offset(1);
                yyformat = yyformat.offset(1);
            }
        } else {
            yyp = yyp.offset(1);
            yyformat = yyformat.offset(1);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn yydestruct(
    mut yymsg: *const libc::c_char,
    mut yytype: libc::c_int,
    mut yyvaluep: *mut YYSTYPE,
    mut p: *mut parser_state,
) {
    if yymsg.is_null() {
        yymsg = b"Deleting\0" as *const u8 as *const libc::c_char;
    }
    if yydebug != 0 {
        fprintf(stderr, b"%s \0" as *const u8 as *const libc::c_char, yymsg);
        yy_symbol_print(stderr, yytype, yyvaluep as *const YYSTYPE, p);
        fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
    }
}
static mut yyval_default: YYSTYPE = YYSTYPE {
    nd: 0 as *const node as *mut node,
};
pub unsafe extern "C" fn yyparse(mut p: *mut parser_state) -> libc::c_int {
    let mut current_block: u64;
    let mut yychar: libc::c_int = 0;
    let mut yylval: YYSTYPE = YYSTYPE {
        nd: 0 as *const node as *mut node,
    };
    let mut yynerrs: libc::c_int = 0;
    let mut yystate: yy_state_fast_t = 0;
    let mut yyerrstatus: libc::c_int = 0;
    let mut yyssa: [yy_state_t; 200] = [0; 200];
    let mut yyss: *mut yy_state_t = 0 as *mut yy_state_t;
    let mut yyssp: *mut yy_state_t = 0 as *mut yy_state_t;
    let mut yyvsa: [YYSTYPE; 200] = [YYSTYPE {
        nd: 0 as *const node as *mut node,
    }; 200];
    let mut yyvs: *mut YYSTYPE = 0 as *mut YYSTYPE;
    let mut yyvsp: *mut YYSTYPE = 0 as *mut YYSTYPE;
    let mut yystacksize: libc::c_long = 0;
    let mut yyn: libc::c_int = 0;
    let mut yyresult: libc::c_int = 0;
    let mut yytoken: libc::c_int = 0;
    let mut yyval: YYSTYPE = YYSTYPE {
        nd: 0 as *const node as *mut node,
    };
    let mut yymsgbuf: [libc::c_char; 128] = [0; 128];
    let mut yymsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut yymsg_alloc: libc::c_long = 0;
    let mut yylen: libc::c_int = 0;
    let mut yysize: libc::c_long = 0;
    let mut yyss1: *mut yy_state_t = 0 as *mut yy_state_t;
    let mut yyptr: *mut yyalloc = 0 as *mut yyalloc;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut yynewbytes: libc::c_long = 0;
    let mut yynewbytes___0: libc::c_long = 0;
    let mut tmp___0: *mut node = 0 as *mut node;
    let mut tmp___1: *mut node = 0 as *mut node;
    let mut tmp___2: *mut node = 0 as *mut node;
    let mut tmp___3: *mut node = 0 as *mut node;
    let mut tmp___4: *mut node = 0 as *mut node;
    let mut lambda: *mut node_lambda = 0 as *mut node_lambda;
    let mut tmp___5: *mut node = 0 as *mut node;
    let mut tmp___6: *mut node = 0 as *mut node;
    let mut tmp___7: *mut node = 0 as *mut node;
    let mut tmp___8: *mut node = 0 as *mut node;
    let mut tmp___9: *mut node = 0 as *mut node;
    let mut tmp___10: *mut node = 0 as *mut node;
    let mut e: *mut node = 0 as *mut node;
    let mut tmp___11: *mut node = 0 as *mut node;
    let mut tmp___12: *mut node = 0 as *mut node;
    let mut yylhs: libc::c_int = 0;
    let mut yyi: libc::c_int = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut yymsgp: *const libc::c_char = 0 as *const libc::c_char;
    let mut yysyntax_error_status: libc::c_int = 0;
    let mut tmp___14: *mut libc::c_void = 0 as *mut libc::c_void;
    yylval = yyval_default;
    yytoken = 0 as libc::c_int;
    yymsg = yymsgbuf.as_mut_ptr();
    yymsg_alloc = ::std::mem::size_of::<[libc::c_char; 128]>() as libc::c_ulong
        as libc::c_long;
    yylen = 0 as libc::c_int;
    yyss = yyssa.as_mut_ptr();
    yyssp = yyss;
    yyvs = yyvsa.as_mut_ptr();
    yyvsp = yyvs;
    yystacksize = 200 as libc::c_long;
    if yydebug != 0 {
        fprintf(stderr, b"Starting parse\n\0" as *const u8 as *const libc::c_char);
    }
    yystate = 0 as libc::c_int;
    yyerrstatus = 0 as libc::c_int;
    yynerrs = 0 as libc::c_int;
    yychar = -(2 as libc::c_int);
    '_yysetstate: loop {
        if yydebug != 0 {
            fprintf(
                stderr,
                b"Entering state %d\n\0" as *const u8 as *const libc::c_char,
                yystate,
            );
        }
        *yyssp = yystate as yy_state_t;
        if yyss.offset(yystacksize as isize).offset(-(1 as libc::c_int as isize))
            as libc::c_ulong <= yyssp as libc::c_ulong
        {
            yysize = yyssp.offset_from(yyss) as libc::c_long + 1 as libc::c_long;
            if 10000 as libc::c_long <= yystacksize {
                current_block = 10735487318834209902;
                break;
            }
            yystacksize *= 2 as libc::c_long;
            if (10000 as libc::c_long) < yystacksize {
                yystacksize = 10000 as libc::c_long;
            }
            yyss1 = yyss;
            tmp = malloc(
                (yystacksize
                    * (::std::mem::size_of::<yy_state_t>() as libc::c_ulong
                        as libc::c_long
                        + ::std::mem::size_of::<YYSTYPE>() as libc::c_ulong
                            as libc::c_long)
                    + (::std::mem::size_of::<yyalloc>() as libc::c_ulong as libc::c_long
                        - 1 as libc::c_long)) as libc::c_ulong,
            );
            yyptr = tmp as *mut yyalloc;
            if yyptr.is_null() {
                current_block = 10735487318834209902;
                break;
            }
            libc::memcpy(
                &mut (*yyptr).yyss_alloc as *mut yy_state_t as *mut libc::c_void,
                yyss as *const libc::c_void,
                (yysize as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<yy_state_t>() as libc::c_ulong)
                    as libc::size_t,
            );
            yyss = &mut (*yyptr).yyss_alloc;
            yynewbytes = yystacksize
                * ::std::mem::size_of::<yy_state_t>() as libc::c_ulong as libc::c_long
                + (::std::mem::size_of::<yyalloc>() as libc::c_ulong as libc::c_long
                    - 1 as libc::c_long);
            yyptr = yyptr
                .offset(
                    (yynewbytes
                        / ::std::mem::size_of::<yyalloc>() as libc::c_ulong
                            as libc::c_long) as isize,
                );
            libc::memcpy(
                &mut (*yyptr).yyvs_alloc as *mut YYSTYPE as *mut libc::c_void,
                yyvs as *const libc::c_void,
                (yysize as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<YYSTYPE>() as libc::c_ulong)
                    as libc::size_t,
            );
            yyvs = &mut (*yyptr).yyvs_alloc;
            yynewbytes___0 = yystacksize
                * ::std::mem::size_of::<YYSTYPE>() as libc::c_ulong as libc::c_long
                + (::std::mem::size_of::<yyalloc>() as libc::c_ulong as libc::c_long
                    - 1 as libc::c_long);
            yyptr = yyptr
                .offset(
                    (yynewbytes___0
                        / ::std::mem::size_of::<yyalloc>() as libc::c_ulong
                            as libc::c_long) as isize,
                );
            if yyss1 as libc::c_ulong != yyssa.as_mut_ptr() as libc::c_ulong {
                free(yyss1 as *mut libc::c_void);
            }
            yyssp = yyss.offset(yysize as isize).offset(-(1 as libc::c_int as isize));
            yyvsp = yyvs.offset(yysize as isize).offset(-(1 as libc::c_int as isize));
            if yydebug != 0 {
                fprintf(
                    stderr,
                    b"Stack size increased to %ld\n\0" as *const u8
                        as *const libc::c_char,
                    yystacksize,
                );
            }
            if yyss.offset(yystacksize as isize).offset(-(1 as libc::c_int as isize))
                as libc::c_ulong <= yyssp as libc::c_ulong
            {
                current_block = 13242541486230035560;
                break;
            }
        }
        if yystate == 82 as libc::c_int {
            yyresult = 0 as libc::c_int;
            current_block = 18382833222391614872;
            break;
        } else {
            yyn = yypact[yystate as usize] as libc::c_int;
            if yyn == -(211 as libc::c_int) {
                current_block = 15907462552534846405;
            } else {
                if yychar == -(2 as libc::c_int) {
                    if yydebug != 0 {
                        fprintf(
                            stderr,
                            b"Reading a token: \0" as *const u8 as *const libc::c_char,
                        );
                    }
                    yychar = yylex(&mut yylval, p);
                }
                if yychar <= 0 as libc::c_int {
                    yytoken = 0 as libc::c_int;
                    yychar = yytoken;
                    if yydebug != 0 {
                        fprintf(
                            stderr,
                            b"Now at end of input.\n\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                } else {
                    if 0 as libc::c_int <= yychar {
                        if yychar <= 301 as libc::c_int {
                            yytoken = yytranslate[yychar as usize] as libc::c_int;
                        } else {
                            yytoken = 2 as libc::c_int;
                        }
                    } else {
                        yytoken = 2 as libc::c_int;
                    }
                    if yydebug != 0 {
                        fprintf(
                            stderr,
                            b"%s \0" as *const u8 as *const libc::c_char,
                            b"Next token is\0" as *const u8 as *const libc::c_char,
                        );
                        yy_symbol_print(
                            stderr,
                            yytoken,
                            &mut yylval as *mut YYSTYPE as *const YYSTYPE,
                            p,
                        );
                        fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
                    }
                }
                yyn += yytoken;
                if yyn < 0 as libc::c_int {
                    current_block = 15907462552534846405;
                } else if (793 as libc::c_int) < yyn {
                    current_block = 15907462552534846405;
                } else if yycheck[yyn as usize] as libc::c_int != yytoken {
                    current_block = 15907462552534846405;
                } else {
                    yyn = yytable[yyn as usize] as libc::c_int;
                    if yyn <= 0 as libc::c_int {
                        if yyn == -(122 as libc::c_int) {
                            current_block = 14129452175553297227;
                        } else {
                            yyn = -yyn;
                            current_block = 367455324382736413;
                        }
                    } else {
                        if yyerrstatus != 0 {
                            yyerrstatus -= 1;
                        }
                        if yydebug != 0 {
                            fprintf(
                                stderr,
                                b"%s \0" as *const u8 as *const libc::c_char,
                                b"Shifting\0" as *const u8 as *const libc::c_char,
                            );
                            yy_symbol_print(
                                stderr,
                                yytoken,
                                &mut yylval as *mut YYSTYPE as *const YYSTYPE,
                                p,
                            );
                            fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
                        }
                        yystate = yyn;
                        yyvsp = yyvsp.offset(1);
                        *yyvsp = yylval;
                        yychar = -(2 as libc::c_int);
                        current_block = 17150304926150652878;
                    }
                }
            }
            match current_block {
                15907462552534846405 => {
                    yyn = yydefact[yystate as usize] as libc::c_int;
                    if yyn == 0 as libc::c_int {
                        current_block = 14129452175553297227;
                    } else {
                        current_block = 367455324382736413;
                    }
                }
                _ => {}
            }
            match current_block {
                367455324382736413 => {
                    yylen = yyr2[yyn as usize] as libc::c_int;
                    yyval = *yyvsp.offset((1 as libc::c_int - yylen) as isize);
                    if yydebug != 0 {
                        yy_reduce_print(yyssp, yyvsp, yyn, p);
                    }
                    match yyn {
                        2 => {
                            (*p)
                                .lval = (*yyvsp.offset(0 as libc::c_int as isize)).nd
                                as *mut libc::c_void;
                        }
                        3 => {
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        4 => {
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        5 => {
                            yyval.nd = 0 as *mut libc::c_void as *mut node;
                        }
                        6 => {
                            yyval.nd = node_nodes_new();
                            node_lineinfo(p, yyval.nd);
                            if !((*yyvsp.offset(0 as libc::c_int as isize)).nd).is_null()
                            {
                                node_nodes_add(
                                    yyval.nd,
                                    (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                );
                                node_lineinfo(
                                    p,
                                    (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                );
                            }
                        }
                        7 => {
                            yyval.nd = (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd;
                            if !((*yyvsp.offset(0 as libc::c_int as isize)).nd).is_null()
                            {
                                if !((*yyvsp.offset(-(2 as libc::c_int) as isize)).nd)
                                    .is_null()
                                {
                                    node_nodes_add(
                                        yyval.nd,
                                        (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                    );
                                } else {
                                    let ref mut fresh17 = (*yyvsp
                                        .offset(-(2 as libc::c_int) as isize))
                                        .nd;
                                    *fresh17 = (*yyvsp.offset(0 as libc::c_int as isize)).nd;
                                }
                                node_lineinfo(
                                    p,
                                    (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                );
                            }
                        }
                        8 => {
                            yyval
                                .nd = node_ns_new(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        9 => {
                            yyval
                                .nd = node_ns_new(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        10 => {
                            yyval
                                .nd = node_import_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).id,
                            );
                        }
                        11 => {
                            tmp___0 = node_method_new(
                                (*yyvsp.offset(-(4 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                            yyval
                                .nd = node_let_new(
                                (*yyvsp.offset(-(6 as libc::c_int) as isize)).id,
                                tmp___0,
                            );
                        }
                        12 => {
                            tmp___1 = node_method_new(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                            yyval
                                .nd = node_let_new(
                                (*yyvsp.offset(-(5 as libc::c_int) as isize)).id,
                                tmp___1,
                            );
                        }
                        14 => {
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        15 => {
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        16 => {
                            yyval.nd = 0 as *mut libc::c_void as *mut node;
                        }
                        17 => {
                            yyval.nd = node_nodes_new();
                            node_lineinfo(p, yyval.nd);
                            if !((*yyvsp.offset(0 as libc::c_int as isize)).nd).is_null()
                            {
                                node_nodes_add(
                                    yyval.nd,
                                    (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                );
                                node_lineinfo(
                                    p,
                                    (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                );
                            }
                        }
                        18 => {
                            yyval.nd = (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd;
                            if !((*yyvsp.offset(0 as libc::c_int as isize)).nd).is_null()
                            {
                                if !((*yyvsp.offset(-(2 as libc::c_int) as isize)).nd)
                                    .is_null()
                                {
                                    node_nodes_add(
                                        yyval.nd,
                                        (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                    );
                                } else {
                                    let ref mut fresh18 = (*yyvsp
                                        .offset(-(2 as libc::c_int) as isize))
                                        .nd;
                                    *fresh18 = (*yyvsp.offset(0 as libc::c_int as isize)).nd;
                                }
                                node_lineinfo(
                                    p,
                                    (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                );
                            }
                        }
                        19 => {
                            yyval
                                .nd = node_let_new(
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        20 => {
                            tmp___2 = node_lambda_new(
                                (*yyvsp.offset(-(4 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                            yyval
                                .nd = node_let_new(
                                (*yyvsp.offset(-(6 as libc::c_int) as isize)).id,
                                tmp___2,
                            );
                        }
                        21 => {
                            tmp___3 = node_lambda_new(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                            yyval
                                .nd = node_let_new(
                                (*yyvsp.offset(-(5 as libc::c_int) as isize)).id,
                                tmp___3,
                            );
                        }
                        22 => {
                            tmp___4 = node_lambda_new(
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                            yyval
                                .nd = node_let_new(
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).id,
                                tmp___4,
                            );
                        }
                        23 => {
                            yyval
                                .nd = node_let_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).id,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                            );
                        }
                        24 => {
                            yyval.nd = node_skip_new();
                        }
                        25 => {
                            yyval
                                .nd = node_emit_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        26 => {
                            yyval
                                .nd = node_return_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        30 => {
                            yyval
                                .id = (*((*yyvsp.offset(0 as libc::c_int as isize)).nd
                                as *mut node_str))
                                .value;
                        }
                        31 => {
                            yyval
                                .nd = node_op_new(
                                b"+\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        32 => {
                            yyval
                                .nd = node_op_new(
                                b"-\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        33 => {
                            yyval
                                .nd = node_op_new(
                                b"*\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        34 => {
                            yyval
                                .nd = node_op_new(
                                b"/\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        35 => {
                            yyval
                                .nd = node_op_new(
                                b"%\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        36 => {
                            yyval
                                .nd = node_op_new(
                                b"|\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        37 => {
                            yyval
                                .nd = node_op_new(
                                b"&\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        38 => {
                            yyval
                                .nd = node_op_new(
                                b">\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        39 => {
                            yyval
                                .nd = node_op_new(
                                b">=\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        40 => {
                            yyval
                                .nd = node_op_new(
                                b"<\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        41 => {
                            yyval
                                .nd = node_op_new(
                                b"<=\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        42 => {
                            yyval
                                .nd = node_op_new(
                                b"==\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        43 => {
                            yyval
                                .nd = node_op_new(
                                b"!=\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        44 => {
                            yyval.nd = (*yyvsp.offset(0 as libc::c_int as isize)).nd;
                        }
                        45 => {
                            yyval
                                .nd = node_op_new(
                                b"-\0" as *const u8 as *const libc::c_char,
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        46 => {
                            yyval
                                .nd = node_op_new(
                                b"!\0" as *const u8 as *const libc::c_char,
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        47 => {
                            yyval
                                .nd = node_op_new(
                                b"~\0" as *const u8 as *const libc::c_char,
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        48 => {
                            yyval
                                .nd = node_op_new(
                                b"&&\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        49 => {
                            yyval
                                .nd = node_op_new(
                                b"||\0" as *const u8 as *const libc::c_char,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        50 => {
                            yyval
                                .nd = node_lambda_new(
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        51 => {
                            yyval
                                .nd = node_lambda_new(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        52 => {
                            yyval
                                .nd = node_if_new(
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        54 => {
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        55 => {
                            yyval.nd = 0 as *mut libc::c_void as *mut node;
                        }
                        56 => {
                            yyval.nd = (*yyvsp.offset(0 as libc::c_int as isize)).nd;
                        }
                        57 => {
                            yyval.nd = 0 as *mut libc::c_void as *mut node;
                        }
                        58 => {
                            yyval
                                .nd = node_array_headers(
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        60 => {
                            yyval
                                .nd = node_pair_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        61 => {
                            yyval
                                .nd = node_splat_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        62 => {
                            yyval.nd = node_array_new();
                            node_array_add(
                                yyval.nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        63 => {
                            yyval.nd = (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd;
                            node_array_add(
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        68 => {
                            yyval
                                .nd = node_ident_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).id,
                            );
                        }
                        69 => {
                            if (*(*yyvsp.offset(-(1 as libc::c_int) as isize)).nd).type_0
                                as libc::c_uint == 9 as libc::c_uint
                            {
                                lambda = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd
                                    as *mut node_lambda;
                                if (*lambda).block != 0 {
                                    (*lambda).block = 0 as libc::c_int;
                                }
                            }
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        70 => {
                            yyval
                                .nd = node_array_headers(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        71 => {
                            yyval.nd = node_array_new();
                        }
                        73 => {
                            yyval.nd = node_nil();
                        }
                        74 => {
                            yyval.nd = node_true();
                        }
                        75 => {
                            yyval.nd = node_false();
                        }
                        76 => {
                            yyval
                                .nd = node_obj_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).id,
                            );
                        }
                        77 => {
                            yyval
                                .nd = node_call_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).id,
                                0 as *mut libc::c_void as *mut node,
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        78 => {
                            yyval
                                .nd = node_call_new(
                                (*yyvsp.offset(-(4 as libc::c_int) as isize)).id,
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        79 => {
                            yyval
                                .nd = node_call_new(
                                (*yyvsp.offset(-(4 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(-(6 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        80 => {
                            yyval
                                .nd = node_call_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd,
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        81 => {
                            yyval
                                .nd = node_fcall_new(
                                (*yyvsp.offset(-(5 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        82 => {
                            yyval
                                .nd = node_genfunc_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).id,
                            );
                        }
                        83 => {
                            yyval.nd = 0 as *mut libc::c_void as *mut node;
                        }
                        85 => {
                            yyval
                                .nd = node_ident_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).id,
                            );
                        }
                        88 => {
                            yyval.nd = node_nil();
                        }
                        89 => {
                            yyval.nd = node_true();
                        }
                        90 => {
                            yyval.nd = node_false();
                        }
                        91 => {
                            yyval.nd = node_pattern_new(NODE_PARRAY);
                        }
                        92 => {
                            tmp___5 = node_pattern_new(NODE_PARRAY);
                            yyval
                                .nd = node_ns_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).id,
                                tmp___5,
                            );
                        }
                        93 => {
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        94 => {
                            yyval
                                .nd = node_ns_new(
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        95 => {
                            yyval
                                .nd = node_ns_new(
                                (*yyvsp.offset(0 as libc::c_int as isize)).id,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                            );
                        }
                        96 => {
                            yyval.nd = node_pattern_new(NODE_PARRAY);
                            node_pattern_add(
                                yyval.nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        97 => {
                            yyval.nd = (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd;
                            node_pattern_add(
                                yyval.nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        98 => {
                            yyval.nd = node_pattern_new(NODE_PSTRUCT);
                            tmp___6 = node_pair_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                            node_pattern_add(yyval.nd, tmp___6);
                        }
                        99 => {
                            yyval.nd = (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd;
                            tmp___7 = node_pair_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).id,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                            node_pattern_add(yyval.nd, tmp___7);
                        }
                        101 => {
                            yyval
                                .nd = node_psplat_new(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                0 as *mut libc::c_void as *mut node,
                            );
                        }
                        102 => {
                            yyval
                                .nd = node_psplat_new(
                                (*yyvsp.offset(-(5 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        103 => {
                            yyval
                                .nd = node_psplat_new(
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                0 as *mut libc::c_void as *mut node,
                            );
                        }
                        104 => {
                            yyval
                                .nd = node_psplat_new(
                                0 as *mut libc::c_void as *mut node,
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        106 => {
                            yyval
                                .nd = node_psplat_new(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                                0 as *mut libc::c_void as *mut node,
                            );
                        }
                        107 => {
                            tmp___8 = node_pattern_new(NODE_PARRAY);
                            yyval
                                .nd = node_plambda_new(
                                tmp___8,
                                0 as *mut libc::c_void as *mut node,
                            );
                        }
                        108 => {
                            tmp___9 = node_pattern_new(NODE_PARRAY);
                            yyval
                                .nd = node_plambda_new(
                                tmp___9,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        109 => {
                            yyval
                                .nd = node_plambda_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                                0 as *mut libc::c_void as *mut node,
                            );
                        }
                        110 => {
                            yyval
                                .nd = node_plambda_new(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        111 => {
                            yyval
                                .nd = node_plambda_body(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                        }
                        112 => {
                            tmp___10 = node_plambda_body(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).nd,
                            );
                            yyval
                                .nd = node_plambda_add(
                                (*yyvsp.offset(-(3 as libc::c_int) as isize)).nd,
                                tmp___10,
                            );
                        }
                        113 => {
                            yyval
                                .nd = node_block_new(
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        114 => {
                            yyval
                                .nd = node_lambda_new(
                                (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                        }
                        115 => {
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        116 => {
                            tmp___11 = node_plambda_new(
                                0 as *mut libc::c_void as *mut node,
                                0 as *mut libc::c_void as *mut node,
                            );
                            e = tmp___11;
                            tmp___12 = node_plambda_body(
                                e,
                                (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd,
                            );
                            yyval
                                .nd = node_plambda_add(
                                (*yyvsp.offset(-(4 as libc::c_int) as isize)).nd,
                                tmp___12,
                            );
                        }
                        117 => {
                            yyval.nd = 0 as *mut libc::c_void as *mut node;
                        }
                        118 => {
                            yyval.nd = (*yyvsp.offset(-(1 as libc::c_int) as isize)).nd;
                        }
                        119 => {
                            yyval.nd = 0 as *mut libc::c_void as *mut node;
                        }
                        121 => {
                            yyval.nd = node_args_new();
                            node_args_add(
                                yyval.nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).id,
                            );
                        }
                        122 => {
                            yyval.nd = (*yyvsp.offset(-(2 as libc::c_int) as isize)).nd;
                            node_args_add(
                                yyval.nd,
                                (*yyvsp.offset(0 as libc::c_int as isize)).id,
                            );
                        }
                        126 => {
                            yyerrstatus = 0 as libc::c_int;
                        }
                        127 => {
                            yyerrstatus = 0 as libc::c_int;
                        }
                        _ => {}
                    }
                    if yydebug != 0 {
                        fprintf(
                            stderr,
                            b"%s \0" as *const u8 as *const libc::c_char,
                            b"-> $$ =\0" as *const u8 as *const libc::c_char,
                        );
                        yy_symbol_print(
                            stderr,
                            yyr1[yyn as usize] as libc::c_int,
                            &mut yyval as *mut YYSTYPE as *const YYSTYPE,
                            p,
                        );
                        fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
                    }
                    yyvsp = yyvsp.offset(-(yylen as isize));
                    yyssp = yyssp.offset(-(yylen as isize));
                    yylen = 0 as libc::c_int;
                    if yydebug != 0 {
                        yy_stack_print(yyss, yyssp);
                    }
                    yyvsp = yyvsp.offset(1);
                    *yyvsp = yyval;
                    yylhs = yyr1[yyn as usize] as libc::c_int - 61 as libc::c_int;
                    yyi = yypgoto[yylhs as usize] as libc::c_int + *yyssp as libc::c_int;
                    if 0 as libc::c_int <= yyi {
                        if yyi <= 793 as libc::c_int {
                            if yycheck[yyi as usize] as libc::c_int
                                == *yyssp as libc::c_int
                            {
                                yystate = yytable[yyi as usize] as yy_state_fast_t;
                            } else {
                                yystate = yydefgoto[yylhs as usize] as yy_state_fast_t;
                            }
                        } else {
                            yystate = yydefgoto[yylhs as usize] as yy_state_fast_t;
                        }
                    } else {
                        yystate = yydefgoto[yylhs as usize] as yy_state_fast_t;
                    }
                }
                14129452175553297227 => {
                    if yychar == -(2 as libc::c_int) {
                        yytoken = -(2 as libc::c_int);
                    } else {
                        if 0 as libc::c_int <= yychar {
                            if yychar <= 301 as libc::c_int {
                                tmp___13 = yytranslate[yychar as usize] as libc::c_int;
                            } else {
                                tmp___13 = 2 as libc::c_int;
                            }
                        } else {
                            tmp___13 = 2 as libc::c_int;
                        }
                        yytoken = tmp___13;
                    }
                    if yyerrstatus == 0 {
                        yynerrs += 1;
                        yymsgp = b"syntax error\0" as *const u8 as *const libc::c_char;
                        yysyntax_error_status = yysyntax_error(
                            &mut yymsg_alloc,
                            &mut yymsg,
                            yyssp,
                            yytoken,
                        );
                        if yysyntax_error_status == 0 as libc::c_int {
                            yymsgp = yymsg as *const libc::c_char;
                        } else if yysyntax_error_status == 1 as libc::c_int {
                            if yymsg as libc::c_ulong
                                != yymsgbuf.as_mut_ptr() as libc::c_ulong
                            {
                                free(yymsg as *mut libc::c_void);
                            }
                            tmp___14 = malloc(yymsg_alloc as libc::c_ulong);
                            yymsg = tmp___14 as *mut libc::c_char;
                            if yymsg.is_null() {
                                yymsg = yymsgbuf.as_mut_ptr();
                                yymsg_alloc = ::std::mem::size_of::<[libc::c_char; 128]>()
                                    as libc::c_ulong as libc::c_long;
                                yysyntax_error_status = 2 as libc::c_int;
                            } else {
                                yysyntax_error_status = yysyntax_error(
                                    &mut yymsg_alloc,
                                    &mut yymsg,
                                    yyssp,
                                    yytoken,
                                );
                                yymsgp = yymsg as *const libc::c_char;
                            }
                        }
                        yyerror(p, yymsgp);
                        if yysyntax_error_status == 2 as libc::c_int {
                            current_block = 10735487318834209902;
                            break;
                        }
                    }
                    if yyerrstatus == 3 as libc::c_int {
                        if yychar <= 0 as libc::c_int {
                            if yychar == 0 as libc::c_int {
                                current_block = 13242541486230035560;
                                break;
                            }
                        } else {
                            yydestruct(
                                b"Error: discarding\0" as *const u8 as *const libc::c_char,
                                yytoken,
                                &mut yylval,
                                p,
                            );
                            yychar = -(2 as libc::c_int);
                        }
                    }
                    yyerrstatus = 3 as libc::c_int;
                    loop {
                        yyn = yypact[yystate as usize] as libc::c_int;
                        if !(yyn == -(211 as libc::c_int)) {
                            yyn += 1;
                            if 0 as libc::c_int <= yyn {
                                if yyn <= 793 as libc::c_int {
                                    if yycheck[yyn as usize] as libc::c_int == 1 as libc::c_int
                                    {
                                        yyn = yytable[yyn as usize] as libc::c_int;
                                        if (0 as libc::c_int) < yyn {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        if yyssp as libc::c_ulong == yyss as libc::c_ulong {
                            current_block = 13242541486230035560;
                            break '_yysetstate;
                        }
                        yydestruct(
                            b"Error: popping\0" as *const u8 as *const libc::c_char,
                            yystos[yystate as usize] as libc::c_int,
                            yyvsp,
                            p,
                        );
                        yyvsp = yyvsp.offset(-1);
                        yyssp = yyssp.offset(-1);
                        yystate = *yyssp as yy_state_fast_t;
                        if yydebug != 0 {
                            yy_stack_print(yyss, yyssp);
                        }
                    }
                    yyvsp = yyvsp.offset(1);
                    *yyvsp = yylval;
                    if yydebug != 0 {
                        fprintf(
                            stderr,
                            b"%s \0" as *const u8 as *const libc::c_char,
                            b"Shifting\0" as *const u8 as *const libc::c_char,
                        );
                        yy_symbol_print(
                            stderr,
                            yystos[yyn as usize] as libc::c_int,
                            yyvsp as *const YYSTYPE,
                            p,
                        );
                        fprintf(stderr, b"\n\0" as *const u8 as *const libc::c_char);
                    }
                    yystate = yyn;
                }
                _ => {}
            }
            yyssp = yyssp.offset(1);
        }
    }
    match current_block {
        10735487318834209902 => {
            yyerror(p, b"memory exhausted\0" as *const u8 as *const libc::c_char);
            yyresult = 2 as libc::c_int;
        }
        13242541486230035560 => {
            yyresult = 1 as libc::c_int;
        }
        _ => {}
    }
    if yychar != -(2 as libc::c_int) {
        if 0 as libc::c_int <= yychar {
            if yychar <= 301 as libc::c_int {
                yytoken = yytranslate[yychar as usize] as libc::c_int;
            } else {
                yytoken = 2 as libc::c_int;
            }
        } else {
            yytoken = 2 as libc::c_int;
        }
        yydestruct(
            b"Cleanup: discarding lookahead\0" as *const u8 as *const libc::c_char,
            yytoken,
            &mut yylval,
            p,
        );
    }
    yyvsp = yyvsp.offset(-(yylen as isize));
    yyssp = yyssp.offset(-(yylen as isize));
    if yydebug != 0 {
        yy_stack_print(yyss, yyssp);
    }
    while yyssp as libc::c_ulong != yyss as libc::c_ulong {
        yydestruct(
            b"Cleanup: popping\0" as *const u8 as *const libc::c_char,
            yystos[*yyssp as usize] as libc::c_int,
            yyvsp,
            p,
        );
        yyvsp = yyvsp.offset(-1);
        yyssp = yyssp.offset(-1);
    }
    if yyss as libc::c_ulong != yyssa.as_mut_ptr() as libc::c_ulong {
        free(yyss as *mut libc::c_void);
    }
    if yymsg as libc::c_ulong != yymsgbuf.as_mut_ptr() as libc::c_ulong {
        free(yymsg as *mut libc::c_void);
    }
    return yyresult;
}
pub static mut yyleng: libc::c_int = 0;
static mut yy_buffer_stack_top: size_t = 0 as libc::c_int as size_t;
static mut yy_buffer_stack_max: size_t = 0 as libc::c_int as size_t;
static mut yy_buffer_stack: *mut YY_BUFFER_STATE = 0 as *const libc::c_void
    as *mut libc::c_void as *mut YY_BUFFER_STATE;
static mut yy_hold_char: libc::c_char = 0;
static mut yy_n_chars: libc::c_int = 0;
static mut yy_c_buf_p: *mut libc::c_char = 0 as *const libc::c_void as *mut libc::c_void
    as *mut libc::c_char;
static mut yy_init: libc::c_int = 0 as libc::c_int;
static mut yy_start: libc::c_int = 0 as libc::c_int;
static mut yy_did_buffer_switch_on_eof: libc::c_int = 0;
pub static mut yyin: *mut FILE = 0 as *const libc::c_void as *mut libc::c_void
    as *mut FILE;
pub static mut yyout: *mut FILE = 0 as *const libc::c_void as *mut libc::c_void
    as *mut FILE;
pub static mut yylineno: libc::c_int = 1 as libc::c_int;
pub static mut yytext: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;
static mut yy_accept: [flex_int16_t; 290] = [
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    14 as libc::c_int as flex_int16_t,
    41 as libc::c_int as flex_int16_t,
    42 as libc::c_int as flex_int16_t,
    3 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    2 as libc::c_int as flex_int16_t,
    40 as libc::c_int as flex_int16_t,
    4 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    41 as libc::c_int as flex_int16_t,
    8 as libc::c_int as flex_int16_t,
    20 as libc::c_int as flex_int16_t,
    10 as libc::c_int as flex_int16_t,
    42 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    39 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    40 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    39 as libc::c_int as flex_int16_t,
    7 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    50 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    44 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    14 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    12 as libc::c_int as flex_int16_t,
    41 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    3 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    2 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    17 as libc::c_int as flex_int16_t,
    40 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    4 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    51 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    8 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    15 as libc::c_int as flex_int16_t,
    9 as libc::c_int as flex_int16_t,
    20 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    16 as libc::c_int as flex_int16_t,
    10 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    11 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    38 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    22 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    39 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    13 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    7 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    52 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    12 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    17 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    46 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    48 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    51 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    15 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    9 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    16 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    11 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    31 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    33 as libc::c_int as flex_int16_t,
    34 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    13 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    46 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    25 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    24 as libc::c_int as flex_int16_t,
    35 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    25 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    29 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    36 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    24 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    30 as libc::c_int as flex_int16_t,
    32 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    28 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
];
static mut yy_ec: [YY_CHAR; 256] = [
    0 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    2 as libc::c_int as YY_CHAR,
    3 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    4 as libc::c_int as YY_CHAR,
    5 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    7 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    8 as libc::c_int as YY_CHAR,
    9 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    10 as libc::c_int as YY_CHAR,
    11 as libc::c_int as YY_CHAR,
    12 as libc::c_int as YY_CHAR,
    13 as libc::c_int as YY_CHAR,
    10 as libc::c_int as YY_CHAR,
    14 as libc::c_int as YY_CHAR,
    15 as libc::c_int as YY_CHAR,
    16 as libc::c_int as YY_CHAR,
    17 as libc::c_int as YY_CHAR,
    18 as libc::c_int as YY_CHAR,
    18 as libc::c_int as YY_CHAR,
    18 as libc::c_int as YY_CHAR,
    18 as libc::c_int as YY_CHAR,
    18 as libc::c_int as YY_CHAR,
    18 as libc::c_int as YY_CHAR,
    18 as libc::c_int as YY_CHAR,
    19 as libc::c_int as YY_CHAR,
    19 as libc::c_int as YY_CHAR,
    20 as libc::c_int as YY_CHAR,
    10 as libc::c_int as YY_CHAR,
    21 as libc::c_int as YY_CHAR,
    22 as libc::c_int as YY_CHAR,
    23 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    24 as libc::c_int as YY_CHAR,
    25 as libc::c_int as YY_CHAR,
    25 as libc::c_int as YY_CHAR,
    25 as libc::c_int as YY_CHAR,
    25 as libc::c_int as YY_CHAR,
    25 as libc::c_int as YY_CHAR,
    25 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    27 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    28 as libc::c_int as YY_CHAR,
    10 as libc::c_int as YY_CHAR,
    29 as libc::c_int as YY_CHAR,
    24 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    30 as libc::c_int as YY_CHAR,
    25 as libc::c_int as YY_CHAR,
    31 as libc::c_int as YY_CHAR,
    32 as libc::c_int as YY_CHAR,
    33 as libc::c_int as YY_CHAR,
    34 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    35 as libc::c_int as YY_CHAR,
    36 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    37 as libc::c_int as YY_CHAR,
    38 as libc::c_int as YY_CHAR,
    39 as libc::c_int as YY_CHAR,
    40 as libc::c_int as YY_CHAR,
    41 as libc::c_int as YY_CHAR,
    42 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    43 as libc::c_int as YY_CHAR,
    44 as libc::c_int as YY_CHAR,
    45 as libc::c_int as YY_CHAR,
    46 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    47 as libc::c_int as YY_CHAR,
    48 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    26 as libc::c_int as YY_CHAR,
    49 as libc::c_int as YY_CHAR,
    50 as libc::c_int as YY_CHAR,
    24 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    51 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    52 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    53 as libc::c_int as YY_CHAR,
    54 as libc::c_int as YY_CHAR,
    54 as libc::c_int as YY_CHAR,
    54 as libc::c_int as YY_CHAR,
    54 as libc::c_int as YY_CHAR,
    54 as libc::c_int as YY_CHAR,
    54 as libc::c_int as YY_CHAR,
    54 as libc::c_int as YY_CHAR,
    54 as libc::c_int as YY_CHAR,
    55 as libc::c_int as YY_CHAR,
    55 as libc::c_int as YY_CHAR,
    55 as libc::c_int as YY_CHAR,
    55 as libc::c_int as YY_CHAR,
    56 as libc::c_int as YY_CHAR,
    56 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
];
static mut yy_meta: [YY_CHAR; 57] = [
    0 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    2 as libc::c_int as YY_CHAR,
    2 as libc::c_int as YY_CHAR,
    2 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    2 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    3 as libc::c_int as YY_CHAR,
    3 as libc::c_int as YY_CHAR,
    3 as libc::c_int as YY_CHAR,
    4 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    5 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    5 as libc::c_int as YY_CHAR,
    5 as libc::c_int as YY_CHAR,
    5 as libc::c_int as YY_CHAR,
    5 as libc::c_int as YY_CHAR,
    5 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    1 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
    6 as libc::c_int as YY_CHAR,
];
static mut yy_base: [flex_int16_t; 324] = [
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    952 as libc::c_int as flex_int16_t,
    953 as libc::c_int as flex_int16_t,
    55 as libc::c_int as flex_int16_t,
    61 as libc::c_int as flex_int16_t,
    929 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    947 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    77 as libc::c_int as flex_int16_t,
    88 as libc::c_int as flex_int16_t,
    57 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    100 as libc::c_int as flex_int16_t,
    106 as libc::c_int as flex_int16_t,
    112 as libc::c_int as flex_int16_t,
    118 as libc::c_int as flex_int16_t,
    109 as libc::c_int as flex_int16_t,
    115 as libc::c_int as flex_int16_t,
    156 as libc::c_int as flex_int16_t,
    133 as libc::c_int as flex_int16_t,
    139 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    953 as libc::c_int as flex_int16_t,
    125 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    135 as libc::c_int as flex_int16_t,
    136 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    161 as libc::c_int as flex_int16_t,
    163 as libc::c_int as flex_int16_t,
    183 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    101 as libc::c_int as flex_int16_t,
    177 as libc::c_int as flex_int16_t,
    220 as libc::c_int as flex_int16_t,
    898 as libc::c_int as flex_int16_t,
    897 as libc::c_int as flex_int16_t,
    896 as libc::c_int as flex_int16_t,
    895 as libc::c_int as flex_int16_t,
    894 as libc::c_int as flex_int16_t,
    226 as libc::c_int as flex_int16_t,
    941 as libc::c_int as flex_int16_t,
    232 as libc::c_int as flex_int16_t,
    905 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    246 as libc::c_int as flex_int16_t,
    60 as libc::c_int as flex_int16_t,
    922 as libc::c_int as flex_int16_t,
    938 as libc::c_int as flex_int16_t,
    937 as libc::c_int as flex_int16_t,
    253 as libc::c_int as flex_int16_t,
    259 as libc::c_int as flex_int16_t,
    936 as libc::c_int as flex_int16_t,
    270 as libc::c_int as flex_int16_t,
    935 as libc::c_int as flex_int16_t,
    276 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    818 as libc::c_int as flex_int16_t,
    178 as libc::c_int as flex_int16_t,
    795 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    752 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    730 as libc::c_int as flex_int16_t,
    303 as libc::c_int as flex_int16_t,
    726 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    719 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    718 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    82 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    335 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    643 as libc::c_int as flex_int16_t,
    640 as libc::c_int as flex_int16_t,
    638 as libc::c_int as flex_int16_t,
    627 as libc::c_int as flex_int16_t,
    625 as libc::c_int as flex_int16_t,
    346 as libc::c_int as flex_int16_t,
    671 as libc::c_int as flex_int16_t,
    352 as libc::c_int as flex_int16_t,
    358 as libc::c_int as flex_int16_t,
    364 as libc::c_int as flex_int16_t,
    669 as libc::c_int as flex_int16_t,
    370 as libc::c_int as flex_int16_t,
    376 as libc::c_int as flex_int16_t,
    382 as libc::c_int as flex_int16_t,
    632 as libc::c_int as flex_int16_t,
    388 as libc::c_int as flex_int16_t,
    55 as libc::c_int as flex_int16_t,
    953 as libc::c_int as flex_int16_t,
    583 as libc::c_int as flex_int16_t,
    577 as libc::c_int as flex_int16_t,
    564 as libc::c_int as flex_int16_t,
    561 as libc::c_int as flex_int16_t,
    560 as libc::c_int as flex_int16_t,
    187 as libc::c_int as flex_int16_t,
    168 as libc::c_int as flex_int16_t,
    237 as libc::c_int as flex_int16_t,
    188 as libc::c_int as flex_int16_t,
    216 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    252 as libc::c_int as flex_int16_t,
    358 as libc::c_int as flex_int16_t,
    363 as libc::c_int as flex_int16_t,
    364 as libc::c_int as flex_int16_t,
    367 as libc::c_int as flex_int16_t,
    303 as libc::c_int as flex_int16_t,
    368 as libc::c_int as flex_int16_t,
    374 as libc::c_int as flex_int16_t,
    369 as libc::c_int as flex_int16_t,
    414 as libc::c_int as flex_int16_t,
    603 as libc::c_int as flex_int16_t,
    420 as libc::c_int as flex_int16_t,
    381 as libc::c_int as flex_int16_t,
    554 as libc::c_int as flex_int16_t,
    549 as libc::c_int as flex_int16_t,
    532 as libc::c_int as flex_int16_t,
    520 as libc::c_int as flex_int16_t,
    562 as libc::c_int as flex_int16_t,
    520 as libc::c_int as flex_int16_t,
    426 as libc::c_int as flex_int16_t,
    556 as libc::c_int as flex_int16_t,
    953 as libc::c_int as flex_int16_t,
    555 as libc::c_int as flex_int16_t,
    550 as libc::c_int as flex_int16_t,
    432 as libc::c_int as flex_int16_t,
    544 as libc::c_int as flex_int16_t,
    538 as libc::c_int as flex_int16_t,
    438 as libc::c_int as flex_int16_t,
    532 as libc::c_int as flex_int16_t,
    527 as libc::c_int as flex_int16_t,
    510 as libc::c_int as flex_int16_t,
    444 as libc::c_int as flex_int16_t,
    507 as libc::c_int as flex_int16_t,
    497 as libc::c_int as flex_int16_t,
    495 as libc::c_int as flex_int16_t,
    435 as libc::c_int as flex_int16_t,
    186 as libc::c_int as flex_int16_t,
    100 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    453 as libc::c_int as flex_int16_t,
    485 as libc::c_int as flex_int16_t,
    409 as libc::c_int as flex_int16_t,
    431 as libc::c_int as flex_int16_t,
    430 as libc::c_int as flex_int16_t,
    425 as libc::c_int as flex_int16_t,
    424 as libc::c_int as flex_int16_t,
    419 as libc::c_int as flex_int16_t,
    418 as libc::c_int as flex_int16_t,
    408 as libc::c_int as flex_int16_t,
    407 as libc::c_int as flex_int16_t,
    398 as libc::c_int as flex_int16_t,
    441 as libc::c_int as flex_int16_t,
    464 as libc::c_int as flex_int16_t,
    440 as libc::c_int as flex_int16_t,
    470 as libc::c_int as flex_int16_t,
    435 as libc::c_int as flex_int16_t,
    434 as libc::c_int as flex_int16_t,
    476 as libc::c_int as flex_int16_t,
    429 as libc::c_int as flex_int16_t,
    482 as libc::c_int as flex_int16_t,
    428 as libc::c_int as flex_int16_t,
    423 as libc::c_int as flex_int16_t,
    488 as libc::c_int as flex_int16_t,
    422 as libc::c_int as flex_int16_t,
    369 as libc::c_int as flex_int16_t,
    358 as libc::c_int as flex_int16_t,
    336 as libc::c_int as flex_int16_t,
    331 as libc::c_int as flex_int16_t,
    463 as libc::c_int as flex_int16_t,
    464 as libc::c_int as flex_int16_t,
    467 as libc::c_int as flex_int16_t,
    473 as libc::c_int as flex_int16_t,
    469 as libc::c_int as flex_int16_t,
    474 as libc::c_int as flex_int16_t,
    479 as libc::c_int as flex_int16_t,
    486 as libc::c_int as flex_int16_t,
    489 as libc::c_int as flex_int16_t,
    485 as libc::c_int as flex_int16_t,
    495 as libc::c_int as flex_int16_t,
    496 as libc::c_int as flex_int16_t,
    498 as libc::c_int as flex_int16_t,
    499 as libc::c_int as flex_int16_t,
    378 as libc::c_int as flex_int16_t,
    541 as libc::c_int as flex_int16_t,
    373 as libc::c_int as flex_int16_t,
    324 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    336 as libc::c_int as flex_int16_t,
    361 as libc::c_int as flex_int16_t,
    360 as libc::c_int as flex_int16_t,
    547 as libc::c_int as flex_int16_t,
    553 as libc::c_int as flex_int16_t,
    355 as libc::c_int as flex_int16_t,
    559 as libc::c_int as flex_int16_t,
    354 as libc::c_int as flex_int16_t,
    550 as libc::c_int as flex_int16_t,
    555 as libc::c_int as flex_int16_t,
    560 as libc::c_int as flex_int16_t,
    349 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    275 as libc::c_int as flex_int16_t,
    270 as libc::c_int as flex_int16_t,
    269 as libc::c_int as flex_int16_t,
    264 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    245 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    578 as libc::c_int as flex_int16_t,
    508 as libc::c_int as flex_int16_t,
    584 as libc::c_int as flex_int16_t,
    501 as libc::c_int as flex_int16_t,
    559 as libc::c_int as flex_int16_t,
    560 as libc::c_int as flex_int16_t,
    563 as libc::c_int as flex_int16_t,
    569 as libc::c_int as flex_int16_t,
    580 as libc::c_int as flex_int16_t,
    617 as libc::c_int as flex_int16_t,
    546 as libc::c_int as flex_int16_t,
    282 as libc::c_int as flex_int16_t,
    233 as libc::c_int as flex_int16_t,
    230 as libc::c_int as flex_int16_t,
    623 as libc::c_int as flex_int16_t,
    266 as libc::c_int as flex_int16_t,
    629 as libc::c_int as flex_int16_t,
    262 as libc::c_int as flex_int16_t,
    621 as libc::c_int as flex_int16_t,
    213 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    189 as libc::c_int as flex_int16_t,
    187 as libc::c_int as flex_int16_t,
    163 as libc::c_int as flex_int16_t,
    639 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    579 as libc::c_int as flex_int16_t,
    647 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    599 as libc::c_int as flex_int16_t,
    614 as libc::c_int as flex_int16_t,
    626 as libc::c_int as flex_int16_t,
    615 as libc::c_int as flex_int16_t,
    630 as libc::c_int as flex_int16_t,
    659 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    98 as libc::c_int as flex_int16_t,
    145 as libc::c_int as flex_int16_t,
    577 as libc::c_int as flex_int16_t,
    93 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    61 as libc::c_int as flex_int16_t,
    55 as libc::c_int as flex_int16_t,
    84 as libc::c_int as flex_int16_t,
    79 as libc::c_int as flex_int16_t,
    635 as libc::c_int as flex_int16_t,
    637 as libc::c_int as flex_int16_t,
    639 as libc::c_int as flex_int16_t,
    641 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    663 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    654 as libc::c_int as flex_int16_t,
    669 as libc::c_int as flex_int16_t,
    660 as libc::c_int as flex_int16_t,
    682 as libc::c_int as flex_int16_t,
    673 as libc::c_int as flex_int16_t,
    687 as libc::c_int as flex_int16_t,
    690 as libc::c_int as flex_int16_t,
    695 as libc::c_int as flex_int16_t,
    953 as libc::c_int as flex_int16_t,
    698 as libc::c_int as flex_int16_t,
    706 as libc::c_int as flex_int16_t,
    713 as libc::c_int as flex_int16_t,
    718 as libc::c_int as flex_int16_t,
    721 as libc::c_int as flex_int16_t,
    953 as libc::c_int as flex_int16_t,
    741 as libc::c_int as flex_int16_t,
    747 as libc::c_int as flex_int16_t,
    752 as libc::c_int as flex_int16_t,
    756 as libc::c_int as flex_int16_t,
    762 as libc::c_int as flex_int16_t,
    768 as libc::c_int as flex_int16_t,
    774 as libc::c_int as flex_int16_t,
    780 as libc::c_int as flex_int16_t,
    786 as libc::c_int as flex_int16_t,
    792 as libc::c_int as flex_int16_t,
    798 as libc::c_int as flex_int16_t,
    804 as libc::c_int as flex_int16_t,
    810 as libc::c_int as flex_int16_t,
    814 as libc::c_int as flex_int16_t,
    817 as libc::c_int as flex_int16_t,
    823 as libc::c_int as flex_int16_t,
    829 as libc::c_int as flex_int16_t,
    835 as libc::c_int as flex_int16_t,
    841 as libc::c_int as flex_int16_t,
    847 as libc::c_int as flex_int16_t,
    853 as libc::c_int as flex_int16_t,
    859 as libc::c_int as flex_int16_t,
    865 as libc::c_int as flex_int16_t,
    871 as libc::c_int as flex_int16_t,
    877 as libc::c_int as flex_int16_t,
    883 as libc::c_int as flex_int16_t,
    889 as libc::c_int as flex_int16_t,
    895 as libc::c_int as flex_int16_t,
    901 as libc::c_int as flex_int16_t,
    907 as libc::c_int as flex_int16_t,
    913 as libc::c_int as flex_int16_t,
    919 as libc::c_int as flex_int16_t,
    925 as libc::c_int as flex_int16_t,
    931 as libc::c_int as flex_int16_t,
];
static mut yy_def: [flex_int16_t; 324] = [
    0 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    292 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    293 as libc::c_int as flex_int16_t,
    293 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    295 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    296 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    298 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    301 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    302 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    303 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    304 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    307 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    308 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    295 as libc::c_int as flex_int16_t,
    296 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    310 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    298 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    301 as libc::c_int as flex_int16_t,
    302 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    303 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    304 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    313 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    314 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    316 as libc::c_int as flex_int16_t,
    307 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    308 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    318 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    310 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    313 as libc::c_int as flex_int16_t,
    314 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    316 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    318 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    320 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    322 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    323 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    320 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    322 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    323 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    0 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
];
static mut yy_nxt: [flex_int16_t; 1010] = [
    0 as libc::c_int as flex_int16_t,
    4 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    7 as libc::c_int as flex_int16_t,
    8 as libc::c_int as flex_int16_t,
    9 as libc::c_int as flex_int16_t,
    10 as libc::c_int as flex_int16_t,
    11 as libc::c_int as flex_int16_t,
    12 as libc::c_int as flex_int16_t,
    13 as libc::c_int as flex_int16_t,
    14 as libc::c_int as flex_int16_t,
    15 as libc::c_int as flex_int16_t,
    16 as libc::c_int as flex_int16_t,
    17 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    20 as libc::c_int as flex_int16_t,
    20 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    22 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    24 as libc::c_int as flex_int16_t,
    25 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    4 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    28 as libc::c_int as flex_int16_t,
    29 as libc::c_int as flex_int16_t,
    30 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    31 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    32 as libc::c_int as flex_int16_t,
    33 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    34 as libc::c_int as flex_int16_t,
    35 as libc::c_int as flex_int16_t,
    36 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    12 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    4 as libc::c_int as flex_int16_t,
    38 as libc::c_int as flex_int16_t,
    39 as libc::c_int as flex_int16_t,
    40 as libc::c_int as flex_int16_t,
    41 as libc::c_int as flex_int16_t,
    42 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    50 as libc::c_int as flex_int16_t,
    61 as libc::c_int as flex_int16_t,
    44 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    50 as libc::c_int as flex_int16_t,
    109 as libc::c_int as flex_int16_t,
    44 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    62 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    55 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    51 as libc::c_int as flex_int16_t,
    57 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    58 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    46 as libc::c_int as flex_int16_t,
    51 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    46 as libc::c_int as flex_int16_t,
    60 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    147 as libc::c_int as flex_int16_t,
    147 as libc::c_int as flex_int16_t,
    64 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    66 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    68 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    147 as libc::c_int as flex_int16_t,
    147 as libc::c_int as flex_int16_t,
    71 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    274 as libc::c_int as flex_int16_t,
    74 as libc::c_int as flex_int16_t,
    73 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    69 as libc::c_int as flex_int16_t,
    74 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    117 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    87 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    98 as libc::c_int as flex_int16_t,
    91 as libc::c_int as flex_int16_t,
    88 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    122 as libc::c_int as flex_int16_t,
    76 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    98 as libc::c_int as flex_int16_t,
    89 as libc::c_int as flex_int16_t,
    95 as libc::c_int as flex_int16_t,
    77 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    92 as libc::c_int as flex_int16_t,
    93 as libc::c_int as flex_int16_t,
    60 as libc::c_int as flex_int16_t,
    104 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    106 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    96 as libc::c_int as flex_int16_t,
    105 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    107 as libc::c_int as flex_int16_t,
    108 as libc::c_int as flex_int16_t,
    79 as libc::c_int as flex_int16_t,
    99 as libc::c_int as flex_int16_t,
    100 as libc::c_int as flex_int16_t,
    101 as libc::c_int as flex_int16_t,
    102 as libc::c_int as flex_int16_t,
    103 as libc::c_int as flex_int16_t,
    61 as libc::c_int as flex_int16_t,
    145 as libc::c_int as flex_int16_t,
    145 as libc::c_int as flex_int16_t,
    145 as libc::c_int as flex_int16_t,
    99 as libc::c_int as flex_int16_t,
    100 as libc::c_int as flex_int16_t,
    101 as libc::c_int as flex_int16_t,
    102 as libc::c_int as flex_int16_t,
    103 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    62 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    110 as libc::c_int as flex_int16_t,
    112 as libc::c_int as flex_int16_t,
    116 as libc::c_int as flex_int16_t,
    179 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    111 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    81 as libc::c_int as flex_int16_t,
    82 as libc::c_int as flex_int16_t,
    83 as libc::c_int as flex_int16_t,
    84 as libc::c_int as flex_int16_t,
    85 as libc::c_int as flex_int16_t,
    113 as libc::c_int as flex_int16_t,
    265 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    114 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    115 as libc::c_int as flex_int16_t,
    118 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    120 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    178 as libc::c_int as flex_int16_t,
    181 as libc::c_int as flex_int16_t,
    44 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    71 as libc::c_int as flex_int16_t,
    264 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    183 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    120 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    182 as libc::c_int as flex_int16_t,
    130 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    263 as libc::c_int as flex_int16_t,
    46 as libc::c_int as flex_int16_t,
    44 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    262 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    55 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    121 as libc::c_int as flex_int16_t,
    180 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    57 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    259 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    135 as libc::c_int as flex_int16_t,
    122 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    46 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    246 as libc::c_int as flex_int16_t,
    60 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    245 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    64 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    66 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    68 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    244 as libc::c_int as flex_int16_t,
    142 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    243 as libc::c_int as flex_int16_t,
    242 as libc::c_int as flex_int16_t,
    71 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    241 as libc::c_int as flex_int16_t,
    146 as libc::c_int as flex_int16_t,
    73 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    74 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    188 as libc::c_int as flex_int16_t,
    150 as libc::c_int as flex_int16_t,
    152 as libc::c_int as flex_int16_t,
    153 as libc::c_int as flex_int16_t,
    154 as libc::c_int as flex_int16_t,
    155 as libc::c_int as flex_int16_t,
    156 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    87 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    163 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    165 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    236 as libc::c_int as flex_int16_t,
    235 as libc::c_int as flex_int16_t,
    91 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    234 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    168 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    221 as libc::c_int as flex_int16_t,
    170 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    220 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    95 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    173 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    184 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    186 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    185 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    190 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    189 as libc::c_int as flex_int16_t,
    187 as libc::c_int as flex_int16_t,
    191 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    120 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    194 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    130 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    135 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    201 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    202 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    214 as libc::c_int as flex_int16_t,
    205 as libc::c_int as flex_int16_t,
    142 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    213 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    150 as libc::c_int as flex_int16_t,
    152 as libc::c_int as flex_int16_t,
    153 as libc::c_int as flex_int16_t,
    154 as libc::c_int as flex_int16_t,
    155 as libc::c_int as flex_int16_t,
    156 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    212 as libc::c_int as flex_int16_t,
    163 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    211 as libc::c_int as flex_int16_t,
    210 as libc::c_int as flex_int16_t,
    165 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    209 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    168 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    203 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    170 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    173 as libc::c_int as flex_int16_t,
    222 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    224 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    223 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    225 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    226 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    227 as libc::c_int as flex_int16_t,
    228 as libc::c_int as flex_int16_t,
    229 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    232 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    231 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    230 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    194 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    249 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    202 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    201 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    202 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    197 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    239 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    205 as libc::c_int as flex_int16_t,
    196 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    205 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    195 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    248 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    251 as libc::c_int as flex_int16_t,
    252 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    122 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    203 as libc::c_int as flex_int16_t,
    253 as libc::c_int as flex_int16_t,
    254 as libc::c_int as flex_int16_t,
    122 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    177 as libc::c_int as flex_int16_t,
    176 as libc::c_int as flex_int16_t,
    255 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    175 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    256 as libc::c_int as flex_int16_t,
    258 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    174 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    251 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    239 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    248 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    261 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    251 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    270 as libc::c_int as flex_int16_t,
    269 as libc::c_int as flex_int16_t,
    268 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    258 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    275 as libc::c_int as flex_int16_t,
    271 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    160 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    159 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    276 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    277 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    158 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    157 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    279 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    281 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    282 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    283 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    287 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    281 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    283 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    283 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    52 as libc::c_int as flex_int16_t,
    52 as libc::c_int as flex_int16_t,
    52 as libc::c_int as flex_int16_t,
    52 as libc::c_int as flex_int16_t,
    52 as libc::c_int as flex_int16_t,
    52 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    127 as libc::c_int as flex_int16_t,
    127 as libc::c_int as flex_int16_t,
    127 as libc::c_int as flex_int16_t,
    127 as libc::c_int as flex_int16_t,
    127 as libc::c_int as flex_int16_t,
    127 as libc::c_int as flex_int16_t,
    132 as libc::c_int as flex_int16_t,
    132 as libc::c_int as flex_int16_t,
    132 as libc::c_int as flex_int16_t,
    132 as libc::c_int as flex_int16_t,
    132 as libc::c_int as flex_int16_t,
    132 as libc::c_int as flex_int16_t,
    133 as libc::c_int as flex_int16_t,
    133 as libc::c_int as flex_int16_t,
    133 as libc::c_int as flex_int16_t,
    133 as libc::c_int as flex_int16_t,
    133 as libc::c_int as flex_int16_t,
    133 as libc::c_int as flex_int16_t,
    136 as libc::c_int as flex_int16_t,
    136 as libc::c_int as flex_int16_t,
    136 as libc::c_int as flex_int16_t,
    136 as libc::c_int as flex_int16_t,
    136 as libc::c_int as flex_int16_t,
    136 as libc::c_int as flex_int16_t,
    138 as libc::c_int as flex_int16_t,
    138 as libc::c_int as flex_int16_t,
    138 as libc::c_int as flex_int16_t,
    138 as libc::c_int as flex_int16_t,
    138 as libc::c_int as flex_int16_t,
    138 as libc::c_int as flex_int16_t,
    139 as libc::c_int as flex_int16_t,
    139 as libc::c_int as flex_int16_t,
    139 as libc::c_int as flex_int16_t,
    139 as libc::c_int as flex_int16_t,
    139 as libc::c_int as flex_int16_t,
    139 as libc::c_int as flex_int16_t,
    140 as libc::c_int as flex_int16_t,
    140 as libc::c_int as flex_int16_t,
    140 as libc::c_int as flex_int16_t,
    140 as libc::c_int as flex_int16_t,
    140 as libc::c_int as flex_int16_t,
    140 as libc::c_int as flex_int16_t,
    143 as libc::c_int as flex_int16_t,
    143 as libc::c_int as flex_int16_t,
    143 as libc::c_int as flex_int16_t,
    143 as libc::c_int as flex_int16_t,
    143 as libc::c_int as flex_int16_t,
    143 as libc::c_int as flex_int16_t,
    144 as libc::c_int as flex_int16_t,
    144 as libc::c_int as flex_int16_t,
    144 as libc::c_int as flex_int16_t,
    144 as libc::c_int as flex_int16_t,
    144 as libc::c_int as flex_int16_t,
    144 as libc::c_int as flex_int16_t,
    148 as libc::c_int as flex_int16_t,
    137 as libc::c_int as flex_int16_t,
    148 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    161 as libc::c_int as flex_int16_t,
    161 as libc::c_int as flex_int16_t,
    161 as libc::c_int as flex_int16_t,
    161 as libc::c_int as flex_int16_t,
    161 as libc::c_int as flex_int16_t,
    161 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    171 as libc::c_int as flex_int16_t,
    171 as libc::c_int as flex_int16_t,
    171 as libc::c_int as flex_int16_t,
    171 as libc::c_int as flex_int16_t,
    171 as libc::c_int as flex_int16_t,
    171 as libc::c_int as flex_int16_t,
    192 as libc::c_int as flex_int16_t,
    192 as libc::c_int as flex_int16_t,
    192 as libc::c_int as flex_int16_t,
    192 as libc::c_int as flex_int16_t,
    192 as libc::c_int as flex_int16_t,
    192 as libc::c_int as flex_int16_t,
    198 as libc::c_int as flex_int16_t,
    198 as libc::c_int as flex_int16_t,
    198 as libc::c_int as flex_int16_t,
    198 as libc::c_int as flex_int16_t,
    198 as libc::c_int as flex_int16_t,
    198 as libc::c_int as flex_int16_t,
    199 as libc::c_int as flex_int16_t,
    199 as libc::c_int as flex_int16_t,
    199 as libc::c_int as flex_int16_t,
    199 as libc::c_int as flex_int16_t,
    199 as libc::c_int as flex_int16_t,
    199 as libc::c_int as flex_int16_t,
    204 as libc::c_int as flex_int16_t,
    204 as libc::c_int as flex_int16_t,
    204 as libc::c_int as flex_int16_t,
    204 as libc::c_int as flex_int16_t,
    204 as libc::c_int as flex_int16_t,
    204 as libc::c_int as flex_int16_t,
    208 as libc::c_int as flex_int16_t,
    208 as libc::c_int as flex_int16_t,
    208 as libc::c_int as flex_int16_t,
    208 as libc::c_int as flex_int16_t,
    208 as libc::c_int as flex_int16_t,
    208 as libc::c_int as flex_int16_t,
    215 as libc::c_int as flex_int16_t,
    215 as libc::c_int as flex_int16_t,
    215 as libc::c_int as flex_int16_t,
    215 as libc::c_int as flex_int16_t,
    215 as libc::c_int as flex_int16_t,
    215 as libc::c_int as flex_int16_t,
    216 as libc::c_int as flex_int16_t,
    216 as libc::c_int as flex_int16_t,
    216 as libc::c_int as flex_int16_t,
    216 as libc::c_int as flex_int16_t,
    216 as libc::c_int as flex_int16_t,
    216 as libc::c_int as flex_int16_t,
    217 as libc::c_int as flex_int16_t,
    217 as libc::c_int as flex_int16_t,
    217 as libc::c_int as flex_int16_t,
    217 as libc::c_int as flex_int16_t,
    217 as libc::c_int as flex_int16_t,
    217 as libc::c_int as flex_int16_t,
    218 as libc::c_int as flex_int16_t,
    218 as libc::c_int as flex_int16_t,
    218 as libc::c_int as flex_int16_t,
    218 as libc::c_int as flex_int16_t,
    218 as libc::c_int as flex_int16_t,
    218 as libc::c_int as flex_int16_t,
    219 as libc::c_int as flex_int16_t,
    219 as libc::c_int as flex_int16_t,
    219 as libc::c_int as flex_int16_t,
    219 as libc::c_int as flex_int16_t,
    219 as libc::c_int as flex_int16_t,
    219 as libc::c_int as flex_int16_t,
    233 as libc::c_int as flex_int16_t,
    233 as libc::c_int as flex_int16_t,
    233 as libc::c_int as flex_int16_t,
    233 as libc::c_int as flex_int16_t,
    233 as libc::c_int as flex_int16_t,
    233 as libc::c_int as flex_int16_t,
    237 as libc::c_int as flex_int16_t,
    237 as libc::c_int as flex_int16_t,
    237 as libc::c_int as flex_int16_t,
    237 as libc::c_int as flex_int16_t,
    237 as libc::c_int as flex_int16_t,
    237 as libc::c_int as flex_int16_t,
    260 as libc::c_int as flex_int16_t,
    260 as libc::c_int as flex_int16_t,
    260 as libc::c_int as flex_int16_t,
    260 as libc::c_int as flex_int16_t,
    260 as libc::c_int as flex_int16_t,
    260 as libc::c_int as flex_int16_t,
    266 as libc::c_int as flex_int16_t,
    266 as libc::c_int as flex_int16_t,
    266 as libc::c_int as flex_int16_t,
    266 as libc::c_int as flex_int16_t,
    266 as libc::c_int as flex_int16_t,
    266 as libc::c_int as flex_int16_t,
    267 as libc::c_int as flex_int16_t,
    267 as libc::c_int as flex_int16_t,
    267 as libc::c_int as flex_int16_t,
    267 as libc::c_int as flex_int16_t,
    267 as libc::c_int as flex_int16_t,
    267 as libc::c_int as flex_int16_t,
    272 as libc::c_int as flex_int16_t,
    272 as libc::c_int as flex_int16_t,
    272 as libc::c_int as flex_int16_t,
    272 as libc::c_int as flex_int16_t,
    272 as libc::c_int as flex_int16_t,
    272 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    131 as libc::c_int as flex_int16_t,
    128 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    126 as libc::c_int as flex_int16_t,
    125 as libc::c_int as flex_int16_t,
    124 as libc::c_int as flex_int16_t,
    123 as libc::c_int as flex_int16_t,
    122 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    48 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    3 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
];
static mut yy_chk: [flex_int16_t; 1010] = [
    0 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    1 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    8 as libc::c_int as flex_int16_t,
    13 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    30 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    274 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    13 as libc::c_int as flex_int16_t,
    10 as libc::c_int as flex_int16_t,
    10 as libc::c_int as flex_int16_t,
    10 as libc::c_int as flex_int16_t,
    30 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    10 as libc::c_int as flex_int16_t,
    272 as libc::c_int as flex_int16_t,
    11 as libc::c_int as flex_int16_t,
    11 as libc::c_int as flex_int16_t,
    11 as libc::c_int as flex_int16_t,
    267 as libc::c_int as flex_int16_t,
    8 as libc::c_int as flex_int16_t,
    11 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    11 as libc::c_int as flex_int16_t,
    266 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    49 as libc::c_int as flex_int16_t,
    12 as libc::c_int as flex_int16_t,
    12 as libc::c_int as flex_int16_t,
    12 as libc::c_int as flex_int16_t,
    97 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    12 as libc::c_int as flex_int16_t,
    14 as libc::c_int as flex_int16_t,
    14 as libc::c_int as flex_int16_t,
    14 as libc::c_int as flex_int16_t,
    76 as libc::c_int as flex_int16_t,
    76 as libc::c_int as flex_int16_t,
    14 as libc::c_int as flex_int16_t,
    15 as libc::c_int as flex_int16_t,
    15 as libc::c_int as flex_int16_t,
    15 as libc::c_int as flex_int16_t,
    5 as libc::c_int as flex_int16_t,
    265 as libc::c_int as flex_int16_t,
    15 as libc::c_int as flex_int16_t,
    16 as libc::c_int as flex_int16_t,
    16 as libc::c_int as flex_int16_t,
    16 as libc::c_int as flex_int16_t,
    6 as libc::c_int as flex_int16_t,
    264 as libc::c_int as flex_int16_t,
    16 as libc::c_int as flex_int16_t,
    17 as libc::c_int as flex_int16_t,
    17 as libc::c_int as flex_int16_t,
    17 as libc::c_int as flex_int16_t,
    147 as libc::c_int as flex_int16_t,
    147 as libc::c_int as flex_int16_t,
    17 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    263 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    18 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    16 as libc::c_int as flex_int16_t,
    20 as libc::c_int as flex_int16_t,
    35 as libc::c_int as flex_int16_t,
    20 as libc::c_int as flex_int16_t,
    20 as libc::c_int as flex_int16_t,
    20 as libc::c_int as flex_int16_t,
    22 as libc::c_int as flex_int16_t,
    22 as libc::c_int as flex_int16_t,
    22 as libc::c_int as flex_int16_t,
    35 as libc::c_int as flex_int16_t,
    35 as libc::c_int as flex_int16_t,
    22 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    262 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    22 as libc::c_int as flex_int16_t,
    260 as libc::c_int as flex_int16_t,
    259 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    24 as libc::c_int as flex_int16_t,
    24 as libc::c_int as flex_int16_t,
    24 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    22 as libc::c_int as flex_int16_t,
    24 as libc::c_int as flex_int16_t,
    19 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    23 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    28 as libc::c_int as flex_int16_t,
    29 as libc::c_int as flex_int16_t,
    258 as libc::c_int as flex_int16_t,
    28 as libc::c_int as flex_int16_t,
    251 as libc::c_int as flex_int16_t,
    248 as libc::c_int as flex_int16_t,
    24 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    28 as libc::c_int as flex_int16_t,
    29 as libc::c_int as flex_int16_t,
    29 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    26 as libc::c_int as flex_int16_t,
    61 as libc::c_int as flex_int16_t,
    74 as libc::c_int as flex_int16_t,
    74 as libc::c_int as flex_int16_t,
    74 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    27 as libc::c_int as flex_int16_t,
    31 as libc::c_int as flex_int16_t,
    61 as libc::c_int as flex_int16_t,
    32 as libc::c_int as flex_int16_t,
    34 as libc::c_int as flex_int16_t,
    31 as libc::c_int as flex_int16_t,
    32 as libc::c_int as flex_int16_t,
    34 as libc::c_int as flex_int16_t,
    105 as libc::c_int as flex_int16_t,
    31 as libc::c_int as flex_int16_t,
    31 as libc::c_int as flex_int16_t,
    32 as libc::c_int as flex_int16_t,
    34 as libc::c_int as flex_int16_t,
    146 as libc::c_int as flex_int16_t,
    146 as libc::c_int as flex_int16_t,
    146 as libc::c_int as flex_int16_t,
    105 as libc::c_int as flex_int16_t,
    36 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    21 as libc::c_int as flex_int16_t,
    33 as libc::c_int as flex_int16_t,
    246 as libc::c_int as flex_int16_t,
    36 as libc::c_int as flex_int16_t,
    33 as libc::c_int as flex_int16_t,
    104 as libc::c_int as flex_int16_t,
    107 as libc::c_int as flex_int16_t,
    33 as libc::c_int as flex_int16_t,
    36 as libc::c_int as flex_int16_t,
    33 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    104 as libc::c_int as flex_int16_t,
    107 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    104 as libc::c_int as flex_int16_t,
    107 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    109 as libc::c_int as flex_int16_t,
    245 as libc::c_int as flex_int16_t,
    45 as libc::c_int as flex_int16_t,
    244 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    109 as libc::c_int as flex_int16_t,
    108 as libc::c_int as flex_int16_t,
    47 as libc::c_int as flex_int16_t,
    48 as libc::c_int as flex_int16_t,
    48 as libc::c_int as flex_int16_t,
    48 as libc::c_int as flex_int16_t,
    243 as libc::c_int as flex_int16_t,
    108 as libc::c_int as flex_int16_t,
    48 as libc::c_int as flex_int16_t,
    108 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    242 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    241 as libc::c_int as flex_int16_t,
    239 as libc::c_int as flex_int16_t,
    54 as libc::c_int as flex_int16_t,
    106 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    237 as libc::c_int as flex_int16_t,
    37 as libc::c_int as flex_int16_t,
    106 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    106 as libc::c_int as flex_int16_t,
    43 as libc::c_int as flex_int16_t,
    56 as libc::c_int as flex_int16_t,
    58 as libc::c_int as flex_int16_t,
    58 as libc::c_int as flex_int16_t,
    58 as libc::c_int as flex_int16_t,
    235 as libc::c_int as flex_int16_t,
    110 as libc::c_int as flex_int16_t,
    58 as libc::c_int as flex_int16_t,
    234 as libc::c_int as flex_int16_t,
    233 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    110 as libc::c_int as flex_int16_t,
    221 as libc::c_int as flex_int16_t,
    59 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    220 as libc::c_int as flex_int16_t,
    219 as libc::c_int as flex_int16_t,
    63 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    218 as libc::c_int as flex_int16_t,
    53 as libc::c_int as flex_int16_t,
    65 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    217 as libc::c_int as flex_int16_t,
    216 as libc::c_int as flex_int16_t,
    67 as libc::c_int as flex_int16_t,
    69 as libc::c_int as flex_int16_t,
    69 as libc::c_int as flex_int16_t,
    69 as libc::c_int as flex_int16_t,
    215 as libc::c_int as flex_int16_t,
    214 as libc::c_int as flex_int16_t,
    69 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    213 as libc::c_int as flex_int16_t,
    212 as libc::c_int as flex_int16_t,
    70 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    211 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    72 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    75 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    115 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    78 as libc::c_int as flex_int16_t,
    79 as libc::c_int as flex_int16_t,
    79 as libc::c_int as flex_int16_t,
    79 as libc::c_int as flex_int16_t,
    210 as libc::c_int as flex_int16_t,
    115 as libc::c_int as flex_int16_t,
    79 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    80 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    209 as libc::c_int as flex_int16_t,
    208 as libc::c_int as flex_int16_t,
    86 as libc::c_int as flex_int16_t,
    88 as libc::c_int as flex_int16_t,
    88 as libc::c_int as flex_int16_t,
    88 as libc::c_int as flex_int16_t,
    204 as libc::c_int as flex_int16_t,
    202 as libc::c_int as flex_int16_t,
    88 as libc::c_int as flex_int16_t,
    89 as libc::c_int as flex_int16_t,
    89 as libc::c_int as flex_int16_t,
    89 as libc::c_int as flex_int16_t,
    199 as libc::c_int as flex_int16_t,
    198 as libc::c_int as flex_int16_t,
    89 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    197 as libc::c_int as flex_int16_t,
    196 as libc::c_int as flex_int16_t,
    90 as libc::c_int as flex_int16_t,
    92 as libc::c_int as flex_int16_t,
    92 as libc::c_int as flex_int16_t,
    92 as libc::c_int as flex_int16_t,
    195 as libc::c_int as flex_int16_t,
    194 as libc::c_int as flex_int16_t,
    92 as libc::c_int as flex_int16_t,
    93 as libc::c_int as flex_int16_t,
    93 as libc::c_int as flex_int16_t,
    93 as libc::c_int as flex_int16_t,
    192 as libc::c_int as flex_int16_t,
    177 as libc::c_int as flex_int16_t,
    93 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    176 as libc::c_int as flex_int16_t,
    111 as libc::c_int as flex_int16_t,
    94 as libc::c_int as flex_int16_t,
    96 as libc::c_int as flex_int16_t,
    96 as libc::c_int as flex_int16_t,
    96 as libc::c_int as flex_int16_t,
    112 as libc::c_int as flex_int16_t,
    113 as libc::c_int as flex_int16_t,
    96 as libc::c_int as flex_int16_t,
    111 as libc::c_int as flex_int16_t,
    114 as libc::c_int as flex_int16_t,
    116 as libc::c_int as flex_int16_t,
    118 as libc::c_int as flex_int16_t,
    111 as libc::c_int as flex_int16_t,
    112 as libc::c_int as flex_int16_t,
    113 as libc::c_int as flex_int16_t,
    113 as libc::c_int as flex_int16_t,
    117 as libc::c_int as flex_int16_t,
    114 as libc::c_int as flex_int16_t,
    116 as libc::c_int as flex_int16_t,
    118 as libc::c_int as flex_int16_t,
    112 as libc::c_int as flex_int16_t,
    175 as libc::c_int as flex_int16_t,
    117 as libc::c_int as flex_int16_t,
    122 as libc::c_int as flex_int16_t,
    117 as libc::c_int as flex_int16_t,
    116 as libc::c_int as flex_int16_t,
    114 as libc::c_int as flex_int16_t,
    118 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    122 as libc::c_int as flex_int16_t,
    174 as libc::c_int as flex_int16_t,
    119 as libc::c_int as flex_int16_t,
    121 as libc::c_int as flex_int16_t,
    121 as libc::c_int as flex_int16_t,
    121 as libc::c_int as flex_int16_t,
    173 as libc::c_int as flex_int16_t,
    171 as libc::c_int as flex_int16_t,
    121 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    170 as libc::c_int as flex_int16_t,
    168 as libc::c_int as flex_int16_t,
    129 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    166 as libc::c_int as flex_int16_t,
    165 as libc::c_int as flex_int16_t,
    134 as libc::c_int as flex_int16_t,
    137 as libc::c_int as flex_int16_t,
    137 as libc::c_int as flex_int16_t,
    137 as libc::c_int as flex_int16_t,
    163 as libc::c_int as flex_int16_t,
    161 as libc::c_int as flex_int16_t,
    137 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    160 as libc::c_int as flex_int16_t,
    145 as libc::c_int as flex_int16_t,
    141 as libc::c_int as flex_int16_t,
    145 as libc::c_int as flex_int16_t,
    145 as libc::c_int as flex_int16_t,
    145 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    159 as libc::c_int as flex_int16_t,
    158 as libc::c_int as flex_int16_t,
    149 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    151 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    157 as libc::c_int as flex_int16_t,
    156 as libc::c_int as flex_int16_t,
    162 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    155 as libc::c_int as flex_int16_t,
    154 as libc::c_int as flex_int16_t,
    164 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    153 as libc::c_int as flex_int16_t,
    152 as libc::c_int as flex_int16_t,
    167 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    137 as libc::c_int as flex_int16_t,
    150 as libc::c_int as flex_int16_t,
    169 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    178 as libc::c_int as flex_int16_t,
    179 as libc::c_int as flex_int16_t,
    172 as libc::c_int as flex_int16_t,
    178 as libc::c_int as flex_int16_t,
    180 as libc::c_int as flex_int16_t,
    144 as libc::c_int as flex_int16_t,
    182 as libc::c_int as flex_int16_t,
    143 as libc::c_int as flex_int16_t,
    178 as libc::c_int as flex_int16_t,
    179 as libc::c_int as flex_int16_t,
    181 as libc::c_int as flex_int16_t,
    183 as libc::c_int as flex_int16_t,
    180 as libc::c_int as flex_int16_t,
    181 as libc::c_int as flex_int16_t,
    182 as libc::c_int as flex_int16_t,
    179 as libc::c_int as flex_int16_t,
    184 as libc::c_int as flex_int16_t,
    142 as libc::c_int as flex_int16_t,
    181 as libc::c_int as flex_int16_t,
    183 as libc::c_int as flex_int16_t,
    140 as libc::c_int as flex_int16_t,
    182 as libc::c_int as flex_int16_t,
    187 as libc::c_int as flex_int16_t,
    185 as libc::c_int as flex_int16_t,
    184 as libc::c_int as flex_int16_t,
    183 as libc::c_int as flex_int16_t,
    186 as libc::c_int as flex_int16_t,
    184 as libc::c_int as flex_int16_t,
    185 as libc::c_int as flex_int16_t,
    186 as libc::c_int as flex_int16_t,
    187 as libc::c_int as flex_int16_t,
    185 as libc::c_int as flex_int16_t,
    188 as libc::c_int as flex_int16_t,
    189 as libc::c_int as flex_int16_t,
    186 as libc::c_int as flex_int16_t,
    190 as libc::c_int as flex_int16_t,
    191 as libc::c_int as flex_int16_t,
    139 as libc::c_int as flex_int16_t,
    225 as libc::c_int as flex_int16_t,
    191 as libc::c_int as flex_int16_t,
    188 as libc::c_int as flex_int16_t,
    189 as libc::c_int as flex_int16_t,
    138 as libc::c_int as flex_int16_t,
    190 as libc::c_int as flex_int16_t,
    191 as libc::c_int as flex_int16_t,
    223 as libc::c_int as flex_int16_t,
    225 as libc::c_int as flex_int16_t,
    190 as libc::c_int as flex_int16_t,
    136 as libc::c_int as flex_int16_t,
    189 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    223 as libc::c_int as flex_int16_t,
    135 as libc::c_int as flex_int16_t,
    193 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    223 as libc::c_int as flex_int16_t,
    133 as libc::c_int as flex_int16_t,
    200 as libc::c_int as flex_int16_t,
    201 as libc::c_int as flex_int16_t,
    201 as libc::c_int as flex_int16_t,
    201 as libc::c_int as flex_int16_t,
    132 as libc::c_int as flex_int16_t,
    130 as libc::c_int as flex_int16_t,
    201 as libc::c_int as flex_int16_t,
    203 as libc::c_int as flex_int16_t,
    203 as libc::c_int as flex_int16_t,
    203 as libc::c_int as flex_int16_t,
    128 as libc::c_int as flex_int16_t,
    127 as libc::c_int as flex_int16_t,
    203 as libc::c_int as flex_int16_t,
    205 as libc::c_int as flex_int16_t,
    205 as libc::c_int as flex_int16_t,
    205 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    126 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    206 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    232 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    207 as libc::c_int as flex_int16_t,
    222 as libc::c_int as flex_int16_t,
    222 as libc::c_int as flex_int16_t,
    222 as libc::c_int as flex_int16_t,
    125 as libc::c_int as flex_int16_t,
    232 as libc::c_int as flex_int16_t,
    222 as libc::c_int as flex_int16_t,
    224 as libc::c_int as flex_int16_t,
    224 as libc::c_int as flex_int16_t,
    224 as libc::c_int as flex_int16_t,
    226 as libc::c_int as flex_int16_t,
    227 as libc::c_int as flex_int16_t,
    224 as libc::c_int as flex_int16_t,
    226 as libc::c_int as flex_int16_t,
    228 as libc::c_int as flex_int16_t,
    261 as libc::c_int as flex_int16_t,
    261 as libc::c_int as flex_int16_t,
    261 as libc::c_int as flex_int16_t,
    226 as libc::c_int as flex_int16_t,
    227 as libc::c_int as flex_int16_t,
    229 as libc::c_int as flex_int16_t,
    124 as libc::c_int as flex_int16_t,
    228 as libc::c_int as flex_int16_t,
    201 as libc::c_int as flex_int16_t,
    227 as libc::c_int as flex_int16_t,
    228 as libc::c_int as flex_int16_t,
    123 as libc::c_int as flex_int16_t,
    120 as libc::c_int as flex_int16_t,
    229 as libc::c_int as flex_int16_t,
    222 as libc::c_int as flex_int16_t,
    249 as libc::c_int as flex_int16_t,
    230 as libc::c_int as flex_int16_t,
    103 as libc::c_int as flex_int16_t,
    102 as libc::c_int as flex_int16_t,
    229 as libc::c_int as flex_int16_t,
    224 as libc::c_int as flex_int16_t,
    101 as libc::c_int as flex_int16_t,
    222 as libc::c_int as flex_int16_t,
    249 as libc::c_int as flex_int16_t,
    230 as libc::c_int as flex_int16_t,
    231 as libc::c_int as flex_int16_t,
    231 as libc::c_int as flex_int16_t,
    231 as libc::c_int as flex_int16_t,
    224 as libc::c_int as flex_int16_t,
    230 as libc::c_int as flex_int16_t,
    231 as libc::c_int as flex_int16_t,
    236 as libc::c_int as flex_int16_t,
    236 as libc::c_int as flex_int16_t,
    236 as libc::c_int as flex_int16_t,
    100 as libc::c_int as flex_int16_t,
    252 as libc::c_int as flex_int16_t,
    236 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    99 as libc::c_int as flex_int16_t,
    95 as libc::c_int as flex_int16_t,
    238 as libc::c_int as flex_int16_t,
    252 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    253 as libc::c_int as flex_int16_t,
    255 as libc::c_int as flex_int16_t,
    247 as libc::c_int as flex_int16_t,
    231 as libc::c_int as flex_int16_t,
    240 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    253 as libc::c_int as flex_int16_t,
    255 as libc::c_int as flex_int16_t,
    250 as libc::c_int as flex_int16_t,
    231 as libc::c_int as flex_int16_t,
    254 as libc::c_int as flex_int16_t,
    255 as libc::c_int as flex_int16_t,
    254 as libc::c_int as flex_int16_t,
    253 as libc::c_int as flex_int16_t,
    256 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    254 as libc::c_int as flex_int16_t,
    268 as libc::c_int as flex_int16_t,
    257 as libc::c_int as flex_int16_t,
    269 as libc::c_int as flex_int16_t,
    256 as libc::c_int as flex_int16_t,
    270 as libc::c_int as flex_int16_t,
    256 as libc::c_int as flex_int16_t,
    271 as libc::c_int as flex_int16_t,
    91 as libc::c_int as flex_int16_t,
    268 as libc::c_int as flex_int16_t,
    87 as libc::c_int as flex_int16_t,
    269 as libc::c_int as flex_int16_t,
    85 as libc::c_int as flex_int16_t,
    270 as libc::c_int as flex_int16_t,
    84 as libc::c_int as flex_int16_t,
    271 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    273 as libc::c_int as flex_int16_t,
    275 as libc::c_int as flex_int16_t,
    275 as libc::c_int as flex_int16_t,
    276 as libc::c_int as flex_int16_t,
    276 as libc::c_int as flex_int16_t,
    276 as libc::c_int as flex_int16_t,
    83 as libc::c_int as flex_int16_t,
    277 as libc::c_int as flex_int16_t,
    82 as libc::c_int as flex_int16_t,
    275 as libc::c_int as flex_int16_t,
    277 as libc::c_int as flex_int16_t,
    81 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    277 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    279 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    280 as libc::c_int as flex_int16_t,
    281 as libc::c_int as flex_int16_t,
    281 as libc::c_int as flex_int16_t,
    281 as libc::c_int as flex_int16_t,
    278 as libc::c_int as flex_int16_t,
    279 as libc::c_int as flex_int16_t,
    282 as libc::c_int as flex_int16_t,
    282 as libc::c_int as flex_int16_t,
    282 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    284 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    73 as libc::c_int as flex_int16_t,
    71 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    68 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    66 as libc::c_int as flex_int16_t,
    285 as libc::c_int as flex_int16_t,
    287 as libc::c_int as flex_int16_t,
    287 as libc::c_int as flex_int16_t,
    287 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    288 as libc::c_int as flex_int16_t,
    286 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    290 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    291 as libc::c_int as flex_int16_t,
    292 as libc::c_int as flex_int16_t,
    64 as libc::c_int as flex_int16_t,
    292 as libc::c_int as flex_int16_t,
    292 as libc::c_int as flex_int16_t,
    292 as libc::c_int as flex_int16_t,
    293 as libc::c_int as flex_int16_t,
    293 as libc::c_int as flex_int16_t,
    293 as libc::c_int as flex_int16_t,
    293 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    294 as libc::c_int as flex_int16_t,
    295 as libc::c_int as flex_int16_t,
    295 as libc::c_int as flex_int16_t,
    295 as libc::c_int as flex_int16_t,
    295 as libc::c_int as flex_int16_t,
    295 as libc::c_int as flex_int16_t,
    295 as libc::c_int as flex_int16_t,
    296 as libc::c_int as flex_int16_t,
    296 as libc::c_int as flex_int16_t,
    296 as libc::c_int as flex_int16_t,
    296 as libc::c_int as flex_int16_t,
    296 as libc::c_int as flex_int16_t,
    296 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    297 as libc::c_int as flex_int16_t,
    298 as libc::c_int as flex_int16_t,
    298 as libc::c_int as flex_int16_t,
    298 as libc::c_int as flex_int16_t,
    298 as libc::c_int as flex_int16_t,
    298 as libc::c_int as flex_int16_t,
    298 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    299 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    300 as libc::c_int as flex_int16_t,
    301 as libc::c_int as flex_int16_t,
    301 as libc::c_int as flex_int16_t,
    301 as libc::c_int as flex_int16_t,
    301 as libc::c_int as flex_int16_t,
    301 as libc::c_int as flex_int16_t,
    301 as libc::c_int as flex_int16_t,
    302 as libc::c_int as flex_int16_t,
    302 as libc::c_int as flex_int16_t,
    302 as libc::c_int as flex_int16_t,
    302 as libc::c_int as flex_int16_t,
    302 as libc::c_int as flex_int16_t,
    302 as libc::c_int as flex_int16_t,
    303 as libc::c_int as flex_int16_t,
    62 as libc::c_int as flex_int16_t,
    303 as libc::c_int as flex_int16_t,
    304 as libc::c_int as flex_int16_t,
    60 as libc::c_int as flex_int16_t,
    304 as libc::c_int as flex_int16_t,
    304 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    305 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    306 as libc::c_int as flex_int16_t,
    307 as libc::c_int as flex_int16_t,
    307 as libc::c_int as flex_int16_t,
    307 as libc::c_int as flex_int16_t,
    307 as libc::c_int as flex_int16_t,
    307 as libc::c_int as flex_int16_t,
    307 as libc::c_int as flex_int16_t,
    308 as libc::c_int as flex_int16_t,
    308 as libc::c_int as flex_int16_t,
    308 as libc::c_int as flex_int16_t,
    308 as libc::c_int as flex_int16_t,
    308 as libc::c_int as flex_int16_t,
    308 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    309 as libc::c_int as flex_int16_t,
    310 as libc::c_int as flex_int16_t,
    310 as libc::c_int as flex_int16_t,
    310 as libc::c_int as flex_int16_t,
    310 as libc::c_int as flex_int16_t,
    310 as libc::c_int as flex_int16_t,
    310 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    311 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    312 as libc::c_int as flex_int16_t,
    313 as libc::c_int as flex_int16_t,
    313 as libc::c_int as flex_int16_t,
    313 as libc::c_int as flex_int16_t,
    313 as libc::c_int as flex_int16_t,
    313 as libc::c_int as flex_int16_t,
    313 as libc::c_int as flex_int16_t,
    314 as libc::c_int as flex_int16_t,
    314 as libc::c_int as flex_int16_t,
    314 as libc::c_int as flex_int16_t,
    314 as libc::c_int as flex_int16_t,
    314 as libc::c_int as flex_int16_t,
    314 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    315 as libc::c_int as flex_int16_t,
    316 as libc::c_int as flex_int16_t,
    316 as libc::c_int as flex_int16_t,
    316 as libc::c_int as flex_int16_t,
    316 as libc::c_int as flex_int16_t,
    316 as libc::c_int as flex_int16_t,
    316 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    317 as libc::c_int as flex_int16_t,
    318 as libc::c_int as flex_int16_t,
    318 as libc::c_int as flex_int16_t,
    318 as libc::c_int as flex_int16_t,
    318 as libc::c_int as flex_int16_t,
    318 as libc::c_int as flex_int16_t,
    318 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    319 as libc::c_int as flex_int16_t,
    320 as libc::c_int as flex_int16_t,
    320 as libc::c_int as flex_int16_t,
    320 as libc::c_int as flex_int16_t,
    320 as libc::c_int as flex_int16_t,
    320 as libc::c_int as flex_int16_t,
    320 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    321 as libc::c_int as flex_int16_t,
    322 as libc::c_int as flex_int16_t,
    322 as libc::c_int as flex_int16_t,
    322 as libc::c_int as flex_int16_t,
    322 as libc::c_int as flex_int16_t,
    322 as libc::c_int as flex_int16_t,
    322 as libc::c_int as flex_int16_t,
    323 as libc::c_int as flex_int16_t,
    323 as libc::c_int as flex_int16_t,
    323 as libc::c_int as flex_int16_t,
    323 as libc::c_int as flex_int16_t,
    323 as libc::c_int as flex_int16_t,
    323 as libc::c_int as flex_int16_t,
    57 as libc::c_int as flex_int16_t,
    55 as libc::c_int as flex_int16_t,
    52 as libc::c_int as flex_int16_t,
    51 as libc::c_int as flex_int16_t,
    50 as libc::c_int as flex_int16_t,
    46 as libc::c_int as flex_int16_t,
    44 as libc::c_int as flex_int16_t,
    42 as libc::c_int as flex_int16_t,
    41 as libc::c_int as flex_int16_t,
    40 as libc::c_int as flex_int16_t,
    39 as libc::c_int as flex_int16_t,
    38 as libc::c_int as flex_int16_t,
    9 as libc::c_int as flex_int16_t,
    7 as libc::c_int as flex_int16_t,
    3 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
    289 as libc::c_int as flex_int16_t,
];
static mut yy_rule_can_match_eol: [flex_int32_t; 56] = [
    0 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    0 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    0 as libc::c_int,
    1 as libc::c_int,
    1 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    1 as libc::c_int,
    0 as libc::c_int,
    1 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
];
static mut yy_last_accepting_state: yy_state_type = 0;
static mut yy_last_accepting_cpos: *mut libc::c_char = 0 as *const libc::c_char
    as *mut libc::c_char;
pub static mut yy_flex_debug: libc::c_int = 0 as libc::c_int;
unsafe extern "C" fn lex_return(
    mut p: *mut parser_state,
    mut c: libc::c_int,
) -> libc::c_int {
    (*p).lineno = (*p).tline;
    (*p).tline = yylineno;
    return c;
}
pub unsafe extern "C" fn yylex(
    mut lval: *mut YYSTYPE,
    mut p: *mut parser_state,
) -> libc::c_int {
    let mut current_block: u64;
    let mut yy_current_state: yy_state_type = 0;
    let mut yy_cp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut yy_bp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut yy_act: libc::c_int = 0;
    let mut tmp: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut yy_c: YY_CHAR = 0;
    let mut yyl: libc::c_int = 0;
    let mut tmp___0: libc::c_int = 0;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: libc::c_int = 0;
    let mut tmp___5: libc::c_int = 0;
    let mut tmp___6: libc::c_int = 0;
    let mut tmp___7: libc::c_int = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut tmp___9: libc::c_int = 0;
    let mut tmp___10: libc::c_int = 0;
    let mut tmp___11: libc::c_int = 0;
    let mut tmp___12: libc::c_int = 0;
    let mut tmp___13: libc::c_int = 0;
    let mut tmp___14: libc::c_int = 0;
    let mut tmp___15: libc::c_int = 0;
    let mut tmp___16: libc::c_int = 0;
    let mut tmp___17: libc::c_int = 0;
    let mut tmp___18: libc::c_int = 0;
    let mut tmp___19: libc::c_int = 0;
    let mut tmp___20: libc::c_int = 0;
    let mut tmp___21: libc::c_int = 0;
    let mut tmp___22: libc::c_int = 0;
    let mut tmp___23: libc::c_int = 0;
    let mut tmp___24: libc::c_int = 0;
    let mut tmp___25: libc::c_int = 0;
    let mut tmp___26: libc::c_int = 0;
    let mut tmp___27: libc::c_int = 0;
    let mut tmp___28: libc::c_int = 0;
    let mut tmp___29: libc::c_int = 0;
    let mut tmp___30: libc::c_int = 0;
    let mut tmp___31: libc::c_int = 0;
    let mut tmp___32: libc::c_int = 0;
    let mut tmp___33: libc::c_int = 0;
    let mut tmp___34: libc::c_int = 0;
    let mut tmp___35: libc::c_int = 0;
    let mut tmp___36: libc::c_int = 0;
    let mut tmp___37: libc::c_int = 0;
    let mut tmp___38: libc::c_int = 0;
    let mut tmp___39: libc::c_int = 0;
    let mut tmp___40: libc::c_int = 0;
    let mut tmp___41: libc::c_int = 0;
    let mut tmp___42: libc::c_int = 0;
    let mut tmp___43: libc::c_int = 0;
    let mut tmp___44: libc::c_long = 0;
    let mut tmp___45: libc::c_int = 0;
    let mut temp: libc::c_double = 0.;
    let mut tmp___46: libc::c_int = 0;
    let mut temp___0: libc::c_ulong = 0;
    let mut tmp___47: libc::c_int = 0;
    let mut temp___1: libc::c_ulong = 0;
    let mut tmp___48: libc::c_int = 0;
    let mut tmp___49: libc::c_int = 0;
    let mut tmp___50: libc::c_int = 0;
    let mut tmp___51: libc::c_int = 0;
    let mut tmp___52: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    let mut tmp___53: *mut *const libc::c_ushort = 0 as *mut *const libc::c_ushort;
    let mut yy_amount_of_matched_text: libc::c_int = 0;
    let mut yy_next_state: yy_state_type = 0;
    let mut tmp___54: libc::c_int = 0;
    if yy_init == 0 {
        yy_init = 1 as libc::c_int;
        if yy_start == 0 {
            yy_start = 1 as libc::c_int;
        }
        if yyin.is_null() {
            yyin = stdin;
        }
        if yyout.is_null() {
            yyout = stdout;
        }
        if !yy_buffer_stack.is_null() {
            tmp = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
        } else {
            tmp = 0 as *mut libc::c_void as YY_BUFFER_STATE;
        }
        if tmp.is_null() {
            yyensure_buffer_stack();
            let ref mut fresh19 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
            *fresh19 = yy_create_buffer(yyin, 16384 as libc::c_int);
        }
        yy_load_buffer_state();
    }
    loop {
        yy_cp = yy_c_buf_p;
        *yy_cp = yy_hold_char;
        yy_bp = yy_cp;
        yy_current_state = yy_start;
        '_yy_match: loop {
            loop {
                yy_c = yy_ec[*yy_cp as YY_CHAR as usize];
                if yy_accept[yy_current_state as usize] != 0 {
                    yy_last_accepting_state = yy_current_state;
                    yy_last_accepting_cpos = yy_cp;
                }
                while yy_chk[(yy_base[yy_current_state as usize] as libc::c_int
                    + yy_c as libc::c_int) as usize] as libc::c_int != yy_current_state
                {
                    yy_current_state = yy_def[yy_current_state as usize] as libc::c_int;
                    if yy_current_state >= 290 as libc::c_int {
                        yy_c = yy_meta[yy_c as usize];
                    }
                }
                yy_current_state = yy_nxt[(yy_base[yy_current_state as usize]
                    as libc::c_int + yy_c as libc::c_int) as usize] as yy_state_type;
                yy_cp = yy_cp.offset(1);
                if !(yy_base[yy_current_state as usize] as libc::c_int
                    != 953 as libc::c_int)
                {
                    break;
                }
            }
            '_yy_find_action: loop {
                yy_act = yy_accept[yy_current_state as usize] as libc::c_int;
                if yy_act == 0 as libc::c_int {
                    yy_cp = yy_last_accepting_cpos;
                    yy_current_state = yy_last_accepting_state;
                    yy_act = yy_accept[yy_current_state as usize] as libc::c_int;
                }
                yytext = yy_bp;
                yyleng = yy_cp.offset_from(yy_bp) as libc::c_long as libc::c_int;
                yy_hold_char = *yy_cp;
                *yy_cp = '\u{0}' as i32 as libc::c_char;
                yy_c_buf_p = yy_cp;
                if yy_act != 56 as libc::c_int {
                    if yy_rule_can_match_eol[yy_act as usize] != 0 {
                        yyl = 0 as libc::c_int;
                        while yyl < yyleng {
                            if *yytext.offset(yyl as isize) as libc::c_int
                                == 10 as libc::c_int
                            {
                                yylineno += 1;
                            }
                            yyl += 1;
                        }
                    }
                }
                loop {
                    match yy_act {
                        0 => {
                            *yy_cp = yy_hold_char;
                            yy_cp = yy_last_accepting_cpos;
                            yy_current_state = yy_last_accepting_state;
                            continue '_yy_find_action;
                        }
                        1 => {
                            tmp___0 = lex_return(p, 278 as libc::c_int);
                            return tmp___0;
                        }
                        2 => {
                            tmp___1 = lex_return(p, 279 as libc::c_int);
                            return tmp___1;
                        }
                        3 => {
                            tmp___2 = lex_return(p, 280 as libc::c_int);
                            return tmp___2;
                        }
                        4 => {
                            tmp___3 = lex_return(p, 281 as libc::c_int);
                            return tmp___3;
                        }
                        5 => {
                            tmp___4 = lex_return(p, 282 as libc::c_int);
                            return tmp___4;
                        }
                        6 => {
                            tmp___5 = lex_return(p, 283 as libc::c_int);
                            return tmp___5;
                        }
                        7 => {
                            tmp___6 = lex_return(p, 284 as libc::c_int);
                            return tmp___6;
                        }
                        8 => {
                            tmp___7 = lex_return(p, 285 as libc::c_int);
                            return tmp___7;
                        }
                        9 => {
                            tmp___8 = lex_return(p, 286 as libc::c_int);
                            return tmp___8;
                        }
                        10 => {
                            tmp___9 = lex_return(p, 287 as libc::c_int);
                            return tmp___9;
                        }
                        11 => {
                            tmp___10 = lex_return(p, 288 as libc::c_int);
                            return tmp___10;
                        }
                        12 => {
                            tmp___11 = lex_return(p, 289 as libc::c_int);
                            return tmp___11;
                        }
                        13 => {
                            tmp___12 = lex_return(p, 290 as libc::c_int);
                            return tmp___12;
                        }
                        14 => {
                            tmp___13 = lex_return(p, 292 as libc::c_int);
                            return tmp___13;
                        }
                        15 => {
                            tmp___14 = lex_return(p, 273 as libc::c_int);
                            return tmp___14;
                        }
                        16 => {
                            tmp___15 = lex_return(p, 274 as libc::c_int);
                            return tmp___15;
                        }
                        17 => {
                            tmp___16 = lex_return(p, 275 as libc::c_int);
                            return tmp___16;
                        }
                        18 => {
                            tmp___17 = lex_return(p, 276 as libc::c_int);
                            return tmp___17;
                        }
                        19 => {
                            tmp___18 = lex_return(p, 277 as libc::c_int);
                            return tmp___18;
                        }
                        20 => {
                            tmp___19 = lex_return(p, '=' as i32);
                            return tmp___19;
                        }
                        21 => {
                            tmp___20 = lex_return(p, 293 as libc::c_int);
                            return tmp___20;
                        }
                        22 => {
                            tmp___21 = lex_return(p, 258 as libc::c_int);
                            return tmp___21;
                        }
                        23 => {
                            tmp___22 = lex_return(p, 259 as libc::c_int);
                            return tmp___22;
                        }
                        24 => {
                            tmp___23 = lex_return(p, 262 as libc::c_int);
                            return tmp___23;
                        }
                        25 => {
                            tmp___24 = lex_return(p, 260 as libc::c_int);
                            return tmp___24;
                        }
                        26 => {
                            tmp___25 = lex_return(p, 261 as libc::c_int);
                            return tmp___25;
                        }
                        27 => {
                            tmp___26 = lex_return(p, 263 as libc::c_int);
                            return tmp___26;
                        }
                        28 => {
                            tmp___27 = lex_return(p, 264 as libc::c_int);
                            return tmp___27;
                        }
                        29 => {
                            tmp___28 = lex_return(p, 265 as libc::c_int);
                            return tmp___28;
                        }
                        30 => {
                            tmp___29 = lex_return(p, 266 as libc::c_int);
                            return tmp___29;
                        }
                        31 => {
                            tmp___30 = lex_return(p, 267 as libc::c_int);
                            return tmp___30;
                        }
                        32 => {
                            tmp___31 = lex_return(p, 268 as libc::c_int);
                            return tmp___31;
                        }
                        33 => {
                            tmp___32 = lex_return(p, 269 as libc::c_int);
                            return tmp___32;
                        }
                        34 => {
                            tmp___33 = lex_return(p, 270 as libc::c_int);
                            return tmp___33;
                        }
                        35 => {
                            tmp___34 = lex_return(p, 271 as libc::c_int);
                            return tmp___34;
                        }
                        36 => {
                            tmp___35 = lex_return(p, 272 as libc::c_int);
                            return tmp___35;
                        }
                        37 => {
                            (*lval)
                                .id = node_str_new(yytext as *const libc::c_char, yyleng);
                            tmp___36 = lex_return(p, 298 as libc::c_int);
                            return tmp___36;
                        }
                        38 => {
                            *yytext
                                .offset(
                                    (yyleng - 1 as libc::c_int) as isize,
                                ) = '\u{0}' as i32 as libc::c_char;
                            (*lval)
                                .id = node_str_new(
                                yytext as *const libc::c_char,
                                yyleng - 1 as libc::c_int,
                            );
                            tmp___37 = lex_return(p, 299 as libc::c_int);
                            return tmp___37;
                        }
                        39 => {
                            tmp___38 = lex_return(p, 291 as libc::c_int);
                            return tmp___38;
                        }
                        40 => {
                            tmp___39 = lex_return(p, '.' as i32);
                            return tmp___39;
                        }
                        41 => {
                            tmp___40 = lex_return(
                                p,
                                *yytext.offset(0 as libc::c_int as isize) as libc::c_int,
                            );
                            return tmp___40;
                        }
                        42 => {
                            tmp___41 = lex_return(
                                p,
                                *yytext.offset(0 as libc::c_int as isize) as libc::c_int,
                            );
                            return tmp___41;
                        }
                        43 => {
                            tmp___42 = lex_return(p, '\n' as i32);
                            return tmp___42;
                        }
                        44 => {
                            tmp___43 = lex_return(p, '\n' as i32);
                            return tmp___43;
                        }
                        45 => {
                            tmp___44 = atol(yytext as *const libc::c_char);
                            (*lval).nd = node_int_new(tmp___44);
                            tmp___45 = lex_return(p, 295 as libc::c_int);
                            return tmp___45;
                        }
                        46 => {
                            sscanf(
                                yytext as *const libc::c_char,
                                b"%lf\0" as *const u8 as *const libc::c_char,
                                &mut temp as *mut libc::c_double,
                            );
                            (*lval).nd = node_float_new(temp);
                            tmp___46 = lex_return(p, 295 as libc::c_int);
                            return tmp___46;
                        }
                        47 => {
                            sscanf(
                                yytext.offset(2 as libc::c_int as isize)
                                    as *const libc::c_char,
                                b"%lx\0" as *const u8 as *const libc::c_char,
                                &mut temp___0 as *mut libc::c_ulong,
                            );
                            (*lval).nd = node_int_new(temp___0 as libc::c_long);
                            tmp___47 = lex_return(p, 295 as libc::c_int);
                            return tmp___47;
                        }
                        48 => {
                            sscanf(
                                yytext.offset(2 as libc::c_int as isize)
                                    as *const libc::c_char,
                                b"%lo\0" as *const u8 as *const libc::c_char,
                                &mut temp___1 as *mut libc::c_ulong,
                            );
                            (*lval).nd = node_int_new(temp___1 as libc::c_long);
                            tmp___48 = lex_return(p, 295 as libc::c_int);
                            return tmp___48;
                        }
                        49 => {
                            (*lval)
                                .nd = node_time_new(yytext as *const libc::c_char, yyleng);
                            if (*lval).nd as libc::c_ulong
                                == 0 as *mut libc::c_void as libc::c_ulong
                            {
                                yyerror(
                                    p,
                                    b"bad time format\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            tmp___49 = lex_return(p, 294 as libc::c_int);
                            return tmp___49;
                        }
                        50 => {
                            (*lval)
                                .nd = node_string_new(
                                yytext.offset(1 as libc::c_int as isize)
                                    as *const libc::c_char,
                                yyleng - 2 as libc::c_int,
                            );
                            tmp___50 = lex_return(p, 297 as libc::c_int);
                            return tmp___50;
                        }
                        51 => {
                            (*lval)
                                .nd = node_string_new(
                                yytext.offset(1 as libc::c_int as isize)
                                    as *const libc::c_char,
                                yyleng - 1 as libc::c_int,
                            );
                            tmp___51 = lex_return(p, 296 as libc::c_int);
                            return tmp___51;
                        }
                        52 => {
                            (*lval)
                                .id = node_str_escaped(
                                yytext.offset(1 as libc::c_int as isize)
                                    as *const libc::c_char,
                                yyleng - 3 as libc::c_int,
                            );
                            tmp___52 = lex_return(p, 299 as libc::c_int);
                            return tmp___52;
                        }
                        53 => {
                            break '_yy_match;
                        }
                        54 => {
                            c = *yytext.offset(0 as libc::c_int as isize);
                            fprintf(
                                stderr,
                                b"%s:%d:lexical error\0" as *const u8
                                    as *const libc::c_char,
                                (*p).fname,
                                yylineno,
                            );
                            if c as libc::c_int & 128 as libc::c_int != 0 {
                                fprintf(
                                    stderr,
                                    b"('\\%03o').\n\0" as *const u8 as *const libc::c_char,
                                    c as libc::c_int,
                                );
                            } else {
                                tmp___53 = __ctype_b_loc();
                                if *(*tmp___53).offset(c as libc::c_int as isize)
                                    as libc::c_int & 16384 as libc::c_int != 0
                                {
                                    if c as libc::c_int == 92 as libc::c_int {
                                        fprintf(
                                            stderr,
                                            b"('\\\\').\n\0" as *const u8 as *const libc::c_char,
                                        );
                                    } else {
                                        fprintf(
                                            stderr,
                                            b"('%c').\n\0" as *const u8 as *const libc::c_char,
                                            c as libc::c_int,
                                        );
                                    }
                                } else {
                                    fprintf(
                                        stderr,
                                        b"('\\%03o').\n\0" as *const u8 as *const libc::c_char,
                                        c as libc::c_int,
                                    );
                                }
                            }
                            exit(1 as libc::c_int);
                        }
                        55 => {
                            fwrite(
                                yytext as *const libc::c_void,
                                yyleng as size_t,
                                1 as libc::c_int as size_t,
                                yyout,
                            );
                            break '_yy_match;
                        }
                        57 => return 0 as libc::c_int,
                        56 => {
                            yy_amount_of_matched_text = yy_cp.offset_from(yytext)
                                as libc::c_long as libc::c_int - 1 as libc::c_int;
                            *yy_cp = yy_hold_char;
                            if (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
                                .yy_buffer_status == 0 as libc::c_int
                            {
                                yy_n_chars = (**yy_buffer_stack
                                    .offset(yy_buffer_stack_top as isize))
                                    .yy_n_chars;
                                let ref mut fresh20 = (**yy_buffer_stack
                                    .offset(yy_buffer_stack_top as isize))
                                    .yy_input_file;
                                *fresh20 = yyin;
                                (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
                                    .yy_buffer_status = 1 as libc::c_int;
                            }
                            if yy_c_buf_p as libc::c_ulong
                                <= ((**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
                                    .yy_ch_buf)
                                    .offset(yy_n_chars as isize) as libc::c_ulong
                            {
                                yy_c_buf_p = yytext
                                    .offset(yy_amount_of_matched_text as isize);
                                yy_current_state = yy_get_previous_state();
                                yy_next_state = yy_try_NUL_trans(yy_current_state);
                                yy_bp = yytext.offset(0 as libc::c_int as isize);
                                if yy_next_state != 0 {
                                    current_block = 5159167864558512679;
                                    break;
                                } else {
                                    current_block = 4402115142504265260;
                                    break;
                                }
                            } else {
                                tmp___54 = yy_get_next_buffer();
                                match tmp___54 {
                                    1 => {
                                        yy_did_buffer_switch_on_eof = 0 as libc::c_int;
                                        yy_c_buf_p = yytext.offset(0 as libc::c_int as isize);
                                        yy_act = 56 as libc::c_int
                                            + (yy_start - 1 as libc::c_int) / 2 as libc::c_int
                                            + 1 as libc::c_int;
                                    }
                                    0 => {
                                        yy_c_buf_p = yytext
                                            .offset(yy_amount_of_matched_text as isize);
                                        yy_current_state = yy_get_previous_state();
                                        yy_cp = yy_c_buf_p;
                                        yy_bp = yytext.offset(0 as libc::c_int as isize);
                                        break '_yy_find_action;
                                    }
                                    2 => {
                                        yy_c_buf_p = ((**yy_buffer_stack
                                            .offset(yy_buffer_stack_top as isize))
                                            .yy_ch_buf)
                                            .offset(yy_n_chars as isize);
                                        yy_current_state = yy_get_previous_state();
                                        yy_cp = yy_c_buf_p;
                                        yy_bp = yytext.offset(0 as libc::c_int as isize);
                                        continue '_yy_find_action;
                                    }
                                    _ => {
                                        break '_yy_match;
                                    }
                                }
                            }
                        }
                        _ => {
                            yy_fatal_error(
                                b"fatal flex scanner internal error--no action found\0"
                                    as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                }
                match current_block {
                    4402115142504265260 => {
                        yy_cp = yy_c_buf_p;
                    }
                    _ => {
                        yy_c_buf_p = yy_c_buf_p.offset(1);
                        yy_cp = yy_c_buf_p;
                        yy_current_state = yy_next_state;
                        break;
                    }
                }
            }
        }
    };
}
unsafe extern "C" fn yy_get_next_buffer() -> libc::c_int {
    let mut dest: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut source: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut number_to_move: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut ret_val: libc::c_int = 0;
    let mut tmp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut num_to_read: libc::c_int = 0;
    let mut b: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut yy_c_buf_p_offset: libc::c_int = 0;
    let mut new_size: libc::c_int = 0;
    let mut tmp___1: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut c: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: libc::c_int = 0;
    let mut tmp___4: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___5: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___6: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___7: size_t = 0;
    let mut tmp___8: libc::c_int = 0;
    let mut new_size___0: libc::c_int = 0;
    let mut tmp___9: *mut libc::c_void = 0 as *mut libc::c_void;
    dest = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf;
    source = yytext;
    if yy_c_buf_p as libc::c_ulong
        > ((**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf)
            .offset((yy_n_chars + 1 as libc::c_int) as isize) as libc::c_ulong
    {
        yy_fatal_error(
            b"fatal flex scanner internal error--end of buffer missed\0" as *const u8
                as *const libc::c_char,
        );
    }
    if (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_fill_buffer
        == 0 as libc::c_int
    {
        if yy_c_buf_p.offset_from(yytext) as libc::c_long == 1 as libc::c_long {
            return 1 as libc::c_int
        } else {
            return 2 as libc::c_int
        }
    }
    number_to_move = (yy_c_buf_p.offset_from(yytext) as libc::c_long - 1 as libc::c_long)
        as libc::c_int;
    i = 0 as libc::c_int;
    while i < number_to_move {
        tmp = dest;
        dest = dest.offset(1);
        tmp___0 = source;
        source = source.offset(1);
        *tmp = *tmp___0;
        i += 1;
    }
    if (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_buffer_status
        == 2 as libc::c_int
    {
        yy_n_chars = 0 as libc::c_int;
        (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_n_chars = yy_n_chars;
    } else {
        num_to_read = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
            .yy_buf_size - number_to_move - 1 as libc::c_int;
        while num_to_read <= 0 as libc::c_int {
            b = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
            yy_c_buf_p_offset = yy_c_buf_p.offset_from((*b).yy_ch_buf) as libc::c_long
                as libc::c_int;
            if (*b).yy_is_our_buffer != 0 {
                new_size = (*b).yy_buf_size * 2 as libc::c_int;
                if new_size <= 0 as libc::c_int {
                    (*b).yy_buf_size += (*b).yy_buf_size / 8 as libc::c_int;
                } else {
                    (*b).yy_buf_size *= 2 as libc::c_int;
                }
                tmp___1 = yyrealloc(
                    (*b).yy_ch_buf as *mut libc::c_void,
                    ((*b).yy_buf_size + 2 as libc::c_int) as yy_size_t,
                );
                (*b).yy_ch_buf = tmp___1 as *mut libc::c_char;
            } else {
                (*b).yy_ch_buf = 0 as *mut libc::c_void as *mut libc::c_char;
            }
            if ((*b).yy_ch_buf).is_null() {
                yy_fatal_error(
                    b"fatal error - scanner input buffer overflow\0" as *const u8
                        as *const libc::c_char,
                );
            }
            yy_c_buf_p = ((*b).yy_ch_buf).offset(yy_c_buf_p_offset as isize);
            num_to_read = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
                .yy_buf_size - number_to_move - 1 as libc::c_int;
        }
        if num_to_read > 8192 as libc::c_int {
            num_to_read = 8192 as libc::c_int;
        }
        if (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_is_interactive
            != 0
        {
            c = '*' as i32;
            n = 0 as libc::c_int;
            while n < num_to_read {
                c = getc(yyin);
                if !(c != -(1 as libc::c_int)) {
                    break;
                }
                if !(c != 10 as libc::c_int) {
                    break;
                }
                *((**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf)
                    .offset(number_to_move as isize)
                    .offset(n as isize) = c as libc::c_char;
                n += 1;
            }
            if c == 10 as libc::c_int {
                tmp___2 = n;
                n += 1;
                *((**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf)
                    .offset(number_to_move as isize)
                    .offset(tmp___2 as isize) = c as libc::c_char;
            }
            if c == -(1 as libc::c_int) {
                tmp___3 = ferror(yyin);
                if tmp___3 != 0 {
                    yy_fatal_error(
                        b"input in flex scanner failed\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
            yy_n_chars = n;
        } else {
            tmp___4 = __errno_location();
            *tmp___4 = 0 as libc::c_int;
            loop {
                tmp___7 = fread(
                    ((**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf)
                        .offset(number_to_move as isize) as *mut libc::c_void,
                    1 as libc::c_int as size_t,
                    num_to_read as yy_size_t,
                    yyin,
                );
                yy_n_chars = tmp___7 as libc::c_int;
                if !(yy_n_chars == 0 as libc::c_int) {
                    break;
                }
                tmp___8 = ferror(yyin);
                if tmp___8 == 0 {
                    break;
                }
                tmp___5 = __errno_location();
                if *tmp___5 != 4 as libc::c_int {
                    yy_fatal_error(
                        b"input in flex scanner failed\0" as *const u8
                            as *const libc::c_char,
                    );
                } else {
                    tmp___6 = __errno_location();
                    *tmp___6 = 0 as libc::c_int;
                    clearerr(yyin);
                }
            }
        }
        (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_n_chars = yy_n_chars;
    }
    if yy_n_chars == 0 as libc::c_int {
        if number_to_move == 0 as libc::c_int {
            ret_val = 1 as libc::c_int;
            yyrestart(yyin);
        } else {
            ret_val = 2 as libc::c_int;
            (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
                .yy_buffer_status = 2 as libc::c_int;
        }
    } else {
        ret_val = 0 as libc::c_int;
    }
    if yy_n_chars + number_to_move
        > (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_buf_size
    {
        new_size___0 = yy_n_chars + number_to_move + (yy_n_chars >> 1 as libc::c_int);
        tmp___9 = yyrealloc(
            (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf
                as *mut libc::c_void,
            new_size___0 as yy_size_t,
        );
        let ref mut fresh21 = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
            .yy_ch_buf;
        *fresh21 = tmp___9 as *mut libc::c_char;
        if ((**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf).is_null()
        {
            yy_fatal_error(
                b"out of dynamic memory in yy_get_next_buffer()\0" as *const u8
                    as *const libc::c_char,
            );
        }
        (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
            .yy_buf_size = new_size___0 - 2 as libc::c_int;
    }
    yy_n_chars += number_to_move;
    *((**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf)
        .offset(yy_n_chars as isize) = 0 as libc::c_int as libc::c_char;
    *((**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf)
        .offset(
            (yy_n_chars + 1 as libc::c_int) as isize,
        ) = 0 as libc::c_int as libc::c_char;
    yytext = ((**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_ch_buf)
        .offset(0 as libc::c_int as isize);
    return ret_val;
}
unsafe extern "C" fn yy_get_previous_state() -> yy_state_type {
    let mut yy_current_state: yy_state_type = 0;
    let mut yy_cp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut yy_c: YY_CHAR = 0;
    let mut tmp: libc::c_int = 0;
    yy_current_state = yy_start;
    yy_cp = yytext.offset(0 as libc::c_int as isize);
    while (yy_cp as libc::c_ulong) < yy_c_buf_p as libc::c_ulong {
        if *yy_cp != 0 {
            tmp = yy_ec[*yy_cp as YY_CHAR as usize] as libc::c_int;
        } else {
            tmp = 1 as libc::c_int;
        }
        yy_c = tmp as YY_CHAR;
        if yy_accept[yy_current_state as usize] != 0 {
            yy_last_accepting_state = yy_current_state;
            yy_last_accepting_cpos = yy_cp;
        }
        while yy_chk[(yy_base[yy_current_state as usize] as libc::c_int
            + yy_c as libc::c_int) as usize] as libc::c_int != yy_current_state
        {
            yy_current_state = yy_def[yy_current_state as usize] as libc::c_int;
            if yy_current_state >= 290 as libc::c_int {
                yy_c = yy_meta[yy_c as usize];
            }
        }
        yy_current_state = yy_nxt[(yy_base[yy_current_state as usize] as libc::c_int
            + yy_c as libc::c_int) as usize] as yy_state_type;
        yy_cp = yy_cp.offset(1);
    }
    return yy_current_state;
}
unsafe extern "C" fn yy_try_NUL_trans(
    mut yy_current_state: yy_state_type,
) -> yy_state_type {
    let mut yy_is_jam: libc::c_int = 0;
    let mut yy_cp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut yy_c: YY_CHAR = 0;
    let mut tmp: libc::c_int = 0;
    yy_cp = yy_c_buf_p;
    yy_c = 1 as libc::c_int as YY_CHAR;
    if yy_accept[yy_current_state as usize] != 0 {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
    }
    while yy_chk[(yy_base[yy_current_state as usize] as libc::c_int
        + yy_c as libc::c_int) as usize] as libc::c_int != yy_current_state
    {
        yy_current_state = yy_def[yy_current_state as usize] as libc::c_int;
        if yy_current_state >= 290 as libc::c_int {
            yy_c = yy_meta[yy_c as usize];
        }
    }
    yy_current_state = yy_nxt[(yy_base[yy_current_state as usize] as libc::c_int
        + yy_c as libc::c_int) as usize] as yy_state_type;
    yy_is_jam = (yy_current_state == 289 as libc::c_int) as libc::c_int;
    if yy_is_jam != 0 {
        tmp = 0 as libc::c_int;
    } else {
        tmp = yy_current_state;
    }
    return tmp;
}
pub unsafe extern "C" fn yyrestart(mut input_file: *mut FILE) {
    let mut tmp: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp___0: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    if !yy_buffer_stack.is_null() {
        tmp = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if tmp.is_null() {
        yyensure_buffer_stack();
        let ref mut fresh22 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
        *fresh22 = yy_create_buffer(yyin, 16384 as libc::c_int);
    }
    if !yy_buffer_stack.is_null() {
        tmp___0 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp___0 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    yy_init_buffer(tmp___0, input_file);
    yy_load_buffer_state();
}
pub unsafe extern "C" fn yy_switch_to_buffer(mut new_buffer: YY_BUFFER_STATE) {
    let mut tmp: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp___0: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    yyensure_buffer_stack();
    if !yy_buffer_stack.is_null() {
        tmp = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if tmp as libc::c_ulong == new_buffer as libc::c_ulong {
        return;
    }
    if !yy_buffer_stack.is_null() {
        tmp___0 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp___0 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if !tmp___0.is_null() {
        *yy_c_buf_p = yy_hold_char;
        let ref mut fresh23 = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
            .yy_buf_pos;
        *fresh23 = yy_c_buf_p;
        (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_n_chars = yy_n_chars;
    }
    let ref mut fresh24 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    *fresh24 = new_buffer;
    yy_load_buffer_state();
    yy_did_buffer_switch_on_eof = 1 as libc::c_int;
}
unsafe extern "C" fn yy_load_buffer_state() {
    yy_n_chars = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_n_chars;
    yy_c_buf_p = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_buf_pos;
    yytext = yy_c_buf_p;
    yyin = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_input_file;
    yy_hold_char = *yy_c_buf_p;
}
pub unsafe extern "C" fn yy_create_buffer(
    mut file: *mut FILE,
    mut size: libc::c_int,
) -> YY_BUFFER_STATE {
    let mut b: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = yyalloc(::std::mem::size_of::<yy_buffer_state>() as libc::c_ulong);
    b = tmp as YY_BUFFER_STATE;
    if b.is_null() {
        yy_fatal_error(
            b"out of dynamic memory in yy_create_buffer()\0" as *const u8
                as *const libc::c_char,
        );
    }
    (*b).yy_buf_size = size;
    tmp___0 = yyalloc(((*b).yy_buf_size + 2 as libc::c_int) as yy_size_t);
    (*b).yy_ch_buf = tmp___0 as *mut libc::c_char;
    if ((*b).yy_ch_buf).is_null() {
        yy_fatal_error(
            b"out of dynamic memory in yy_create_buffer()\0" as *const u8
                as *const libc::c_char,
        );
    }
    (*b).yy_is_our_buffer = 1 as libc::c_int;
    yy_init_buffer(b, file);
    return b;
}
pub unsafe extern "C" fn yy_delete_buffer(mut b: YY_BUFFER_STATE) {
    let mut tmp: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    if b.is_null() {
        return;
    }
    if !yy_buffer_stack.is_null() {
        tmp = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if b as libc::c_ulong == tmp as libc::c_ulong {
        let ref mut fresh25 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
        *fresh25 = 0 as YY_BUFFER_STATE;
    }
    if (*b).yy_is_our_buffer != 0 {
        yyfree((*b).yy_ch_buf as *mut libc::c_void);
    }
    yyfree(b as *mut libc::c_void);
}
unsafe extern "C" fn yy_init_buffer(mut b: YY_BUFFER_STATE, mut file: *mut FILE) {
    let mut oerrno: libc::c_int = 0;
    let mut tmp: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut tmp___0: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp___1: libc::c_int = 0;
    let mut tmp___2: libc::c_int = 0;
    let mut tmp___3: *mut libc::c_int = 0 as *mut libc::c_int;
    tmp = __errno_location();
    oerrno = *tmp;
    yy_flush_buffer(b);
    (*b).yy_input_file = file;
    (*b).yy_fill_buffer = 1 as libc::c_int;
    if !yy_buffer_stack.is_null() {
        tmp___0 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp___0 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if b as libc::c_ulong != tmp___0 as libc::c_ulong {
        (*b).yy_bs_lineno = 1 as libc::c_int;
        (*b).yy_bs_column = 0 as libc::c_int;
    }
    if !file.is_null() {
        tmp___1 = fileno(file);
        tmp___2 = isatty(tmp___1);
        (*b).yy_is_interactive = (tmp___2 > 0 as libc::c_int) as libc::c_int;
    } else {
        (*b).yy_is_interactive = 0 as libc::c_int;
    }
    tmp___3 = __errno_location();
    *tmp___3 = oerrno;
}
pub unsafe extern "C" fn yy_flush_buffer(mut b: YY_BUFFER_STATE) {
    let mut tmp: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    if b.is_null() {
        return;
    }
    (*b).yy_n_chars = 0 as libc::c_int;
    *((*b).yy_ch_buf)
        .offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
    *((*b).yy_ch_buf)
        .offset(1 as libc::c_int as isize) = 0 as libc::c_int as libc::c_char;
    (*b).yy_buf_pos = ((*b).yy_ch_buf).offset(0 as libc::c_int as isize);
    (*b).yy_at_bol = 1 as libc::c_int;
    (*b).yy_buffer_status = 0 as libc::c_int;
    if !yy_buffer_stack.is_null() {
        tmp = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if b as libc::c_ulong == tmp as libc::c_ulong {
        yy_load_buffer_state();
    }
}
pub unsafe extern "C" fn yypush_buffer_state(mut new_buffer: YY_BUFFER_STATE) {
    let mut tmp: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp___0: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    if new_buffer as libc::c_ulong == 0 as *mut libc::c_void as libc::c_ulong {
        return;
    }
    yyensure_buffer_stack();
    if !yy_buffer_stack.is_null() {
        tmp = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if !tmp.is_null() {
        *yy_c_buf_p = yy_hold_char;
        let ref mut fresh26 = (**yy_buffer_stack.offset(yy_buffer_stack_top as isize))
            .yy_buf_pos;
        *fresh26 = yy_c_buf_p;
        (**yy_buffer_stack.offset(yy_buffer_stack_top as isize)).yy_n_chars = yy_n_chars;
    }
    if !yy_buffer_stack.is_null() {
        tmp___0 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp___0 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if !tmp___0.is_null() {
        yy_buffer_stack_top = yy_buffer_stack_top.wrapping_add(1);
    }
    let ref mut fresh27 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    *fresh27 = new_buffer;
    yy_load_buffer_state();
    yy_did_buffer_switch_on_eof = 1 as libc::c_int;
}
pub unsafe extern "C" fn yypop_buffer_state() {
    let mut tmp: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp___0: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp___1: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    if !yy_buffer_stack.is_null() {
        tmp = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if tmp.is_null() {
        return;
    }
    if !yy_buffer_stack.is_null() {
        tmp___0 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp___0 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    yy_delete_buffer(tmp___0);
    let ref mut fresh28 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    *fresh28 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    if yy_buffer_stack_top > 0 as libc::c_ulong {
        yy_buffer_stack_top = yy_buffer_stack_top.wrapping_sub(1);
    }
    if !yy_buffer_stack.is_null() {
        tmp___1 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
    } else {
        tmp___1 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
    }
    if !tmp___1.is_null() {
        yy_load_buffer_state();
        yy_did_buffer_switch_on_eof = 1 as libc::c_int;
    }
}
unsafe extern "C" fn yyensure_buffer_stack() {
    let mut num_to_alloc: yy_size_t = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut grow_size: yy_size_t = 0;
    let mut tmp___0: *mut libc::c_void = 0 as *mut libc::c_void;
    if yy_buffer_stack.is_null() {
        num_to_alloc = 1 as libc::c_int as yy_size_t;
        tmp = yyalloc(
            num_to_alloc
                .wrapping_mul(
                    ::std::mem::size_of::<*mut yy_buffer_state>() as libc::c_ulong,
                ),
        );
        yy_buffer_stack = tmp as *mut *mut yy_buffer_state;
        if yy_buffer_stack.is_null() {
            yy_fatal_error(
                b"out of dynamic memory in yyensure_buffer_stack()\0" as *const u8
                    as *const libc::c_char,
            );
        }
        memset(
            yy_buffer_stack as *mut libc::c_void,
            0 as libc::c_int,
            num_to_alloc
                .wrapping_mul(
                    ::std::mem::size_of::<*mut yy_buffer_state>() as libc::c_ulong,
                ),
        );
        yy_buffer_stack_max = num_to_alloc;
        yy_buffer_stack_top = 0 as libc::c_int as size_t;
        return;
    }
    if yy_buffer_stack_top >= yy_buffer_stack_max.wrapping_sub(1 as libc::c_ulong) {
        grow_size = 8 as libc::c_int as yy_size_t;
        num_to_alloc = yy_buffer_stack_max.wrapping_add(grow_size);
        tmp___0 = yyrealloc(
            yy_buffer_stack as *mut libc::c_void,
            num_to_alloc
                .wrapping_mul(
                    ::std::mem::size_of::<*mut yy_buffer_state>() as libc::c_ulong,
                ),
        );
        yy_buffer_stack = tmp___0 as *mut *mut yy_buffer_state;
        if yy_buffer_stack.is_null() {
            yy_fatal_error(
                b"out of dynamic memory in yyensure_buffer_stack()\0" as *const u8
                    as *const libc::c_char,
            );
        }
        memset(
            yy_buffer_stack.offset(yy_buffer_stack_max as isize) as *mut libc::c_void,
            0 as libc::c_int,
            grow_size
                .wrapping_mul(
                    ::std::mem::size_of::<*mut yy_buffer_state>() as libc::c_ulong,
                ),
        );
        yy_buffer_stack_max = num_to_alloc;
    }
}
pub unsafe extern "C" fn yy_scan_buffer(
    mut base: *mut libc::c_char,
    mut size: yy_size_t,
) -> YY_BUFFER_STATE {
    let mut b: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: *mut libc::c_char = 0 as *mut libc::c_char;
    if size < 2 as libc::c_ulong {
        return 0 as *mut libc::c_void as YY_BUFFER_STATE
    } else {
        if *base.offset(size.wrapping_sub(2 as libc::c_ulong) as isize) as libc::c_int
            != 0 as libc::c_int
        {
            return 0 as *mut libc::c_void as YY_BUFFER_STATE
        } else {
            if *base.offset(size.wrapping_sub(1 as libc::c_ulong) as isize)
                as libc::c_int != 0 as libc::c_int
            {
                return 0 as *mut libc::c_void as YY_BUFFER_STATE;
            }
        }
    }
    tmp = yyalloc(::std::mem::size_of::<yy_buffer_state>() as libc::c_ulong);
    b = tmp as YY_BUFFER_STATE;
    if b.is_null() {
        yy_fatal_error(
            b"out of dynamic memory in yy_scan_buffer()\0" as *const u8
                as *const libc::c_char,
        );
    }
    (*b).yy_buf_size = size.wrapping_sub(2 as libc::c_ulong) as libc::c_int;
    tmp___0 = base;
    (*b).yy_ch_buf = tmp___0;
    (*b).yy_buf_pos = tmp___0;
    (*b).yy_is_our_buffer = 0 as libc::c_int;
    (*b).yy_input_file = 0 as *mut libc::c_void as *mut FILE;
    (*b).yy_n_chars = (*b).yy_buf_size;
    (*b).yy_is_interactive = 0 as libc::c_int;
    (*b).yy_at_bol = 1 as libc::c_int;
    (*b).yy_fill_buffer = 0 as libc::c_int;
    (*b).yy_buffer_status = 0 as libc::c_int;
    yy_switch_to_buffer(b);
    return b;
}
pub unsafe extern "C" fn yy_scan_string(
    mut yystr: *const libc::c_char,
) -> YY_BUFFER_STATE {
    let mut tmp: size_t = 0;
    let mut tmp___0: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    tmp = strlen(yystr);
    tmp___0 = yy_scan_bytes(yystr, tmp as libc::c_int);
    return tmp___0;
}
pub unsafe extern "C" fn yy_scan_bytes(
    mut yybytes: *const libc::c_char,
    mut _yybytes_len: libc::c_int,
) -> YY_BUFFER_STATE {
    let mut b: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut buf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut n: yy_size_t = 0;
    let mut i: libc::c_int = 0;
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut tmp___0: libc::c_char = 0;
    n = (_yybytes_len + 2 as libc::c_int) as yy_size_t;
    tmp = yyalloc(n);
    buf = tmp as *mut libc::c_char;
    if buf.is_null() {
        yy_fatal_error(
            b"out of dynamic memory in yy_scan_bytes()\0" as *const u8
                as *const libc::c_char,
        );
    }
    i = 0 as libc::c_int;
    while i < _yybytes_len {
        *buf.offset(i as isize) = *yybytes.offset(i as isize);
        i += 1;
    }
    tmp___0 = 0 as libc::c_int as libc::c_char;
    *buf.offset((_yybytes_len + 1 as libc::c_int) as isize) = tmp___0;
    *buf.offset(_yybytes_len as isize) = tmp___0;
    b = yy_scan_buffer(buf, n);
    if b.is_null() {
        yy_fatal_error(
            b"bad buffer in yy_scan_bytes()\0" as *const u8 as *const libc::c_char,
        );
    }
    (*b).yy_is_our_buffer = 1 as libc::c_int;
    return b;
}
unsafe extern "C" fn yy_fatal_error(mut msg: *const libc::c_char) -> ! {
    fprintf(stderr, b"%s\n\0" as *const u8 as *const libc::c_char, msg);
    exit(2 as libc::c_int);
}
pub unsafe extern "C" fn yyget_lineno() -> libc::c_int {
    return yylineno;
}
pub unsafe extern "C" fn yyget_in() -> *mut FILE {
    return yyin;
}
pub unsafe extern "C" fn yyget_out() -> *mut FILE {
    return yyout;
}
pub unsafe extern "C" fn yyget_leng() -> libc::c_int {
    return yyleng;
}
pub unsafe extern "C" fn yyget_text() -> *mut libc::c_char {
    return yytext;
}
pub unsafe extern "C" fn yyset_lineno(mut _line_number: libc::c_int) {
    yylineno = _line_number;
}
pub unsafe extern "C" fn yyset_in(mut _in_str: *mut FILE) {
    yyin = _in_str;
}
pub unsafe extern "C" fn yyset_out(mut _out_str: *mut FILE) {
    yyout = _out_str;
}
pub unsafe extern "C" fn yyget_debug() -> libc::c_int {
    return yy_flex_debug;
}
pub unsafe extern "C" fn yyset_debug(mut _bdebug: libc::c_int) {
    yy_flex_debug = _bdebug;
}
unsafe extern "C" fn yy_init_globals() -> libc::c_int {
    yylineno = 1 as libc::c_int;
    yy_buffer_stack = 0 as *mut libc::c_void as *mut YY_BUFFER_STATE;
    yy_buffer_stack_top = 0 as libc::c_int as size_t;
    yy_buffer_stack_max = 0 as libc::c_int as size_t;
    yy_c_buf_p = 0 as *mut libc::c_void as *mut libc::c_char;
    yy_init = 0 as libc::c_int;
    yy_start = 0 as libc::c_int;
    yyin = 0 as *mut libc::c_void as *mut FILE;
    yyout = 0 as *mut libc::c_void as *mut FILE;
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn yylex_destroy() -> libc::c_int {
    let mut tmp: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    let mut tmp___0: YY_BUFFER_STATE = 0 as *mut yy_buffer_state;
    loop {
        if !yy_buffer_stack.is_null() {
            tmp___0 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
        } else {
            tmp___0 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
        }
        if tmp___0.is_null() {
            break;
        }
        if !yy_buffer_stack.is_null() {
            tmp = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
        } else {
            tmp = 0 as *mut libc::c_void as YY_BUFFER_STATE;
        }
        yy_delete_buffer(tmp);
        let ref mut fresh29 = *yy_buffer_stack.offset(yy_buffer_stack_top as isize);
        *fresh29 = 0 as *mut libc::c_void as YY_BUFFER_STATE;
        yypop_buffer_state();
    }
    yyfree(yy_buffer_stack as *mut libc::c_void);
    yy_buffer_stack = 0 as *mut libc::c_void as *mut YY_BUFFER_STATE;
    yy_init_globals();
    return 0 as libc::c_int;
}
pub unsafe extern "C" fn yyalloc(mut size: yy_size_t) -> *mut libc::c_void {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = malloc(size);
    return tmp;
}
pub unsafe extern "C" fn yyrealloc(
    mut ptr: *mut libc::c_void,
    mut size: yy_size_t,
) -> *mut libc::c_void {
    let mut tmp: *mut libc::c_void = 0 as *mut libc::c_void;
    tmp = realloc(ptr, size);
    return tmp;
}
pub unsafe extern "C" fn yyfree(mut ptr: *mut libc::c_void) {
    free(ptr as *mut libc::c_char as *mut libc::c_void);
}
unsafe extern "C" fn yyerror(mut p: *mut parser_state, mut s: *const libc::c_char) {
    (*p).nerr += 1;
    if !((*p).fname).is_null() {
        fprintf(
            stderr,
            b"%s:%d:%s\n\0" as *const u8 as *const libc::c_char,
            (*p).fname,
            (*p).lineno,
            s,
        );
    } else {
        fprintf(
            stderr,
            b"%d:%s\n\0" as *const u8 as *const libc::c_char,
            (*p).lineno,
            s,
        );
    };
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *const libc::c_char,
            ) as i32,
        )
    }
}
