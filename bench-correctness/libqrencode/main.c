/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
enum __anonenum_QRencodeMode_707716630 {
    QR_MODE_NUL = -1,
    QR_MODE_NUM = 0,
    QR_MODE_AN = 1,
    QR_MODE_8 = 2,
    QR_MODE_KANJI = 3,
    QR_MODE_STRUCTURE = 4,
    QR_MODE_ECI = 5,
    QR_MODE_FNC1FIRST = 6,
    QR_MODE_FNC1SECOND = 7
} ;
typedef enum __anonenum_QRencodeMode_707716630 QRencodeMode;
enum __anonenum_QRecLevel_598008851 {
    QR_ECLEVEL_L = 0,
    QR_ECLEVEL_M = 1,
    QR_ECLEVEL_Q = 2,
    QR_ECLEVEL_H = 3
} ;
typedef enum __anonenum_QRecLevel_598008851 QRecLevel;
struct _QRinput ;
typedef struct _QRinput QRinput;
struct _QRinput_Struct ;
typedef struct _QRinput_Struct QRinput_Struct;
struct __anonstruct_QRcode_929122250 {
   int version ;
   int width ;
   unsigned char *data ;
};
typedef struct __anonstruct_QRcode_929122250 QRcode;
struct __anonstruct_BitStream_209270119 {
   size_t length ;
   size_t datasize ;
   unsigned char *data ;
};
typedef struct __anonstruct_BitStream_209270119 BitStream;
struct _QRinput_List ;
typedef struct _QRinput_List QRinput_List;
struct _QRinput_List {
   QRencodeMode mode ;
   int size ;
   unsigned char *data ;
   BitStream *bstream ;
   QRinput_List *next ;
};
struct _QRinput {
   int version ;
   QRecLevel level ;
   QRinput_List *head ;
   QRinput_List *tail ;
   int mqr ;
   int fnc1 ;
   unsigned char appid ;
};
struct _QRinput_InputList ;
typedef struct _QRinput_InputList QRinput_InputList;
struct _QRinput_InputList {
   QRinput *input ;
   QRinput_InputList *next ;
};
struct _QRinput_Struct {
   int size ;
   int parity ;
   QRinput_InputList *head ;
   QRinput_InputList *tail ;
};
struct __anonstruct_RSblock_1044616699 {
   int dataLength ;
   int eccLength ;
   unsigned char *data ;
   unsigned char *ecc ;
};
typedef struct __anonstruct_RSblock_1044616699 RSblock;
struct __anonstruct_QRRawCode_1053786244 {
   int version ;
   int dataLength ;
   int eccLength ;
   unsigned char *datacode ;
   unsigned char *ecccode ;
   int b1 ;
   int blocks ;
   RSblock *rsblock ;
   int count ;
};
typedef struct __anonstruct_QRRawCode_1053786244 QRRawCode;
typedef void *iconv_t;
struct _DataChunk {
   QRencodeMode mode ;
   int size ;
   int bits ;
   unsigned char *data ;
   struct _DataChunk *next ;
};
typedef struct _DataChunk DataChunk;
struct __anonstruct_QRdata_391029226 {
   unsigned char *data ;
   int size ;
   int mqr ;
   int version ;
   QRecLevel level ;
   DataChunk *chunks ;
   DataChunk *last ;
   int eccResult ;
};
typedef struct __anonstruct_QRdata_391029226 QRdata;
struct FormatInfo {
   int version ;
   QRecLevel level ;
};
struct __anonstruct_FrameFiller_528872232 {
   int width ;
   unsigned char *frame ;
   int x ;
   int y ;
   int dir ;
   int bit ;
   int mqr ;
};
typedef struct __anonstruct_FrameFiller_528872232 FrameFiller;
struct _QRcode_List {
   QRcode *code ;
   struct _QRcode_List *next ;
};
typedef struct _QRcode_List QRcode_List;
struct __anonstruct_MQRRawCode_892681476 {
   int version ;
   int dataLength ;
   int eccLength ;
   unsigned char *datacode ;
   unsigned char *ecccode ;
   RSblock *rsblock ;
   int oddbits ;
   int count ;
};
typedef struct __anonstruct_MQRRawCode_892681476 MQRRawCode;
struct __anonstruct_TestString_48814953 {
   char *str ;
   int version ;
   QRecLevel level ;
   QRencodeMode hint ;
   int casesensitive ;
};
typedef struct __anonstruct_TestString_48814953 TestString;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __anonstruct_QRspec_Capacity_897426155 {
   int width ;
   int words ;
   int remainder ;
   int ec[4] ;
};
typedef struct __anonstruct_QRspec_Capacity_897426155 QRspec_Capacity;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef int MaskMaker(int  , unsigned char const   * , unsigned char * );
struct __anonstruct_MQRspec_Capacity_991265789 {
   int width ;
   int ec[4] ;
};
typedef struct __anonstruct_MQRspec_Capacity_991265789 MQRspec_Capacity;
typedef void MaskMaker___0(int  , unsigned char const   * , unsigned char * );
#pragma merger("0","/tmp/cil-Xj15PZd2.i","")
extern int printf(char const   * __restrict  __format  , ...) ;
extern int puts(char const   *__s ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
BitStream *BitStream_new(void) ;
void BitStream_free(BitStream *bstream ) ;
int QRinput_mergeBitStream(QRinput *input , BitStream *bstream ) ;
QRRawCode *QRraw_new(QRinput *input ) ;
void QRraw_free(QRRawCode *raw ) ;
int assertionFailed ;
int assertionNum ;
char const   levelChar[4] ;
char const   *modeStr[5] ;
void testInit(int tests___0 ) ;
void testStartReal(char const   *func , char const   *name ) ;
void testEnd(int result ) ;
void testFinish(void) ;
void testReport(int expectedTests ) ;
int ncmpBin(char *correct , BitStream *bstream , size_t len ) ;
int cmpBin(char *correct , BitStream *bstream ) ;
void printFrame(int width , unsigned char *frame ) ;
void printQRcode(QRcode *code ) ;
void printQRRawCodeFromQRinput(QRinput *input ) ;
void printQRinput(QRinput *input ) ;
void printQRinputInfo(QRinput *input ) ;
void printQRinputStruct(QRinput_Struct *s ) ;
void printBinary(unsigned char *data , int length ) ;
void printBstream(BitStream *bstream ) ;
void show_QRcode(QRcode *qrcode ) ;
static int tests  =    0;
static int failed  =    0;
int assertionFailed  =    0;
int assertionNum  =    0;
static char const   *testName  =    (char const   *)((void *)0);
static char const   *testFunc  =    (char const   *)((void *)0);
char const   levelChar[4]  = {      (char const   )'L',      (char const   )'M',      (char const   )'Q',      (char const   )'H'};
char const   *modeStr[5]  = {      "nm",      "an",      "8",      "kj", 
        "st"};
int ncmpBin(char *correct , BitStream *bstream , size_t len ) 
{ 
  int bit ;
  size_t i ;
  char *p ;

  {
  if (len != bstream->length) {
    printf((char const   * __restrict  )"Length is not match: %zu, %zu expected.\n",
           bstream->length, len);
    return (-1);
  }
  p = correct;
  i = (size_t )0;
  while ((int )*p != 0) {
    while ((int )*p == 32) {
      p ++;
    }
    if ((int )*p == 49) {
      bit = 1;
    } else {
      bit = 0;
    }
    if ((int )*(bstream->data + i) != bit) {
      return (-1);
    }
    i ++;
    p ++;
    if (i == len) {
      break;
    }
  }
  return (0);
}
}
int cmpBin(char *correct , BitStream *bstream ) 
{ 
  size_t len ;
  char *p ;
  int tmp ;

  {
  len = (size_t )0;
  p = correct;
  while ((int )*p != 0) {
    if ((int )*p != 32) {
      len ++;
    }
    p ++;
  }
  tmp = ncmpBin(correct, bstream, len);
  return (tmp);
}
}
void testInit(int tests___0 ) 
{ 


  {
  printf((char const   * __restrict  )"1..%d\n", tests___0);
  return;
}
}
void testStartReal(char const   *func , char const   *name ) 
{ 


  {
  tests ++;
  testName = name;
  testFunc = func;
  assertionFailed = 0;
  assertionNum = 0;
  return;
}
}
void testEnd(int result ) 
{ 


  {
  if (result) {
    printf((char const   * __restrict  )"not ok %d %s: %s\n", tests, testFunc, testName);
    failed ++;
  } else {
    printf((char const   * __restrict  )"ok %d %s: %s\n", tests, testFunc, testName);
  }
  return;
}
}
void testFinish(void) 
{ 


  {
  if (assertionFailed) {
    printf((char const   * __restrict  )"not ok %d %s: %s (%d assertions failed.)\n",
           tests, testFunc, testName, assertionFailed);
    failed ++;
  } else {
    printf((char const   * __restrict  )"ok %d %s: %s (%d assertions passed.)\n",
           tests, testFunc, testName, assertionNum);
  }
  return;
}
}
void testReport(int expectedTests ) 
{ 


  {
  printf((char const   * __restrict  )"Total %d tests, %d fails.\n", tests, failed);
  if (failed) {
    exit(-1);
  }
  if (expectedTests != tests) {
    printf((char const   * __restrict  )"WARNING: the number of the executed tests (%d) is not equal to the expecetd (%d).\n",
           tests, expectedTests);
  }
  return;
}
}
int testNum(void) 
{ 


  {
  return (tests);
}
}
void printBinary(unsigned char *data , int length ) 
{ 
  int i ;
  char const   *tmp ;

  {
  i = 0;
  while (i < length) {
    if (*(data + i)) {
      tmp = "1";
    } else {
      tmp = "0";
    }
    printf((char const   * __restrict  )tmp);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  return;
}
}
void printBstream(BitStream *bstream ) 
{ 


  {
  printBinary(bstream->data, (int )bstream->length);
  return;
}
}
void printQRinput(QRinput *input ) 
{ 
  QRinput_List *list ;
  int i ;

  {
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    i = 0;
    while (i < list->size) {
      printf((char const   * __restrict  )"0x%02x,", (int )*(list->data + i));
      i ++;
    }
    list = list->next;
  }
  printf((char const   * __restrict  )"\n");
  return;
}
}
void printQRinputInfo(QRinput *input ) 
{ 
  QRinput_List *list ;
  BitStream *b ;
  int i ;
  int ret ;

  {
  printf((char const   * __restrict  )"QRinput info:\n");
  printf((char const   * __restrict  )" version: %d\n", input->version);
  printf((char const   * __restrict  )" level  : %c\n", (int const   )levelChar[input->level]);
  list = input->head;
  i = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    i ++;
    list = list->next;
  }
  printf((char const   * __restrict  )"  chunks: %d\n", i);
  b = BitStream_new();
  ret = QRinput_mergeBitStream(input, b);
  if (ret == 0) {
    printf((char const   * __restrict  )"  bitstream-size: %zu\n", b->length);
    BitStream_free(b);
  }
  list = input->head;
  i = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"\t#%d: mode = %s, size = %d\n", i, modeStr[list->mode],
           list->size);
    i ++;
    list = list->next;
  }
  return;
}
}
void printQRinputStruct(QRinput_Struct *s ) 
{ 
  QRinput_InputList *list ;
  int i ;

  {
  i = 1;
  printf((char const   * __restrict  )"Struct size: %d\n", s->size);
  printf((char const   * __restrict  )"Struct parity: %08x\n", s->parity);
  list = s->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"Symbol %d - ", i);
    printQRinputInfo(list->input);
    i ++;
    list = list->next;
  }
  return;
}
}
void printFrame(int width , unsigned char *frame ) 
{ 
  int x ;
  int y ;
  unsigned char *tmp ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      tmp = frame;
      frame ++;
      printf((char const   * __restrict  )"%02x ", (int )*tmp);
      x ++;
    }
    printf((char const   * __restrict  )"\n");
    y ++;
  }
  return;
}
}
void printQRcode(QRcode *code ) 
{ 


  {
  printFrame(code->width, code->data);
  return;
}
}
void printQRRawCodeFromQRinput(QRinput *input ) 
{ 
  QRRawCode *raw ;
  int i ;

  {
  puts("QRRawCode dump image:");
  raw = QRraw_new(input);
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    puts("Failed to generate QRRawCode from this input.\n");
    return;
  }
  i = 0;
  while (i < raw->dataLength) {
    printf((char const   * __restrict  )" %02x", (int )*(raw->datacode + i));
    i ++;
  }
  i = 0;
  while (i < raw->eccLength) {
    printf((char const   * __restrict  )" %02x", (int )*(raw->ecccode + i));
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  QRraw_free(raw);
  return;
}
}
void show_QRcode(QRcode *qrcode ) 
{ 


  {
  return;
}
}
#pragma merger("0","/tmp/cil-0Jpg0ahF.i","")
extern int putchar(int __c ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
extern int iconv_close(iconv_t __cd ) ;
DataChunk *DataChunk_new(QRencodeMode mode ) ;
void DataChunk_free(DataChunk *chunk ) ;
void DataChunk_freeList(DataChunk *list ) ;
void DataChunk_dumpChunkList(DataChunk *list ) ;
int DataChunk_totalSize(DataChunk *list ) ;
unsigned char *DataChunk_concatChunkList(DataChunk *list , int *retsize ) ;
DataChunk *DataChunk_new(QRencodeMode mode ) 
{ 
  DataChunk *chunk ;
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(DataChunk ));
  chunk = (DataChunk *)tmp;
  if ((unsigned long )chunk == (unsigned long )((void *)0)) {
    return ((DataChunk *)((void *)0));
  }
  chunk->mode = mode;
  return (chunk);
}
}
void DataChunk_free(DataChunk *chunk ) 
{ 


  {
  if (chunk) {
    if (chunk->data) {
      free((void *)chunk->data);
    }
    free((void *)chunk);
  }
  return;
}
}
void DataChunk_freeList(DataChunk *list ) 
{ 
  DataChunk *next ;

  {
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    next = list->next;
    DataChunk_free(list);
    list = next;
  }
  return;
}
}
static void dumpNum(DataChunk *chunk ) 
{ 


  {
  printf((char const   * __restrict  )"%s\n", chunk->data);
  return;
}
}
static void dumpAn(DataChunk *chunk ) 
{ 


  {
  printf((char const   * __restrict  )"%s\n", chunk->data);
  return;
}
}
static void dump8(DataChunk *chunk ) 
{ 
  int i ;
  int j ;
  unsigned char c ;
  int count ;
  unsigned char buf[16] ;

  {
  count = 0;
  i = 0;
  while (i < chunk->size) {
    buf[count] = *(chunk->data + i);
    c = *(chunk->data + i);
    if ((int )c >= 32) {
      if ((int )c <= 126) {
        putchar((int )c);
      } else {
        putchar('.');
      }
    } else {
      putchar('.');
    }
    count ++;
    if (count >= 16) {
      putchar(' ');
      j = 0;
      while (j < 16) {
        printf((char const   * __restrict  )" %02x", (int )buf[j]);
        j ++;
      }
      count = 0;
      putchar('\n');
    }
    i ++;
  }
  if (count > 0) {
    i = 0;
    while (i < 16 - count) {
      putchar(' ');
      i ++;
    }
    putchar(' ');
    j = 0;
    while (j < count) {
      printf((char const   * __restrict  )" %02x", (int )buf[j]);
      j ++;
    }
    count = 0;
    putchar('\n');
  }
  return;
}
}
static void dumpKanji(DataChunk *chunk ) 
{ 
  iconv_t conv ;
  char *inbuf ;
  char *outbuf ;
  char *outp ;
  size_t inbytes ;
  size_t outbytes ;
  size_t ret ;
  void *tmp ;

  {
  conv = iconv_open("UTF-8", "SHIFT_JIS");
  inbytes = (size_t )chunk->size;
  inbuf = (char *)chunk->data;
  outbytes = inbytes * 4UL + 1UL;
  tmp = malloc(inbytes * 4UL + 1UL);
  outbuf = (char *)tmp;
  outp = outbuf;
  ret = iconv(conv, (char ** __restrict  )(& inbuf), (size_t * __restrict  )(& inbytes),
              (char ** __restrict  )(& outp), (size_t * __restrict  )(& outbytes));
  if (ret == 0xffffffffffffffffUL) {
    perror((char const   *)((void *)0));
  }
  *outp = (char )'\000';
  printf((char const   * __restrict  )"%s\n", outbuf);
  iconv_close(conv);
  free((void *)outbuf);
  return;
}
}
static void dumpChunk(DataChunk *chunk ) 
{ 


  {
  switch ((int )chunk->mode) {
  case 0: 
  printf((char const   * __restrict  )"Numeric: %d bytes\n", chunk->size);
  dumpNum(chunk);
  break;
  case 1: 
  printf((char const   * __restrict  )"AlphaNumeric: %d bytes\n", chunk->size);
  dumpAn(chunk);
  break;
  case 2: 
  printf((char const   * __restrict  )"8-bit data: %d bytes\n", chunk->size);
  dump8(chunk);
  break;
  case 3: 
  printf((char const   * __restrict  )"Kanji: %d bytes\n", chunk->size);
  dumpKanji(chunk);
  break;
  default: 
  printf((char const   * __restrict  )"Invalid or reserved: %d bytes\n", chunk->size);
  dump8(chunk);
  break;
  }
  return;
}
}
void DataChunk_dumpChunkList(DataChunk *list ) 
{ 


  {
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    dumpChunk(list);
    list = list->next;
  }
  return;
}
}
int DataChunk_totalSize(DataChunk *list ) 
{ 
  int size ;

  {
  size = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    size += list->size;
    list = list->next;
  }
  return (size);
}
}
unsigned char *DataChunk_concatChunkList(DataChunk *list , int *retsize ) 
{ 
  int size ;
  int idx ;
  unsigned char *data ;
  void *tmp ;

  {
  size = DataChunk_totalSize(list);
  if (size <= 0) {
    return ((unsigned char *)((void *)0));
  }
  tmp = malloc((size_t )(size + 1));
  data = (unsigned char *)tmp;
  idx = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    memcpy((void * __restrict  )(data + idx), (void const   * __restrict  )list->data,
           (size_t )list->size);
    idx += list->size;
    list = list->next;
  }
  *(data + size) = (unsigned char )'\000';
  *retsize = size;
  return (data);
}
}
#pragma merger("0","/tmp/cil-ChGvGbbo.i","")
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
int QRspec_lengthIndicator(QRencodeMode mode , int version ) ;
void QRspec_getEccSpec(int version , QRecLevel level , int *spec ) ;
BitStream *BitStream_newWithBits(size_t size , unsigned char *bits ) ;
unsigned char *Mask_makeMask(int width , unsigned char *frame , int mask , QRecLevel level ) ;
int MQRspec_getDataLengthBit(int version , QRecLevel level ) ;
int MQRspec_getECCLength(int version , QRecLevel level ) ;
int MQRspec_lengthIndicator(QRencodeMode mode , int version ) ;
unsigned char *MMask_makeMask(int version , unsigned char *frame , int mask , QRecLevel level ) ;
struct FormatInfo MQRformat[8] ;
QRdata *QRdata_new(void) ;
QRdata *QRdata_newMQR(void) ;
int QRdata_decodeBitStream(QRdata *qrdata , BitStream *bstream ) ;
void QRdata_dump(QRdata *data ) ;
void QRdata_free(QRdata *qrdata ) ;
int QRcode_decodeVersion(QRcode *code ) ;
int QRcode_decodeFormat(QRcode *code , QRecLevel *level , int *mask ) ;
unsigned char *QRcode_unmask(QRcode *code ) ;
BitStream *QRcode_extractBits(QRcode *code , int *dataLength , int *eccLength ) ;
QRdata *QRcode_decodeBits(QRcode *code ) ;
QRdata *QRcode_decode(QRcode *code ) ;
int QRcode_decodeFormatMQR(QRcode *code , int *version , QRecLevel *level , int *mask ) ;
unsigned char *QRcode_unmaskMQR(QRcode *code ) ;
BitStream *QRcode_extractBitsMQR(QRcode *code , int *dataLength , int *eccLength ,
                                 int *version , QRecLevel *level ) ;
QRdata *QRcode_decodeBitsMQR(QRcode *code ) ;
QRdata *QRcode_decodeMQR(QRcode *code ) ;
static unsigned int bitToInt(unsigned char *bits , int length ) 
{ 
  int i ;
  unsigned int val ;

  {
  val = 0U;
  i = 0;
  while (i < length) {
    val <<= 1;
    val |= (unsigned int )((int )*(bits + i) & 1);
    i ++;
  }
  return (val);
}
}
static int decodeLength(int *bits_length , unsigned char **bits , QRencodeMode mode ,
                        int version , int mqr ) 
{ 
  int i ;
  int length ;
  int lbits ;

  {
  length = 0;
  if (mqr) {
    lbits = MQRspec_lengthIndicator(mode, version);
  } else {
    lbits = QRspec_lengthIndicator(mode, version);
  }
  if (*bits_length < lbits) {
    printf((char const   * __restrict  )"Bit length is too short: %d\n", *bits_length);
    return (0);
  }
  length = 0;
  i = 0;
  while (i < lbits) {
    length <<= 1;
    length += (int )*(*bits + i);
    i ++;
  }
  *bits_length -= lbits;
  *bits += lbits;
  return (length);
}
}
static DataChunk *decodeNum(int *bits_length , unsigned char **bits , int version ,
                            int mqr ) 
{ 
  int i ;
  int size ;
  int sizeInBit ;
  int words ;
  int remain ;
  unsigned char *p ;
  char *buf ;
  char *q ;
  unsigned int val ;
  DataChunk *chunk ;
  void *tmp ;

  {
  size = decodeLength(bits_length, bits, (QRencodeMode )0, version, mqr);
  if (size < 0) {
    return ((DataChunk *)((void *)0));
  }
  words = size / 3;
  remain = size - words * 3;
  sizeInBit = words * 10;
  if (remain == 2) {
    sizeInBit += 7;
  } else
  if (remain == 1) {
    sizeInBit += 4;
  }
  if (*bits_length < sizeInBit) {
    printf((char const   * __restrict  )"Bit length is too short: %d, expected %d.\n",
           *bits_length, sizeInBit);
    return ((DataChunk *)((void *)0));
  }
  tmp = malloc((size_t )size + 1UL);
  buf = (char *)tmp;
  p = *bits;
  q = buf;
  i = 0;
  while (i < words) {
    val = bitToInt(p, 10);
    sprintf((char * __restrict  )q, (char const   * __restrict  )"%03d", val);
    p += 10;
    q += 3;
    i ++;
  }
  if (remain == 2) {
    val = bitToInt(p, 7);
    sprintf((char * __restrict  )q, (char const   * __restrict  )"%02d", val);
  } else
  if (remain == 1) {
    val = bitToInt(p, 4);
    sprintf((char * __restrict  )q, (char const   * __restrict  )"%1d", val);
  }
  *(buf + size) = (char )'\000';
  chunk = DataChunk_new((QRencodeMode )0);
  chunk->size = size;
  chunk->data = (unsigned char *)buf;
  *bits_length -= sizeInBit;
  *bits += sizeInBit;
  return (chunk);
}
}
static char const   decodeAnTable[45]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )' ',      (char const   )'$',      (char const   )'%',      (char const   )'*', 
        (char const   )'+',      (char const   )'-',      (char const   )'.',      (char const   )'/', 
        (char const   )':'};
static DataChunk *decodeAn(int *bits_length , unsigned char **bits , int version ,
                           int mqr ) 
{ 
  int i ;
  int size ;
  int sizeInBit ;
  int words ;
  int remain ;
  unsigned char *p ;
  char *buf ;
  char *q ;
  unsigned int val ;
  int ch ;
  int cl ;
  DataChunk *chunk ;
  void *tmp ;

  {
  size = decodeLength(bits_length, bits, (QRencodeMode )1, version, mqr);
  if (size < 0) {
    return ((DataChunk *)((void *)0));
  }
  words = size / 2;
  remain = size - words * 2;
  sizeInBit = words * 11 + remain * 6;
  if (*bits_length < sizeInBit) {
    printf((char const   * __restrict  )"Bit length is too short: %d, expected %d.\n",
           *bits_length, sizeInBit);
    return ((DataChunk *)((void *)0));
  }
  tmp = malloc((size_t )size + 1UL);
  buf = (char *)tmp;
  p = *bits;
  q = buf;
  i = 0;
  while (i < words) {
    val = bitToInt(p, 11);
    ch = (int )(val / 45U);
    cl = (int )(val % 45U);
    sprintf((char * __restrict  )q, (char const   * __restrict  )"%c%c", (int const   )decodeAnTable[ch],
            (int const   )decodeAnTable[cl]);
    p += 11;
    q += 2;
    i ++;
  }
  if (remain == 1) {
    val = bitToInt(p, 6);
    sprintf((char * __restrict  )q, (char const   * __restrict  )"%c", (int const   )decodeAnTable[val]);
  }
  chunk = DataChunk_new((QRencodeMode )1);
  chunk->size = size;
  chunk->data = (unsigned char *)buf;
  *bits_length -= sizeInBit;
  *bits += sizeInBit;
  return (chunk);
}
}
static DataChunk *decode8(int *bits_length , unsigned char **bits , int version ,
                          int mqr ) 
{ 
  int i ;
  int size ;
  int sizeInBit ;
  unsigned char *p ;
  unsigned char *buf ;
  unsigned char *q ;
  DataChunk *chunk ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  size = decodeLength(bits_length, bits, (QRencodeMode )2, version, mqr);
  if (size < 0) {
    return ((DataChunk *)((void *)0));
  }
  sizeInBit = size * 8;
  if (*bits_length < sizeInBit) {
    printf((char const   * __restrict  )"Bit length is too short: %d, expected %d.\n",
           *bits_length, sizeInBit);
    return ((DataChunk *)((void *)0));
  }
  tmp = malloc((size_t )size);
  buf = (unsigned char *)tmp;
  p = *bits;
  q = buf;
  i = 0;
  while (i < size) {
    tmp___0 = bitToInt(p, 8);
    *q = (unsigned char )tmp___0;
    p += 8;
    q ++;
    i ++;
  }
  chunk = DataChunk_new((QRencodeMode )2);
  chunk->size = size;
  chunk->data = buf;
  *bits_length -= sizeInBit;
  *bits += sizeInBit;
  return (chunk);
}
}
static DataChunk *decodeKanji(int *bits_length , unsigned char **bits , int version ,
                              int mqr ) 
{ 
  int i ;
  int size ;
  int sizeInBit ;
  unsigned char *p ;
  char *buf ;
  char *q ;
  unsigned int val ;
  unsigned int ch ;
  unsigned int cl ;
  DataChunk *chunk ;
  void *tmp ;

  {
  size = decodeLength(bits_length, bits, (QRencodeMode )3, version, mqr);
  if (size < 0) {
    return ((DataChunk *)((void *)0));
  }
  sizeInBit = size * 13;
  if (*bits_length < sizeInBit) {
    printf((char const   * __restrict  )"Bit length is too short: %d, expected %d.\n",
           *bits_length, sizeInBit);
    return ((DataChunk *)((void *)0));
  }
  tmp = malloc((size_t )size * 2UL + 1UL);
  buf = (char *)tmp;
  p = *bits;
  q = buf;
  i = 0;
  while (i < size) {
    val = bitToInt(p, 13);
    ch = val / 192U;
    cl = val - ch * 192U;
    val = ch * 256U + cl;
    if (val >= 7936U) {
      val += 49472U;
    } else {
      val += 33088U;
    }
    sprintf((char * __restrict  )q, (char const   * __restrict  )"%c%c", (val >> 8) & 255U,
            val & 255U);
    p += 13;
    q += 2;
    i ++;
  }
  chunk = DataChunk_new((QRencodeMode )3);
  chunk->size = size * 2;
  chunk->data = (unsigned char *)buf;
  *bits_length -= sizeInBit;
  *bits += sizeInBit;
  return (chunk);
}
}
static DataChunk *decodeChunk(int *bits_length , unsigned char **bits , int version ) 
{ 
  unsigned int val ;
  DataChunk *tmp ;
  DataChunk *tmp___0 ;
  DataChunk *tmp___1 ;
  DataChunk *tmp___2 ;

  {
  if (*bits_length < 4) {
    return ((DataChunk *)((void *)0));
  }
  val = bitToInt(*bits, 4);
  *bits_length -= 4;
  *bits += 4;
  switch (val) {
  case 0U: 
  return ((DataChunk *)((void *)0));
  case 1U: 
  tmp = decodeNum(bits_length, bits, version, 0);
  return (tmp);
  case 2U: 
  tmp___0 = decodeAn(bits_length, bits, version, 0);
  return (tmp___0);
  case 4U: 
  tmp___1 = decode8(bits_length, bits, version, 0);
  return (tmp___1);
  case 8U: 
  tmp___2 = decodeKanji(bits_length, bits, version, 0);
  return (tmp___2);
  default: 
  break;
  }
  printf((char const   * __restrict  )"Invalid mode in a chunk: %d\n", val);
  return ((DataChunk *)((void *)0));
}
}
static DataChunk *decodeChunkMQR(int *bits_length , unsigned char **bits , int version ) 
{ 
  int modebits ;
  int termbits ;
  unsigned int val ;
  DataChunk *tmp ;
  DataChunk *tmp___0 ;
  DataChunk *tmp___1 ;
  DataChunk *tmp___2 ;

  {
  modebits = version - 1;
  termbits = version * 2 + 1;
  if (*bits_length >= termbits) {
    val = bitToInt(*bits, termbits);
    if (val == 0U) {
      *bits += termbits;
      *bits_length -= termbits;
      return ((DataChunk *)((void *)0));
    }
  } else {
    if (*bits_length < modebits) {
      val = bitToInt(*bits, *bits_length);
    } else {
      val = bitToInt(*bits, modebits);
    }
    if (val == 0U) {
      return ((DataChunk *)((void *)0));
    } else {
      printf((char const   * __restrict  )"Terminating bits include 1-bit.\n");
      return ((DataChunk *)((void *)0));
    }
  }
  val = bitToInt(*bits, modebits);
  if (version == 4) {
    if (val > 3U) {
      printf((char const   * __restrict  )"Invalid mode number %d.\n", val);
    }
  }
  *bits_length -= modebits;
  *bits += modebits;
  switch (val) {
  case 0U: 
  tmp = decodeNum(bits_length, bits, version, 1);
  return (tmp);
  case 1U: 
  tmp___0 = decodeAn(bits_length, bits, version, 1);
  return (tmp___0);
  case 2U: 
  tmp___1 = decode8(bits_length, bits, version, 1);
  return (tmp___1);
  case 3U: 
  tmp___2 = decodeKanji(bits_length, bits, version, 1);
  return (tmp___2);
  default: 
  break;
  }
  printf((char const   * __restrict  )"Invalid mode in a chunk: %d\n", val);
  return ((DataChunk *)((void *)0));
}
}
static int appendChunk(QRdata *qrdata , int *bits_length , unsigned char **bits ) 
{ 
  DataChunk *chunk ;

  {
  if (qrdata->mqr) {
    chunk = decodeChunkMQR(bits_length, bits, qrdata->version);
  } else {
    chunk = decodeChunk(bits_length, bits, qrdata->version);
  }
  if ((unsigned long )chunk == (unsigned long )((void *)0)) {
    return (1);
  }
  if ((unsigned long )qrdata->last == (unsigned long )((void *)0)) {
    qrdata->chunks = chunk;
  } else {
    (qrdata->last)->next = chunk;
  }
  qrdata->last = chunk;
  return (0);
}
}
QRdata *QRdata_new(void) 
{ 
  QRdata *qrdata ;
  void *tmp ;

  {
  tmp = calloc(sizeof(QRdata ), (size_t )1);
  qrdata = (QRdata *)tmp;
  if ((unsigned long )qrdata == (unsigned long )((void *)0)) {
    return ((QRdata *)((void *)0));
  }
  qrdata->eccResult = 0;
  return (qrdata);
}
}
QRdata *QRdata_newMQR(void) 
{ 
  QRdata *qrdata ;

  {
  qrdata = QRdata_new();
  if ((unsigned long )qrdata == (unsigned long )((void *)0)) {
    return ((QRdata *)((void *)0));
  }
  qrdata->mqr = 1;
  return (qrdata);
}
}
void QRdata_free(QRdata *qrdata ) 
{ 


  {
  DataChunk_freeList(qrdata->chunks);
  if ((unsigned long )qrdata->data != (unsigned long )((void *)0)) {
    free((void *)qrdata->data);
  }
  free((void *)qrdata);
  return;
}
}
static int QRdata_decodeBits(QRdata *qrdata , int length , unsigned char *bits ) 
{ 
  int ret ;

  {
  ret = 0;
  while (ret == 0) {
    ret = appendChunk(qrdata, & length, & bits);
  }
  return (length);
}
}
int QRdata_decodeBitStream(QRdata *qrdata , BitStream *bstream ) 
{ 
  int tmp ;

  {
  tmp = QRdata_decodeBits(qrdata, (int )bstream->length, bstream->data);
  return (tmp);
}
}
void QRdata_dump(QRdata *data ) 
{ 


  {
  DataChunk_dumpChunkList(data->chunks);
  return;
}
}
int QRcode_decodeVersion(QRcode *code ) 
{ 
  unsigned int v1 ;
  unsigned int v2 ;
  int x ;
  int y ;
  int width ;
  unsigned char *p ;

  {
  width = code->width;
  if (width < 45) {
    return ((width - 21) / 4 + 1);
  }
  v1 = 0U;
  p = (code->data + width * (width - 9)) + 5;
  x = 0;
  while (x < 6) {
    y = 0;
    while (y < 3) {
      v1 <<= 1;
      v1 |= (unsigned int )((int )*((p - y * width) - x) & 1);
      y ++;
    }
    x ++;
  }
  v2 = 0U;
  p = ((code->data + width * 5) + width) - 9;
  y = 0;
  while (y < 6) {
    x = 0;
    while (x < 3) {
      v2 <<= 1;
      v2 |= (unsigned int )((int )*((p - y * width) - x) & 1);
      x ++;
    }
    y ++;
  }
  if (v1 != v2) {
    printf((char const   * __restrict  )"Two verion patterns are different.\n");
    return (-1);
  }
  return ((int )(v1 >> 12));
}
}
int QRcode_decodeFormat(QRcode *code , QRecLevel *level , int *mask ) 
{ 
  unsigned int v1 ;
  unsigned int v2 ;
  int i ;
  int width ;
  unsigned char *p ;

  {
  width = code->width;
  v1 = 0U;
  p = code->data + width * 8;
  i = 0;
  while (i < 8) {
    v1 <<= 1;
    if (i < 6) {
      v1 |= (unsigned int )((int )*(p + i) & 1);
    } else {
      v1 |= (unsigned int )((int )*((p + i) + 1) & 1);
    }
    i ++;
  }
  p = (code->data + width * 7) + 8;
  i = 0;
  while (i < 7) {
    v1 <<= 1;
    if (i < 1) {
      v1 |= (unsigned int )((int )*(p - width * i) & 1);
    } else {
      v1 |= (unsigned int )((int )*(p - width * (i + 1)) & 1);
    }
    i ++;
  }
  v2 = 0U;
  p = (code->data + width * (width - 1)) + 8;
  i = 0;
  while (i < 7) {
    v2 <<= 1;
    v2 |= (unsigned int )((int )*(p - width * i) & 1);
    i ++;
  }
  p = ((code->data + width * 8) + width) - 8;
  i = 0;
  while (i < 8) {
    v2 <<= 1;
    v2 |= (unsigned int )((int )*(p + i) & 1);
    i ++;
  }
  if (v1 != v2) {
    printf((char const   * __restrict  )"Two format infos are different.\n");
    return (-1);
  }
  v1 = (v1 ^ 21522U) >> 10;
  *mask = (int )(v1 & 7U);
  switch ((v1 >> 3) & 3U) {
  case 1U: 
  *level = (QRecLevel )0;
  break;
  case 0U: 
  *level = (QRecLevel )1;
  break;
  case 3U: 
  *level = (QRecLevel )2;
  break;
  case 2U: 
  *level = (QRecLevel )3;
  break;
  default: 
  break;
  }
  return (0);
}
}
static unsigned char *unmask(QRcode *code , QRecLevel level , int mask ) 
{ 
  unsigned char *unmasked ;

  {
  unmasked = Mask_makeMask(code->width, code->data, mask, level);
  return (unmasked);
}
}
unsigned char *QRcode_unmask(QRcode *code ) 
{ 
  int ret ;
  int version ;
  int mask ;
  QRecLevel level ;
  unsigned char *tmp ;

  {
  version = QRcode_decodeVersion(code);
  if (version < 1) {
    return ((unsigned char *)((void *)0));
  }
  ret = QRcode_decodeFormat(code, & level, & mask);
  if (ret < 0) {
    return ((unsigned char *)((void *)0));
  }
  tmp = unmask(code, level, mask);
  return (tmp);
}
}
static FrameFiller *FrameFiller_new(int width , unsigned char *frame , int mqr ) 
{ 
  FrameFiller *filler ;
  void *tmp ;

  {
  tmp = malloc(sizeof(FrameFiller ));
  filler = (FrameFiller *)tmp;
  if ((unsigned long )filler == (unsigned long )((void *)0)) {
    return ((FrameFiller *)((void *)0));
  }
  filler->width = width;
  filler->frame = frame;
  filler->x = width - 1;
  filler->y = width - 1;
  filler->dir = -1;
  filler->bit = -1;
  filler->mqr = mqr;
  return (filler);
}
}
static unsigned char *FrameFiller_next(FrameFiller *filler ) 
{ 
  unsigned char *p ;
  int x ;
  int y ;
  int w ;
  unsigned char *tmp ;

  {
  if (filler->bit == -1) {
    filler->bit = 0;
    return ((filler->frame + filler->y * filler->width) + filler->x);
  }
  x = filler->x;
  y = filler->y;
  p = filler->frame;
  w = filler->width;
  if (filler->bit == 0) {
    x --;
    (filler->bit) ++;
  } else {
    x ++;
    y += filler->dir;
    (filler->bit) --;
  }
  if (filler->dir < 0) {
    if (y < 0) {
      y = 0;
      x -= 2;
      filler->dir = 1;
      if (! filler->mqr) {
        if (x == 6) {
          x --;
          y = 9;
        }
      }
    }
  } else
  if (y == w) {
    y = w - 1;
    x -= 2;
    filler->dir = -1;
    if (! filler->mqr) {
      if (x == 6) {
        x --;
        y -= 8;
      }
    }
  }
  if (x < 0) {
    return ((unsigned char *)((void *)0));
  } else
  if (y < 0) {
    return ((unsigned char *)((void *)0));
  }
  filler->x = x;
  filler->y = y;
  if ((int )*(p + (y * w + x)) & 128) {
    tmp = FrameFiller_next(filler);
    return (tmp);
  }
  return (p + (y * w + x));
}
}
static BitStream *extractBits(int width , unsigned char *frame , int *spec ) 
{ 
  BitStream *bstream ;
  unsigned char *bits ;
  unsigned char *p ;
  unsigned char *q ;
  FrameFiller *filler ;
  int i ;
  int j ;
  int col ;
  int row ;
  int d1 ;
  int b1 ;
  int blocks ;
  int idx ;
  int words ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  blocks = *(spec + 0) + *(spec + 3);
  words = *(spec + 0) * *(spec + 1) + *(spec + 3) * *(spec + 4);
  d1 = *(spec + 1);
  b1 = *(spec + 0);
  tmp = malloc((size_t )words * 8UL);
  bits = (unsigned char *)tmp;
  col = 0;
  row = col;
  filler = FrameFiller_new(width, frame, 0);
  i = 0;
  while (i < words) {
    col = i / blocks;
    if (col >= d1) {
      tmp___0 = b1;
    } else {
      tmp___0 = 0;
    }
    row = i % blocks + tmp___0;
    if (row > b1) {
      tmp___1 = row - b1;
    } else {
      tmp___1 = 0;
    }
    idx = (d1 * row + col) + tmp___1;
    q = bits + idx * 8;
    j = 0;
    while (j < 8) {
      p = FrameFiller_next(filler);
      *(q + j) = (unsigned char )((int )*p & 1);
      j ++;
    }
    i ++;
  }
  free((void *)filler);
  bstream = BitStream_newWithBits((size_t )words * 8UL, bits);
  free((void *)bits);
  return (bstream);
}
}
BitStream *QRcode_extractBits(QRcode *code , int *dataLength , int *eccLength ) 
{ 
  BitStream *bstream ;
  unsigned char *unmasked ;
  int spec[5] ;
  int ret ;
  int version ;
  int mask ;
  QRecLevel level ;

  {
  version = QRcode_decodeVersion(code);
  if (version < 1) {
    return ((BitStream *)((void *)0));
  }
  ret = QRcode_decodeFormat(code, & level, & mask);
  if (ret < 0) {
    return ((BitStream *)((void *)0));
  }
  QRspec_getEccSpec(version, level, (int *)(spec));
  unmasked = unmask(code, level, mask);
  if ((unsigned long )unmasked == (unsigned long )((void *)0)) {
    return ((BitStream *)((void *)0));
  }
  bstream = extractBits(code->width, unmasked, (int *)(spec));
  free((void *)unmasked);
  *dataLength = (spec[0] * spec[1] + spec[3] * spec[4]) * 8;
  *eccLength = ((spec[0] + spec[3]) * spec[2]) * 8;
  return (bstream);
}
}
static int checkRemainderWords(int length , unsigned char *bits , int remainder ) 
{ 
  int rbits ;
  int words ;
  unsigned char *p ;
  unsigned char v ;
  int i ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  words = remainder / 8;
  rbits = remainder - words * 8;
  bits += length - remainder;
  i = 0;
  while (i < rbits) {
    if (((int )*(bits + i) & 1) != 0) {
      printf((char const   * __restrict  )"Terminating code includes 1-bit.\n");
      printBinary(bits, remainder);
      return (-1);
    }
    i ++;
  }
  p = bits + rbits;
  i = 0;
  while (i < words) {
    tmp = bitToInt(p, 8);
    v = (unsigned char )tmp;
    if (i & 1) {
      tmp___0 = 17;
    } else {
      tmp___0 = 236;
    }
    if ((int )v != tmp___0) {
      printf((char const   * __restrict  )"Remainder codewords wrong.\n");
      printBinary(bits, remainder);
      return (-1);
    }
    p += 8;
    i ++;
  }
  return (0);
}
}
QRdata *QRcode_decodeBits(QRcode *code ) 
{ 
  BitStream *bstream ;
  unsigned char *unmasked ;
  int spec[5] ;
  int ret ;
  int version ;
  int mask ;
  int length ;
  QRecLevel level ;
  QRdata *qrdata ;

  {
  version = QRcode_decodeVersion(code);
  if (version < 1) {
    return ((QRdata *)((void *)0));
  }
  ret = QRcode_decodeFormat(code, & level, & mask);
  if (ret < 0) {
    return ((QRdata *)((void *)0));
  }
  QRspec_getEccSpec(version, level, (int *)(spec));
  length = (spec[0] * spec[1] + spec[3] * spec[4]) * 8;
  unmasked = unmask(code, level, mask);
  if ((unsigned long )unmasked == (unsigned long )((void *)0)) {
    return ((QRdata *)((void *)0));
  }
  bstream = extractBits(code->width, unmasked, (int *)(spec));
  free((void *)unmasked);
  qrdata = QRdata_new();
  qrdata->version = version;
  qrdata->level = level;
  ret = QRdata_decodeBitStream(qrdata, bstream);
  if (ret > 0) {
    checkRemainderWords(length, bstream->data, ret);
  }
  BitStream_free(bstream);
  return (qrdata);
}
}
void QRdata_concatChunks(QRdata *qrdata ) 
{ 


  {
  qrdata->data = DataChunk_concatChunkList(qrdata->chunks, & qrdata->size);
  return;
}
}
QRdata *QRcode_decode(QRcode *code ) 
{ 
  QRdata *qrdata ;

  {
  qrdata = QRcode_decodeBits(code);
  QRdata_concatChunks(qrdata);
  return (qrdata);
}
}
struct FormatInfo MQRformat[8]  = 
  {      {1, (QRecLevel )0}, 
        {2, (QRecLevel )0}, 
        {2, (QRecLevel )1}, 
        {3, (QRecLevel )0}, 
        {3, (QRecLevel )1}, 
        {4, (QRecLevel )0}, 
        {4, (QRecLevel )1}, 
        {4, (QRecLevel )2}};
int QRcode_decodeFormatMQR(QRcode *code , int *version , QRecLevel *level , int *mask ) 
{ 
  unsigned int v ;
  unsigned int t ;
  int i ;
  int width ;
  unsigned char *p ;

  {
  width = code->width;
  v = 0U;
  p = (code->data + width * 8) + 1;
  i = 0;
  while (i < 8) {
    v <<= 1;
    v |= (unsigned int )((int )*(p + i) & 1);
    i ++;
  }
  p = (code->data + width * 7) + 8;
  i = 0;
  while (i < 7) {
    v <<= 1;
    v |= (unsigned int )((int )*(p - width * i) & 1);
    i ++;
  }
  v ^= 17477U;
  *mask = (int )((v >> 10) & 3U);
  t = (v >> 12) & 7U;
  *version = MQRformat[t].version;
  *level = MQRformat[t].level;
  if (*version * 2 + 9 != width) {
    printf((char const   * __restrict  )"Decoded version number does not match to the size.\n");
    return (-1);
  }
  return (0);
}
}
static unsigned char *unmaskMQR(QRcode *code , QRecLevel level , int mask ) 
{ 
  unsigned char *unmasked ;

  {
  unmasked = MMask_makeMask(code->version, code->data, mask, level);
  return (unmasked);
}
}
unsigned char *QRcode_unmaskMQR(QRcode *code ) 
{ 
  int ret ;
  int version ;
  int mask ;
  QRecLevel level ;
  unsigned char *tmp ;

  {
  ret = QRcode_decodeFormatMQR(code, & version, & level, & mask);
  if (ret < 0) {
    return ((unsigned char *)((void *)0));
  }
  tmp = unmaskMQR(code, level, mask);
  return (tmp);
}
}
static BitStream *extractBitsMQR(int width , unsigned char *frame , int version ,
                                 QRecLevel level ) 
{ 
  BitStream *bstream ;
  unsigned char *bits ;
  FrameFiller *filler ;
  int i ;
  int size ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;

  {
  tmp = MQRspec_getDataLengthBit(version, level);
  tmp___0 = MQRspec_getECCLength(version, level);
  size = tmp + tmp___0 * 8;
  tmp___1 = malloc((size_t )size);
  bits = (unsigned char *)tmp___1;
  filler = FrameFiller_new(width, frame, 1);
  i = 0;
  while (i < size) {
    tmp___2 = FrameFiller_next(filler);
    *(bits + i) = (unsigned char )((int )*tmp___2 & 1);
    i ++;
  }
  free((void *)filler);
  bstream = BitStream_newWithBits((size_t )size, bits);
  free((void *)bits);
  return (bstream);
}
}
BitStream *QRcode_extractBitsMQR(QRcode *code , int *dataLength , int *eccLength ,
                                 int *version , QRecLevel *level ) 
{ 
  BitStream *bstream ;
  unsigned char *unmasked ;
  int ret ;
  int mask ;
  int tmp ;

  {
  ret = QRcode_decodeFormatMQR(code, version, level, & mask);
  if (ret < 0) {
    return ((BitStream *)((void *)0));
  }
  unmasked = unmaskMQR(code, *level, mask);
  if ((unsigned long )unmasked == (unsigned long )((void *)0)) {
    return ((BitStream *)((void *)0));
  }
  *dataLength = MQRspec_getDataLengthBit(*version, *level);
  tmp = MQRspec_getECCLength(*version, *level);
  *eccLength = tmp * 8;
  bstream = extractBitsMQR(code->width, unmasked, *version, *level);
  free((void *)unmasked);
  return (bstream);
}
}
static int checkRemainderWordsMQR(int length , unsigned char *bits , int remainder ,
                                  int version ) 
{ 
  int rbits ;
  int words ;
  int paddings ;
  unsigned char *p ;
  unsigned char v ;
  int i ;
  int decoded ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  decoded = length - remainder;
  bits += decoded;
  words = (decoded + 7) / 8;
  rbits = words * 8 - decoded;
  i = 0;
  while (i < rbits) {
    if (((int )*(bits + i) & 1) != 0) {
      printf((char const   * __restrict  )"Terminating code includes 1-bit.\n");
      printBinary(bits, remainder);
      return (-1);
    }
    i ++;
  }
  paddings = (length - words * 8) / 8;
  p = bits + rbits;
  i = 0;
  while (i < paddings) {
    tmp = bitToInt(p, 8);
    v = (unsigned char )tmp;
    if (i & 1) {
      tmp___0 = 17;
    } else {
      tmp___0 = 236;
    }
    if ((int )v != tmp___0) {
      printf((char const   * __restrict  )"Remainder codewords wrong.\n");
      printBinary(bits, remainder);
      return (-1);
    }
    p += 8;
    i ++;
  }
  rbits = length - (paddings + words) * 8;
  if (rbits > 0) {
    if (version == 1) {
      goto _L___0;
    } else
    if (version == 3) {
      _L___0: /* CIL Label */ 
      if (rbits == 4) {
        tmp___1 = bitToInt(p, 4);
        v = (unsigned char )tmp___1;
        if ((int )v != 0) {
          printf((char const   * __restrict  )"Last padding bits include 1-bit.\n");
          return (-1);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (version == 1) {
        tmp___2 = 4;
      } else
      if (version == 3) {
        tmp___2 = 4;
      } else {
        tmp___2 = 0;
      }
      printf((char const   * __restrict  )"The length of the last padding bits is %d, not %d.\n",
             rbits, tmp___2);
      return (-1);
    }
  }
  return (0);
}
}
QRdata *QRcode_decodeBitsMQR(QRcode *code ) 
{ 
  BitStream *bstream ;
  int ret ;
  int version ;
  int dataLength ;
  int eccLength ;
  QRecLevel level ;
  QRdata *qrdata ;

  {
  bstream = QRcode_extractBitsMQR(code, & dataLength, & eccLength, & version, & level);
  if ((unsigned long )bstream == (unsigned long )((void *)0)) {
    return ((QRdata *)((void *)0));
  }
  qrdata = QRdata_newMQR();
  qrdata->version = version;
  qrdata->level = level;
  ret = QRdata_decodeBits(qrdata, dataLength, bstream->data);
  if (ret > 0) {
    ret = checkRemainderWordsMQR(dataLength, bstream->data, ret, version);
    if (ret < 0) {
      QRdata_free(qrdata);
      qrdata = (QRdata *)((void *)0);
    }
  }
  BitStream_free(bstream);
  return (qrdata);
}
}
QRdata *QRcode_decodeMQR(QRcode *code ) 
{ 
  QRdata *qrdata ;

  {
  qrdata = QRcode_decodeBitsMQR(code);
  if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
    QRdata_concatChunks(qrdata);
  }
  return (qrdata);
}
}
#pragma merger("0","/tmp/cil-Rh9X9RIe.i","")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
QRinput *QRinput_new(void) ;
QRinput *QRinput_new2(int version , QRecLevel level ) ;
QRinput *QRinput_newMQR(int version , QRecLevel level ) ;
int QRinput_append(QRinput *input , QRencodeMode mode , int size , unsigned char const   *data ) ;
int QRinput_setVersion(QRinput *input , int version ) ;
int QRinput_setErrorCorrectionLevel(QRinput *input , QRecLevel level ) ;
void QRinput_free(QRinput *input ) ;
QRcode *QRcode_encodeInput(QRinput *input ) ;
QRcode *QRcode_encodeString(char const   *string , int version , QRecLevel level ,
                            QRencodeMode hint , int casesensitive ) ;
QRcode *QRcode_encodeString8bit(char const   *string , int version , QRecLevel level ) ;
QRcode *QRcode_encodeStringMQR(char const   *string , int version , QRecLevel level ,
                               QRencodeMode hint , int casesensitive ) ;
QRcode *QRcode_encodeString8bitMQR(char const   *string , int version , QRecLevel level ) ;
QRcode *QRcode_encodeData(int size , unsigned char const   *data , int version , QRecLevel level ) ;
void QRcode_free(QRcode *qrcode ) ;
QRcode_List *QRcode_encodeStringStructured(char const   *string , int version , QRecLevel level ,
                                           QRencodeMode hint , int casesensitive ) ;
QRcode_List *QRcode_encodeString8bitStructured(char const   *string , int version ,
                                               QRecLevel level ) ;
int QRcode_List_size(QRcode_List *qrlist ) ;
void QRcode_List_free(QRcode_List *qrlist ) ;
void QRcode_APIVersion(int *major_version , int *minor_version , int *micro_version ) ;
char *QRcode_APIVersionString(void) ;
unsigned char QRraw_getCode(QRRawCode *raw ) ;
MQRRawCode *MQRraw_new(QRinput *input ) ;
void MQRraw_free(MQRRawCode *raw ) ;
unsigned char *FrameFiller_test(int version ) ;
unsigned char *FrameFiller_testMQR(int version ) ;
QRcode *QRcode_encodeMask(QRinput *input , int mask ) ;
int QRspec_getDataLength(int version , QRecLevel level ) ;
int QRspec_getECCLength(int version , QRecLevel level ) ;
int QRspec_getWidth(int version ) ;
int QRspec_getRemainder(int version ) ;
unsigned int QRspec_getFormatInfo(int mask , QRecLevel level ) ;
unsigned char *QRspec_newFrame(int version ) ;
int MQRspec_getWidth(int version ) ;
unsigned char *MQRspec_newFrame(int version ) ;
int Mask_writeFormatInformation(int width , unsigned char *frame , int mask , QRecLevel level ) ;
int Split_splitStringToQRinput(char const   *string , QRinput *input , QRencodeMode hint ,
                               int casesensitive ) ;
static char const   decodeAnTable___0[45]  = 
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )' ',      (char const   )'$',      (char const   )'%',      (char const   )'*', 
        (char const   )'+',      (char const   )'-',      (char const   )'.',      (char const   )'/', 
        (char const   )':'};
static void test_qrraw_new(void) 
{ 
  int i ;
  QRinput *stream ;
  char num[9] ;
  QRRawCode *raw ;

  {
  num[0] = (char )'0';
  num[1] = (char )'1';
  num[2] = (char )'2';
  num[3] = (char )'3';
  num[4] = (char )'4';
  num[5] = (char )'5';
  num[6] = (char )'6';
  num[7] = (char )'7';
  num[8] = (char )'\000';
  testStartReal("test_qrraw_new", "Test QRraw_new()");
  stream = QRinput_new();
  QRinput_setVersion(stream, 10);
  QRinput_setErrorCorrectionLevel(stream, (QRecLevel )2);
  QRinput_append(stream, (QRencodeMode )0, 8, (unsigned char const   *)((unsigned char *)(num)));
  raw = QRraw_new(stream);
  assertionNum ++;
  if (! ((unsigned long )raw != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Failed QRraw_new().\n");
  }
  assertionNum ++;
  if (! (raw->count == 0)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRraw.count = %d != 0\n", raw->count);
  }
  assertionNum ++;
  if (! (raw->version == 10)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRraw.version was not as expected. (%d)\n",
           raw->version);
  }
  assertionNum ++;
  if (! (raw->dataLength == 154)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRraw.dataLength was not as expected.\n");
  }
  assertionNum ++;
  if (! (raw->eccLength == 192)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRraw.eccLength was not as expected.\n");
  }
  assertionNum ++;
  if (! (raw->b1 == 6)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRraw.b1 was not as expected.\n");
  }
  assertionNum ++;
  if (! (raw->blocks == 8)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRraw.blocks was not as expected.\n");
  }
  i = 0;
  while (i < raw->b1) {
    assertionNum ++;
    if (! ((raw->rsblock + i)->dataLength == 19)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"QRraw.rsblock[%d].dataLength was not as expected. (%d)\n",
             i, (raw->rsblock + i)->dataLength);
    }
    i ++;
  }
  i = raw->b1;
  while (i < raw->blocks) {
    assertionNum ++;
    if (! ((raw->rsblock + i)->dataLength == 20)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"QRraw.rsblock[%d].dataLength was not as expected. (%d)\n",
             i, (raw->rsblock + i)->dataLength);
    }
    i ++;
  }
  i = 0;
  while (i < raw->blocks) {
    assertionNum ++;
    if (! ((raw->rsblock + i)->eccLength == 24)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"QRraw.rsblock[%d].eccLength was not as expected. (%d)\n",
             i, (raw->rsblock + i)->eccLength);
    }
    i ++;
  }
  QRinput_free(stream);
  QRraw_free(raw);
  testFinish();
  return;
}
}
static void test_iterate(void) 
{ 
  int i ;
  QRinput *stream ;
  char num[9] ;
  unsigned char *data ;
  QRRawCode *raw ;
  int err ;
  unsigned char tmp ;

  {
  num[0] = (char )'0';
  num[1] = (char )'1';
  num[2] = (char )'2';
  num[3] = (char )'3';
  num[4] = (char )'4';
  num[5] = (char )'5';
  num[6] = (char )'6';
  num[7] = (char )'7';
  num[8] = (char )'\000';
  err = 0;
  testStartReal("test_iterate", "Test getCode (1-L)");
  stream = QRinput_new();
  QRinput_setVersion(stream, 1);
  QRinput_setErrorCorrectionLevel(stream, (QRecLevel )0);
  QRinput_append(stream, (QRencodeMode )0, 8, (unsigned char const   *)((unsigned char *)(num)));
  raw = QRraw_new(stream);
  data = raw->datacode;
  i = 0;
  while (i < raw->dataLength) {
    tmp = QRraw_getCode(raw);
    if ((int )*(data + i) != (int )tmp) {
      err ++;
    }
    i ++;
  }
  QRinput_free(stream);
  QRraw_free(raw);
  testEnd(err);
  return;
}
}
static void test_iterate2(void) 
{ 
  int i ;
  QRinput *stream ;
  char num[9] ;
  QRRawCode *raw ;
  int err ;
  unsigned char correct[134] ;
  unsigned char tmp ;

  {
  num[0] = (char )'0';
  num[1] = (char )'1';
  num[2] = (char )'2';
  num[3] = (char )'3';
  num[4] = (char )'4';
  num[5] = (char )'5';
  num[6] = (char )'6';
  num[7] = (char )'7';
  num[8] = (char )'\000';
  err = 0;
  correct[0] = (unsigned char)16;
  correct[1] = (unsigned char)17;
  correct[2] = (unsigned char)236;
  correct[3] = (unsigned char)236;
  correct[4] = (unsigned char)32;
  correct[5] = (unsigned char)236;
  correct[6] = (unsigned char)17;
  correct[7] = (unsigned char)17;
  correct[8] = (unsigned char)12;
  correct[9] = (unsigned char)17;
  correct[10] = (unsigned char)236;
  correct[11] = (unsigned char)236;
  correct[12] = (unsigned char)86;
  correct[13] = (unsigned char)236;
  correct[14] = (unsigned char)17;
  correct[15] = (unsigned char)17;
  correct[16] = (unsigned char)97;
  correct[17] = (unsigned char)17;
  correct[18] = (unsigned char)236;
  correct[19] = (unsigned char)236;
  correct[20] = (unsigned char)128;
  correct[21] = (unsigned char)236;
  correct[22] = (unsigned char)17;
  correct[23] = (unsigned char)17;
  correct[24] = (unsigned char)236;
  correct[25] = (unsigned char)17;
  correct[26] = (unsigned char)236;
  correct[27] = (unsigned char)236;
  correct[28] = (unsigned char)17;
  correct[29] = (unsigned char)236;
  correct[30] = (unsigned char)17;
  correct[31] = (unsigned char)17;
  correct[32] = (unsigned char)236;
  correct[33] = (unsigned char)17;
  correct[34] = (unsigned char)236;
  correct[35] = (unsigned char)236;
  correct[36] = (unsigned char)17;
  correct[37] = (unsigned char)236;
  correct[38] = (unsigned char)17;
  correct[39] = (unsigned char)17;
  correct[40] = (unsigned char)236;
  correct[41] = (unsigned char)17;
  correct[42] = (unsigned char)236;
  correct[43] = (unsigned char)236;
  correct[44] = (unsigned char)17;
  correct[45] = (unsigned char)17;
  correct[46] = (unsigned char)92;
  correct[47] = (unsigned char)222;
  correct[48] = (unsigned char)104;
  correct[49] = (unsigned char)104;
  correct[50] = (unsigned char)77;
  correct[51] = (unsigned char)179;
  correct[52] = (unsigned char)219;
  correct[53] = (unsigned char)219;
  correct[54] = (unsigned char)213;
  correct[55] = (unsigned char)20;
  correct[56] = (unsigned char)225;
  correct[57] = (unsigned char)225;
  correct[58] = (unsigned char)91;
  correct[59] = (unsigned char)42;
  correct[60] = (unsigned char)31;
  correct[61] = (unsigned char)31;
  correct[62] = (unsigned char)73;
  correct[63] = (unsigned char)196;
  correct[64] = (unsigned char)120;
  correct[65] = (unsigned char)120;
  correct[66] = (unsigned char)247;
  correct[67] = (unsigned char)224;
  correct[68] = (unsigned char)91;
  correct[69] = (unsigned char)91;
  correct[70] = (unsigned char)195;
  correct[71] = (unsigned char)167;
  correct[72] = (unsigned char)193;
  correct[73] = (unsigned char)193;
  correct[74] = (unsigned char)93;
  correct[75] = (unsigned char)154;
  correct[76] = (unsigned char)234;
  correct[77] = (unsigned char)234;
  correct[78] = (unsigned char)72;
  correct[79] = (unsigned char)173;
  correct[80] = (unsigned char)157;
  correct[81] = (unsigned char)157;
  correct[82] = (unsigned char)88;
  correct[83] = (unsigned char)179;
  correct[84] = (unsigned char)63;
  correct[85] = (unsigned char)63;
  correct[86] = (unsigned char)16;
  correct[87] = (unsigned char)219;
  correct[88] = (unsigned char)191;
  correct[89] = (unsigned char)191;
  correct[90] = (unsigned char)235;
  correct[91] = (unsigned char)236;
  correct[92] = (unsigned char)5;
  correct[93] = (unsigned char)5;
  correct[94] = (unsigned char)152;
  correct[95] = (unsigned char)53;
  correct[96] = (unsigned char)131;
  correct[97] = (unsigned char)131;
  correct[98] = (unsigned char)169;
  correct[99] = (unsigned char)149;
  correct[100] = (unsigned char)166;
  correct[101] = (unsigned char)166;
  correct[102] = (unsigned char)234;
  correct[103] = (unsigned char)123;
  correct[104] = (unsigned char)141;
  correct[105] = (unsigned char)141;
  correct[106] = (unsigned char)4;
  correct[107] = (unsigned char)60;
  correct[108] = (unsigned char)8;
  correct[109] = (unsigned char)8;
  correct[110] = (unsigned char)100;
  correct[111] = (unsigned char)206;
  correct[112] = (unsigned char)62;
  correct[113] = (unsigned char)62;
  correct[114] = (unsigned char)77;
  correct[115] = (unsigned char)155;
  correct[116] = (unsigned char)48;
  correct[117] = (unsigned char)48;
  correct[118] = (unsigned char)78;
  correct[119] = (unsigned char)101;
  correct[120] = (unsigned char)214;
  correct[121] = (unsigned char)214;
  correct[122] = (unsigned char)228;
  correct[123] = (unsigned char)83;
  correct[124] = (unsigned char)44;
  correct[125] = (unsigned char)44;
  correct[126] = (unsigned char)70;
  correct[127] = (unsigned char)29;
  correct[128] = (unsigned char)46;
  correct[129] = (unsigned char)46;
  correct[130] = (unsigned char)41;
  correct[131] = (unsigned char)22;
  correct[132] = (unsigned char)39;
  correct[133] = (unsigned char)39;
  testStartReal("test_iterate2", "Test getCode (5-H)");
  stream = QRinput_new();
  QRinput_setVersion(stream, 5);
  QRinput_setErrorCorrectionLevel(stream, (QRecLevel )3);
  QRinput_append(stream, (QRencodeMode )0, 8, (unsigned char const   *)((unsigned char *)(num)));
  raw = QRraw_new(stream);
  i = 0;
  while (i < raw->dataLength) {
    tmp = QRraw_getCode(raw);
    if ((int )correct[i] != (int )tmp) {
      err ++;
    }
    i ++;
  }
  QRinput_free(stream);
  QRraw_free(raw);
  testEnd(err);
  return;
}
}
static void print_filler(void) 
{ 
  int width ;
  int version ;
  unsigned char *frame ;

  {
  version = 7;
  puts("\nPrinting debug info of FrameFiller.");
  width = QRspec_getWidth(version);
  frame = FrameFiller_test(version);
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    abort();
  }
  printFrame(width, frame);
  free((void *)frame);
  return;
}
}
static void test_filler(void) 
{ 
  unsigned char *frame ;
  int i ;
  int j ;
  int w ;
  int e ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  testStartReal("test_filler", "Frame filler test");
  i = 1;
  while (i <= 40) {
    tmp = QRspec_getDataLength(i, (QRecLevel )0);
    tmp___0 = QRspec_getECCLength(i, (QRecLevel )0);
    tmp___1 = QRspec_getRemainder(i);
    length = (tmp * 8 + tmp___0 * 8) + tmp___1;
    frame = FrameFiller_test(i);
    if ((unsigned long )frame == (unsigned long )((void *)0)) {
      assertionNum ++;
      if (! ((unsigned long )frame != (unsigned long )((void *)0))) {
        assertionFailed ++;
        printf((char const   * __restrict  )"Something wrong in version %d\n", i);
      }
    } else {
      w = QRspec_getWidth(i);
      e = 0;
      j = 0;
      while (j < w * w) {
        if ((int )*(frame + j) == 0) {
          e ++;
        }
        j ++;
      }
      assertionNum ++;
      if (! (e == 0)) {
        assertionFailed ++;
        printf((char const   * __restrict  )"Not filled bit is found. (%d,%d)\n",
               j % w, j / w);
      }
      if (i > 6) {
        tmp___2 = 3;
      } else {
        tmp___2 = 0;
      }
      e = w * ((w - 9) - tmp___2);
      assertionNum ++;
      if (! ((int )*(frame + e) == ((int )((unsigned char )((length - 1) & 127)) | 128))) {
        assertionFailed ++;
        printf((char const   * __restrict  )"Number of cell does not match.\n");
      }
      free((void *)frame);
    }
    i ++;
  }
  testFinish();
  return;
}
}
static void print_fillerMQR(void) 
{ 
  int width ;
  int version ;
  unsigned char *frame ;

  {
  version = 3;
  puts("\nPrinting debug info of FrameFiller for Micro QR.");
  version = 1;
  while (version <= 4) {
    width = MQRspec_getWidth(version);
    frame = FrameFiller_testMQR(version);
    if ((unsigned long )frame == (unsigned long )((void *)0)) {
      abort();
    }
    printFrame(width, frame);
    version ++;
  }
  return;
}
}
static void test_fillerMQR(void) 
{ 
  unsigned char *frame ;
  int i ;
  int j ;
  int w ;
  int e ;
  int length ;
  int tmp ;
  int tmp___0 ;

  {
  testStartReal("test_fillerMQR", "Micro QR Code Frame filler test");
  i = 1;
  while (i <= 4) {
    tmp = MQRspec_getDataLengthBit(i, (QRecLevel )0);
    tmp___0 = MQRspec_getECCLength(i, (QRecLevel )0);
    length = tmp + tmp___0 * 8;
    frame = FrameFiller_testMQR(i);
    if ((unsigned long )frame == (unsigned long )((void *)0)) {
      assertionNum ++;
      if (! ((unsigned long )frame != (unsigned long )((void *)0))) {
        assertionFailed ++;
        printf((char const   * __restrict  )"Something wrong in version %d\n", i);
      }
    } else {
      w = MQRspec_getWidth(i);
      e = 0;
      j = 0;
      while (j < w * w) {
        if ((int )*(frame + j) == 0) {
          e ++;
        }
        j ++;
      }
      assertionNum ++;
      if (! (e == 0)) {
        assertionFailed ++;
        printf((char const   * __restrict  )"Not filled bit is found. (%d,%d)\n",
               j % w, j / w);
      }
      if (i & 1) {
        e = w * 9 + 1;
      } else {
        e = w * (w - 1) + 1;
      }
      assertionNum ++;
      if (! ((int )*(frame + e) == ((int )((unsigned char )((length - 1) & 127)) | 128))) {
        assertionFailed ++;
        printf((char const   * __restrict  )"Number of cell does not match in version %d.\n",
               i);
      }
      free((void *)frame);
    }
    i ++;
  }
  testFinish();
  return;
}
}
static void test_format(void) 
{ 
  unsigned char *frame ;
  unsigned int format ;
  int width ;
  int i ;
  unsigned int decode ;
  int blacks ;
  int b1 ;
  int b2 ;

  {
  b1 = 0;
  b2 = 0;
  testStartReal("test_format", "Test format information(level L,mask 0)");
  width = QRspec_getWidth(1);
  frame = QRspec_newFrame(1);
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    goto ABORT;
  }
  format = QRspec_getFormatInfo(1, (QRecLevel )0);
  blacks = Mask_writeFormatInformation(width, frame, 1, (QRecLevel )0);
  decode = 0U;
  i = 0;
  while (i < 15) {
    if ((unsigned int )(1 << i) & format) {
      b2 += 2;
    }
    i ++;
  }
  i = 0;
  while (i < 8) {
    decode <<= 1;
    decode |= (unsigned int )((int )*(frame + ((width * 8 + i) + (i > 5))) & 1);
    if (decode & 1U) {
      b1 ++;
    }
    i ++;
  }
  i = 0;
  while (i < 7) {
    decode <<= 1;
    decode |= (unsigned int )((int )*(frame + (width * ((6 - i) + (i < 1)) + 8)) & 1);
    if (decode & 1U) {
      b1 ++;
    }
    i ++;
  }
  if (decode != format) {
    printf((char const   * __restrict  )"Upper-left format information is invalid.\n");
    printf((char const   * __restrict  )"%08x, %08x\n", format, decode);
    testEnd(1);
    return;
  }
  decode = 0U;
  i = 0;
  while (i < 7) {
    decode <<= 1;
    decode |= (unsigned int )((int )*(frame + (width * ((width - 1) - i) + 8)) & 1);
    if (decode & 1U) {
      b1 ++;
    }
    i ++;
  }
  i = 0;
  while (i < 8) {
    decode <<= 1;
    decode |= (unsigned int )((int )*(frame + (((width * 8 + width) - 8) + i)) & 1);
    if (decode & 1U) {
      b1 ++;
    }
    i ++;
  }
  if (decode != format) {
    printf((char const   * __restrict  )"Bottom and right format information is invalid.\n");
    printf((char const   * __restrict  )"%08x, %08x\n", format, decode);
    testEnd(1);
    return;
  }
  if (b2 != blacks) {
    printf((char const   * __restrict  )"Number of dark modules is incorrect.\n");
    printf((char const   * __restrict  )"Return value: %d, dark modules in frame: %d, should be: %d\n",
           blacks, b1, b2);
    testEnd(1);
    return;
  } else
  if (b1 != b2) {
    printf((char const   * __restrict  )"Number of dark modules is incorrect.\n");
    printf((char const   * __restrict  )"Return value: %d, dark modules in frame: %d, should be: %d\n",
           blacks, b1, b2);
    testEnd(1);
    return;
  }
  free((void *)frame);
  ABORT: 
  testEnd(0);
  return;
}
}
unsigned int m1pat[8][21]  = 
  { {        2082687U,        1072193U,        1526877U,        1526621U, 
            1530717U,        1065537U,        2086271U,        0U, 
            1393938U,        1709730U,        227054U,        1682354U, 
            323297U,        5186U,        2081041U,        1066059U, 
            1531229U,        1526446U,        1530597U,        1065912U, 
            2085605U}, 
   {        2088319U,        1066561U,        1529437U,        1524061U, 
            1524061U,        1071169U,        2086271U,        2560U, 
            1339173U,        1096712U,        646212U,        1245464U, 
            934987U,        7912U,        2087867U,        1068769U, 
            1525751U,        1523716U,        1527887U,        1067282U, 
            2086991U}, 
   {        2083711U,        1068865U,        1527901U,        1529949U, 
            1529693U,        1069377U,        2086271U,        4864U, 
            1558908U,        177452U,        289439U,        67644U, 
            258704U,        6092U,        2084192U,        1071045U, 
            1528108U,        1530144U,        1529492U,        1065014U, 
            2088596U}, 
   {        2087807U,        1070145U,        1527133U,        1529949U, 
            1526877U,        1068097U,        2086271U,        6144U, 
            1500235U,        177452U,        1241586U,        1713546U, 
            258704U,        7329U,        2085078U,        1071045U, 
            1526337U,        1528982U,        1529492U,        1067867U, 
            2085666U}, 
   {        2085759U,        1066817U,        1525597U,        1531741U, 
            1531741U,        1071425U,        2086271U,        5120U, 
            1143289U,        822735U,        1437059U,        1085216U, 
            903795U,        7983U,        2087548U,        1065177U, 
            1530319U,        1524163U,        1524104U,        1066794U, 
            2086519U}, 
   {        2084223U,        1070913U,        1527901U,        1528925U, 
            1525597U,        1067329U,        2086271U,        6912U, 
            1071566U,        371037U,        289439U,        196636U, 
            934987U,        8172U,        2084192U,        1067956U, 
            1524012U,        1523968U,        1523791U,        1067030U, 
            2088596U}, 
   {        2088319U,        1070913U,        1528925U,        1524829U, 
            1529181U,        1068865U,        2086271U,        2816U, 
            1310103U,        371037U,        63702U,        165380U, 
            934987U,        7983U,        2087410U,        1072052U, 
            1528677U,        1529624U,        1523791U,        1067221U, 
            2087430U}, 
   {        2082687U,        1067073U,        1527389U,        1526621U, 
            1527645U,        1069121U,        2086271U,        1024U, 
            1234848U,        1709730U,        676476U,        1915387U, 
            323297U,        4304U,        2081624U,        1070155U, 
            1526223U,        1530087U,        1526501U,        1066794U, 
            2085036U}};
static void test_encode(void) 
{ 
  QRinput *stream ;
  char num[9] ;
  unsigned char *frame ;
  int err ;
  int x ;
  int y ;
  int w ;
  int mask ;
  QRcode *qrcode ;

  {
  num[0] = (char )'0';
  num[1] = (char )'1';
  num[2] = (char )'2';
  num[3] = (char )'3';
  num[4] = (char )'4';
  num[5] = (char )'5';
  num[6] = (char )'6';
  num[7] = (char )'7';
  num[8] = (char )'\000';
  err = 0;
  testStartReal("test_encode", "Test encode (1-M)");
  stream = QRinput_new();
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
    goto ABORT;
  }
  QRinput_append(stream, (QRencodeMode )0, 8, (unsigned char const   *)((unsigned char *)(num)));
  mask = 0;
  while (mask < 8) {
    QRinput_setVersion(stream, 1);
    QRinput_setErrorCorrectionLevel(stream, (QRecLevel )1);
    qrcode = QRcode_encodeMask(stream, mask);
    if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
      goto ABORT;
    }
    w = qrcode->width;
    frame = qrcode->data;
    y = 0;
    while (y < w) {
      x = 0;
      while (x < w) {
        if (((m1pat[mask][y] >> (20 - x)) & 1U) != (unsigned int )((int )*(frame + (y * w + x)) & 1)) {
          printf((char const   * __restrict  )"Diff in mask=%d (%d,%d)\n", mask, x,
                 y);
          err ++;
        }
        x ++;
      }
      y ++;
    }
    QRcode_free(qrcode);
    mask ++;
  }
  QRinput_free(stream);
  ABORT: 
  testEnd(err);
  return;
}
}
static void test_encode2(void) 
{ 
  QRcode *qrcode ;

  {
  testStartReal("test_encode2", "Test encode (2-H) (no padding test)");
  qrcode = QRcode_encodeString("abcdefghijk123456789012", 0, (QRecLevel )3, (QRencodeMode )2,
                               0);
  testEnd(! (qrcode->version == 2));
  QRcode_free(qrcode);
  return;
}
}
static void test_encode3(void) 
{ 
  QRcode *code1 ;
  QRcode *code2 ;
  QRinput *input ;
  int tmp ;

  {
  testStartReal("test_encode3", "Compare encodeString and encodeInput");
  code1 = QRcode_encodeString("0123456", 0, (QRecLevel )0, (QRencodeMode )2, 0);
  input = QRinput_new2(0, (QRecLevel )0);
  QRinput_append(input, (QRencodeMode )0, 7, (unsigned char const   *)((unsigned char *)"0123456"));
  code2 = QRcode_encodeInput(input);
  tmp = memcmp((void const   *)code1->data, (void const   *)code2->data, (size_t )(code1->width * code1->width));
  testEnd(tmp);
  QRcode_free(code1);
  QRcode_free(code2);
  QRinput_free(input);
  return;
}
}
static void test_encodeNull(void) 
{ 
  QRcode *qrcode ;

  {
  testStartReal("test_encodeNull", "Test encode NULL.");
  qrcode = QRcode_encodeString((char const   *)((void *)0), 0, (QRecLevel )3, (QRencodeMode )2,
                               0);
  assertionNum ++;
  if (! ((unsigned long )qrcode == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRcode_encodeString() returned something.\n");
  }
  testFinish();
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  return;
}
}
static void test_encodeEmpty(void) 
{ 
  QRcode *qrcode ;

  {
  testStartReal("test_encodeEmpty", "Test encode an empty string.");
  qrcode = QRcode_encodeString("", 0, (QRecLevel )3, (QRencodeMode )2, 0);
  assertionNum ++;
  if (! ((unsigned long )qrcode == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRcode_encodeString() returned something.\n");
  }
  testFinish();
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  return;
}
}
static void test_encodeNull8(void) 
{ 
  QRcode *qrcode ;

  {
  testStartReal("test_encodeNull8", "Test encode NULL.");
  qrcode = QRcode_encodeString8bit((char const   *)((void *)0), 0, (QRecLevel )3);
  assertionNum ++;
  if (! ((unsigned long )qrcode == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRcode_encodeString8bit() returned something.\n");
  }
  testFinish();
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  return;
}
}
static void test_encodeEmpty8(void) 
{ 
  QRcode *qrcode ;

  {
  testStartReal("test_encodeEmpty8", "Test encode an empty string.");
  qrcode = QRcode_encodeString8bit("", 0, (QRecLevel )3);
  assertionNum ++;
  if (! ((unsigned long )qrcode == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRcode_encodeString8bit() returned something.\n");
  }
  testFinish();
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  return;
}
}
static void test_encodeLongData(void) 
{ 
  QRinput *stream ;
  unsigned char data[7090] ;
  int maxlength[4][4] ;
  int i ;
  int l ;
  int len ;
  int ret ;
  QRcode *qrcode ;

  {
  maxlength[0][0] = 7089;
  maxlength[0][1] = 5596;
  maxlength[0][2] = 3993;
  maxlength[0][3] = 3057;
  maxlength[1][0] = 4296;
  maxlength[1][1] = 3391;
  maxlength[1][2] = 2420;
  maxlength[1][3] = 1852;
  maxlength[2][0] = 2953;
  maxlength[2][1] = 2331;
  maxlength[2][2] = 1663;
  maxlength[2][3] = 1273;
  maxlength[3][0] = 3634;
  maxlength[3][1] = 2870;
  maxlength[3][2] = 2048;
  maxlength[3][3] = 1568;
  testStartReal("test_encodeLongData", "Encoding long data.");
  i = 0;
  while (i <= 3) {
    if (i != 3) {
      memset((void *)(data), '0', (size_t )(maxlength[i][0] + 1));
    } else {
      l = 0;
      while (l <= maxlength[i][0] / 2 + 1) {
        data[l * 2] = (unsigned char)147;
        data[l * 2 + 1] = (unsigned char)95;
        l ++;
      }
    }
    l = 0;
    while (l <= 3) {
      stream = QRinput_new2(0, (QRecLevel )l);
      ret = QRinput_append(stream, (QRencodeMode )i, maxlength[i][l], (unsigned char const   *)(data));
      assertionNum ++;
      if (! (ret == 0)) {
        assertionFailed ++;
        printf((char const   * __restrict  )"Failed to add %d-byte %s to a QRinput\n",
               maxlength[i][l], modeStr[i]);
      }
      qrcode = QRcode_encodeInput(stream);
      assertionNum ++;
      if (! ((unsigned long )qrcode != (unsigned long )((void *)0))) {
        assertionFailed ++;
        printf((char const   * __restrict  )"(QRcode_encodeInput) failed to encode %d-byte %s in level %d.\n",
               maxlength[i][l], modeStr[i], l);
      }
      if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
        QRcode_free(qrcode);
      }
      QRinput_free(stream);
      stream = QRinput_new2(0, (QRecLevel )l);
      len = maxlength[i][l];
      if (i == 3) {
        len += 2;
      } else {
        len ++;
      }
      ret = QRinput_append(stream, (QRencodeMode )i, len, (unsigned char const   *)(data));
      if (ret == 0) {
        qrcode = QRcode_encodeInput(stream);
        assertionNum ++;
        if (! ((unsigned long )qrcode == (unsigned long )((void *)0))) {
          assertionFailed ++;
          printf((char const   * __restrict  )"(QRcode_encodeInput) incorrectly succeeded to encode %d-byte %s in level %d.\n",
                 len, modeStr[i], l);
        }
        if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
          printf((char const   * __restrict  )"version: %d\n", qrcode->version);
          QRcode_free(qrcode);
        }
      }
      QRinput_free(stream);
      l ++;
    }
    i ++;
  }
  testFinish();
  return;
}
}
static void test_encodeVer26Num(void) 
{ 
  char data[3284] ;
  QRcode *qrcode ;
  QRinput *input ;
  QRinput_List *list ;

  {
  testStartReal("test_encodeVer26Num", "Encoding 3283 digits number. (issue #160)");
  memset((void *)(data), '0', (size_t )3283);
  data[3283] = (char )'\000';
  qrcode = QRcode_encodeString((char const   *)(data), 0, (QRecLevel )0, (QRencodeMode )2,
                               0);
  assertionNum ++;
  if (! ((unsigned long )qrcode != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"(QRcode_encodeString) failed to encode 3283 digits number in level L.\n");
  }
  assertionNum ++;
  if (! (qrcode->version == 26)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"version number is %d (26 expected)\n", qrcode->version);
  }
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  input = QRinput_new2(0, (QRecLevel )0);
  Split_splitStringToQRinput((char const   *)(data), input, (QRencodeMode )2, 0);
  list = input->head;
  assertionNum ++;
  if (! (list->size == 3283)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"chunk size is wrong. (%d, 3283 expected)\n",
           list->size);
  }
  QRinput_free(input);
  testFinish();
  return;
}
}
static void test_01234567(void) 
{ 
  QRinput *stream ;
  char num[9] ;
  int i ;
  int err ;
  QRcode *qrcode ;
  unsigned char correct[441] ;

  {
  num[0] = (char )'0';
  num[1] = (char )'1';
  num[2] = (char )'2';
  num[3] = (char )'3';
  num[4] = (char )'4';
  num[5] = (char )'5';
  num[6] = (char )'6';
  num[7] = (char )'7';
  num[8] = (char )'\000';
  err = 0;
  correct[0] = (unsigned char)193;
  correct[1] = (unsigned char)193;
  correct[2] = (unsigned char)193;
  correct[3] = (unsigned char)193;
  correct[4] = (unsigned char)193;
  correct[5] = (unsigned char)193;
  correct[6] = (unsigned char)193;
  correct[7] = (unsigned char)192;
  correct[8] = (unsigned char)132;
  correct[9] = (unsigned char)3;
  correct[10] = (unsigned char)2;
  correct[11] = (unsigned char)3;
  correct[12] = (unsigned char)3;
  correct[13] = (unsigned char)192;
  correct[14] = (unsigned char)193;
  correct[15] = (unsigned char)193;
  correct[16] = (unsigned char)193;
  correct[17] = (unsigned char)193;
  correct[18] = (unsigned char)193;
  correct[19] = (unsigned char)193;
  correct[20] = (unsigned char)193;
  correct[21] = (unsigned char)193;
  correct[22] = (unsigned char)192;
  correct[23] = (unsigned char)192;
  correct[24] = (unsigned char)192;
  correct[25] = (unsigned char)192;
  correct[26] = (unsigned char)192;
  correct[27] = (unsigned char)193;
  correct[28] = (unsigned char)192;
  correct[29] = (unsigned char)132;
  correct[30] = (unsigned char)3;
  correct[31] = (unsigned char)3;
  correct[32] = (unsigned char)3;
  correct[33] = (unsigned char)3;
  correct[34] = (unsigned char)192;
  correct[35] = (unsigned char)193;
  correct[36] = (unsigned char)192;
  correct[37] = (unsigned char)192;
  correct[38] = (unsigned char)192;
  correct[39] = (unsigned char)192;
  correct[40] = (unsigned char)192;
  correct[41] = (unsigned char)193;
  correct[42] = (unsigned char)193;
  correct[43] = (unsigned char)192;
  correct[44] = (unsigned char)193;
  correct[45] = (unsigned char)193;
  correct[46] = (unsigned char)193;
  correct[47] = (unsigned char)192;
  correct[48] = (unsigned char)193;
  correct[49] = (unsigned char)192;
  correct[50] = (unsigned char)133;
  correct[51] = (unsigned char)2;
  correct[52] = (unsigned char)2;
  correct[53] = (unsigned char)2;
  correct[54] = (unsigned char)2;
  correct[55] = (unsigned char)192;
  correct[56] = (unsigned char)193;
  correct[57] = (unsigned char)192;
  correct[58] = (unsigned char)193;
  correct[59] = (unsigned char)193;
  correct[60] = (unsigned char)193;
  correct[61] = (unsigned char)192;
  correct[62] = (unsigned char)193;
  correct[63] = (unsigned char)193;
  correct[64] = (unsigned char)192;
  correct[65] = (unsigned char)193;
  correct[66] = (unsigned char)193;
  correct[67] = (unsigned char)193;
  correct[68] = (unsigned char)192;
  correct[69] = (unsigned char)193;
  correct[70] = (unsigned char)192;
  correct[71] = (unsigned char)133;
  correct[72] = (unsigned char)3;
  correct[73] = (unsigned char)2;
  correct[74] = (unsigned char)2;
  correct[75] = (unsigned char)2;
  correct[76] = (unsigned char)192;
  correct[77] = (unsigned char)193;
  correct[78] = (unsigned char)192;
  correct[79] = (unsigned char)193;
  correct[80] = (unsigned char)193;
  correct[81] = (unsigned char)193;
  correct[82] = (unsigned char)192;
  correct[83] = (unsigned char)193;
  correct[84] = (unsigned char)193;
  correct[85] = (unsigned char)192;
  correct[86] = (unsigned char)193;
  correct[87] = (unsigned char)193;
  correct[88] = (unsigned char)193;
  correct[89] = (unsigned char)192;
  correct[90] = (unsigned char)193;
  correct[91] = (unsigned char)192;
  correct[92] = (unsigned char)133;
  correct[93] = (unsigned char)2;
  correct[94] = (unsigned char)3;
  correct[95] = (unsigned char)1;
  correct[96] = (unsigned char)1;
  correct[97] = (unsigned char)192;
  correct[98] = (unsigned char)193;
  correct[99] = (unsigned char)192;
  correct[100] = (unsigned char)193;
  correct[101] = (unsigned char)193;
  correct[102] = (unsigned char)193;
  correct[103] = (unsigned char)192;
  correct[104] = (unsigned char)193;
  correct[105] = (unsigned char)193;
  correct[106] = (unsigned char)192;
  correct[107] = (unsigned char)192;
  correct[108] = (unsigned char)192;
  correct[109] = (unsigned char)192;
  correct[110] = (unsigned char)192;
  correct[111] = (unsigned char)193;
  correct[112] = (unsigned char)192;
  correct[113] = (unsigned char)133;
  correct[114] = (unsigned char)2;
  correct[115] = (unsigned char)2;
  correct[116] = (unsigned char)0;
  correct[117] = (unsigned char)1;
  correct[118] = (unsigned char)192;
  correct[119] = (unsigned char)193;
  correct[120] = (unsigned char)192;
  correct[121] = (unsigned char)192;
  correct[122] = (unsigned char)192;
  correct[123] = (unsigned char)192;
  correct[124] = (unsigned char)192;
  correct[125] = (unsigned char)193;
  correct[126] = (unsigned char)193;
  correct[127] = (unsigned char)193;
  correct[128] = (unsigned char)193;
  correct[129] = (unsigned char)193;
  correct[130] = (unsigned char)193;
  correct[131] = (unsigned char)193;
  correct[132] = (unsigned char)193;
  correct[133] = (unsigned char)192;
  correct[134] = (unsigned char)145;
  correct[135] = (unsigned char)144;
  correct[136] = (unsigned char)145;
  correct[137] = (unsigned char)144;
  correct[138] = (unsigned char)145;
  correct[139] = (unsigned char)192;
  correct[140] = (unsigned char)193;
  correct[141] = (unsigned char)193;
  correct[142] = (unsigned char)193;
  correct[143] = (unsigned char)193;
  correct[144] = (unsigned char)193;
  correct[145] = (unsigned char)193;
  correct[146] = (unsigned char)193;
  correct[147] = (unsigned char)192;
  correct[148] = (unsigned char)192;
  correct[149] = (unsigned char)192;
  correct[150] = (unsigned char)192;
  correct[151] = (unsigned char)192;
  correct[152] = (unsigned char)192;
  correct[153] = (unsigned char)192;
  correct[154] = (unsigned char)192;
  correct[155] = (unsigned char)133;
  correct[156] = (unsigned char)2;
  correct[157] = (unsigned char)2;
  correct[158] = (unsigned char)1;
  correct[159] = (unsigned char)1;
  correct[160] = (unsigned char)192;
  correct[161] = (unsigned char)192;
  correct[162] = (unsigned char)192;
  correct[163] = (unsigned char)192;
  correct[164] = (unsigned char)192;
  correct[165] = (unsigned char)192;
  correct[166] = (unsigned char)192;
  correct[167] = (unsigned char)192;
  correct[168] = (unsigned char)133;
  correct[169] = (unsigned char)132;
  correct[170] = (unsigned char)133;
  correct[171] = (unsigned char)133;
  correct[172] = (unsigned char)133;
  correct[173] = (unsigned char)133;
  correct[174] = (unsigned char)145;
  correct[175] = (unsigned char)132;
  correct[176] = (unsigned char)132;
  correct[177] = (unsigned char)3;
  correct[178] = (unsigned char)2;
  correct[179] = (unsigned char)0;
  correct[180] = (unsigned char)1;
  correct[181] = (unsigned char)132;
  correct[182] = (unsigned char)133;
  correct[183] = (unsigned char)133;
  correct[184] = (unsigned char)133;
  correct[185] = (unsigned char)133;
  correct[186] = (unsigned char)133;
  correct[187] = (unsigned char)132;
  correct[188] = (unsigned char)132;
  correct[189] = (unsigned char)2;
  correct[190] = (unsigned char)2;
  correct[191] = (unsigned char)2;
  correct[192] = (unsigned char)3;
  correct[193] = (unsigned char)2;
  correct[194] = (unsigned char)3;
  correct[195] = (unsigned char)144;
  correct[196] = (unsigned char)3;
  correct[197] = (unsigned char)3;
  correct[198] = (unsigned char)2;
  correct[199] = (unsigned char)3;
  correct[200] = (unsigned char)0;
  correct[201] = (unsigned char)1;
  correct[202] = (unsigned char)0;
  correct[203] = (unsigned char)0;
  correct[204] = (unsigned char)1;
  correct[205] = (unsigned char)0;
  correct[206] = (unsigned char)1;
  correct[207] = (unsigned char)1;
  correct[208] = (unsigned char)0;
  correct[209] = (unsigned char)0;
  correct[210] = (unsigned char)2;
  correct[211] = (unsigned char)2;
  correct[212] = (unsigned char)3;
  correct[213] = (unsigned char)2;
  correct[214] = (unsigned char)2;
  correct[215] = (unsigned char)2;
  correct[216] = (unsigned char)145;
  correct[217] = (unsigned char)3;
  correct[218] = (unsigned char)2;
  correct[219] = (unsigned char)3;
  correct[220] = (unsigned char)2;
  correct[221] = (unsigned char)1;
  correct[222] = (unsigned char)0;
  correct[223] = (unsigned char)1;
  correct[224] = (unsigned char)0;
  correct[225] = (unsigned char)0;
  correct[226] = (unsigned char)1;
  correct[227] = (unsigned char)1;
  correct[228] = (unsigned char)1;
  correct[229] = (unsigned char)1;
  correct[230] = (unsigned char)1;
  correct[231] = (unsigned char)2;
  correct[232] = (unsigned char)2;
  correct[233] = (unsigned char)2;
  correct[234] = (unsigned char)2;
  correct[235] = (unsigned char)3;
  correct[236] = (unsigned char)2;
  correct[237] = (unsigned char)144;
  correct[238] = (unsigned char)2;
  correct[239] = (unsigned char)2;
  correct[240] = (unsigned char)3;
  correct[241] = (unsigned char)2;
  correct[242] = (unsigned char)0;
  correct[243] = (unsigned char)0;
  correct[244] = (unsigned char)0;
  correct[245] = (unsigned char)0;
  correct[246] = (unsigned char)1;
  correct[247] = (unsigned char)1;
  correct[248] = (unsigned char)1;
  correct[249] = (unsigned char)1;
  correct[250] = (unsigned char)0;
  correct[251] = (unsigned char)0;
  correct[252] = (unsigned char)2;
  correct[253] = (unsigned char)2;
  correct[254] = (unsigned char)2;
  correct[255] = (unsigned char)3;
  correct[256] = (unsigned char)3;
  correct[257] = (unsigned char)3;
  correct[258] = (unsigned char)145;
  correct[259] = (unsigned char)3;
  correct[260] = (unsigned char)3;
  correct[261] = (unsigned char)2;
  correct[262] = (unsigned char)2;
  correct[263] = (unsigned char)1;
  correct[264] = (unsigned char)0;
  correct[265] = (unsigned char)1;
  correct[266] = (unsigned char)0;
  correct[267] = (unsigned char)0;
  correct[268] = (unsigned char)1;
  correct[269] = (unsigned char)0;
  correct[270] = (unsigned char)0;
  correct[271] = (unsigned char)0;
  correct[272] = (unsigned char)0;
  correct[273] = (unsigned char)192;
  correct[274] = (unsigned char)192;
  correct[275] = (unsigned char)192;
  correct[276] = (unsigned char)192;
  correct[277] = (unsigned char)192;
  correct[278] = (unsigned char)192;
  correct[279] = (unsigned char)192;
  correct[280] = (unsigned char)192;
  correct[281] = (unsigned char)129;
  correct[282] = (unsigned char)2;
  correct[283] = (unsigned char)3;
  correct[284] = (unsigned char)1;
  correct[285] = (unsigned char)1;
  correct[286] = (unsigned char)1;
  correct[287] = (unsigned char)1;
  correct[288] = (unsigned char)0;
  correct[289] = (unsigned char)0;
  correct[290] = (unsigned char)1;
  correct[291] = (unsigned char)1;
  correct[292] = (unsigned char)0;
  correct[293] = (unsigned char)0;
  correct[294] = (unsigned char)193;
  correct[295] = (unsigned char)193;
  correct[296] = (unsigned char)193;
  correct[297] = (unsigned char)193;
  correct[298] = (unsigned char)193;
  correct[299] = (unsigned char)193;
  correct[300] = (unsigned char)193;
  correct[301] = (unsigned char)192;
  correct[302] = (unsigned char)132;
  correct[303] = (unsigned char)3;
  correct[304] = (unsigned char)3;
  correct[305] = (unsigned char)0;
  correct[306] = (unsigned char)1;
  correct[307] = (unsigned char)0;
  correct[308] = (unsigned char)1;
  correct[309] = (unsigned char)1;
  correct[310] = (unsigned char)0;
  correct[311] = (unsigned char)0;
  correct[312] = (unsigned char)0;
  correct[313] = (unsigned char)0;
  correct[314] = (unsigned char)0;
  correct[315] = (unsigned char)193;
  correct[316] = (unsigned char)192;
  correct[317] = (unsigned char)192;
  correct[318] = (unsigned char)192;
  correct[319] = (unsigned char)192;
  correct[320] = (unsigned char)192;
  correct[321] = (unsigned char)193;
  correct[322] = (unsigned char)192;
  correct[323] = (unsigned char)133;
  correct[324] = (unsigned char)2;
  correct[325] = (unsigned char)3;
  correct[326] = (unsigned char)1;
  correct[327] = (unsigned char)1;
  correct[328] = (unsigned char)1;
  correct[329] = (unsigned char)1;
  correct[330] = (unsigned char)0;
  correct[331] = (unsigned char)0;
  correct[332] = (unsigned char)0;
  correct[333] = (unsigned char)1;
  correct[334] = (unsigned char)0;
  correct[335] = (unsigned char)1;
  correct[336] = (unsigned char)193;
  correct[337] = (unsigned char)192;
  correct[338] = (unsigned char)193;
  correct[339] = (unsigned char)193;
  correct[340] = (unsigned char)193;
  correct[341] = (unsigned char)192;
  correct[342] = (unsigned char)193;
  correct[343] = (unsigned char)192;
  correct[344] = (unsigned char)133;
  correct[345] = (unsigned char)2;
  correct[346] = (unsigned char)2;
  correct[347] = (unsigned char)0;
  correct[348] = (unsigned char)1;
  correct[349] = (unsigned char)0;
  correct[350] = (unsigned char)0;
  correct[351] = (unsigned char)1;
  correct[352] = (unsigned char)0;
  correct[353] = (unsigned char)1;
  correct[354] = (unsigned char)1;
  correct[355] = (unsigned char)0;
  correct[356] = (unsigned char)0;
  correct[357] = (unsigned char)193;
  correct[358] = (unsigned char)192;
  correct[359] = (unsigned char)193;
  correct[360] = (unsigned char)193;
  correct[361] = (unsigned char)193;
  correct[362] = (unsigned char)192;
  correct[363] = (unsigned char)193;
  correct[364] = (unsigned char)192;
  correct[365] = (unsigned char)133;
  correct[366] = (unsigned char)3;
  correct[367] = (unsigned char)2;
  correct[368] = (unsigned char)0;
  correct[369] = (unsigned char)1;
  correct[370] = (unsigned char)0;
  correct[371] = (unsigned char)0;
  correct[372] = (unsigned char)1;
  correct[373] = (unsigned char)0;
  correct[374] = (unsigned char)0;
  correct[375] = (unsigned char)0;
  correct[376] = (unsigned char)0;
  correct[377] = (unsigned char)0;
  correct[378] = (unsigned char)193;
  correct[379] = (unsigned char)192;
  correct[380] = (unsigned char)193;
  correct[381] = (unsigned char)193;
  correct[382] = (unsigned char)193;
  correct[383] = (unsigned char)192;
  correct[384] = (unsigned char)193;
  correct[385] = (unsigned char)192;
  correct[386] = (unsigned char)133;
  correct[387] = (unsigned char)2;
  correct[388] = (unsigned char)3;
  correct[389] = (unsigned char)1;
  correct[390] = (unsigned char)0;
  correct[391] = (unsigned char)1;
  correct[392] = (unsigned char)0;
  correct[393] = (unsigned char)0;
  correct[394] = (unsigned char)1;
  correct[395] = (unsigned char)0;
  correct[396] = (unsigned char)1;
  correct[397] = (unsigned char)0;
  correct[398] = (unsigned char)0;
  correct[399] = (unsigned char)193;
  correct[400] = (unsigned char)192;
  correct[401] = (unsigned char)192;
  correct[402] = (unsigned char)192;
  correct[403] = (unsigned char)192;
  correct[404] = (unsigned char)192;
  correct[405] = (unsigned char)193;
  correct[406] = (unsigned char)192;
  correct[407] = (unsigned char)132;
  correct[408] = (unsigned char)2;
  correct[409] = (unsigned char)2;
  correct[410] = (unsigned char)0;
  correct[411] = (unsigned char)0;
  correct[412] = (unsigned char)0;
  correct[413] = (unsigned char)0;
  correct[414] = (unsigned char)1;
  correct[415] = (unsigned char)1;
  correct[416] = (unsigned char)0;
  correct[417] = (unsigned char)1;
  correct[418] = (unsigned char)1;
  correct[419] = (unsigned char)0;
  correct[420] = (unsigned char)193;
  correct[421] = (unsigned char)193;
  correct[422] = (unsigned char)193;
  correct[423] = (unsigned char)193;
  correct[424] = (unsigned char)193;
  correct[425] = (unsigned char)193;
  correct[426] = (unsigned char)193;
  correct[427] = (unsigned char)192;
  correct[428] = (unsigned char)133;
  correct[429] = (unsigned char)3;
  correct[430] = (unsigned char)3;
  correct[431] = (unsigned char)1;
  correct[432] = (unsigned char)0;
  correct[433] = (unsigned char)1;
  correct[434] = (unsigned char)0;
  correct[435] = (unsigned char)0;
  correct[436] = (unsigned char)1;
  correct[437] = (unsigned char)0;
  correct[438] = (unsigned char)1;
  correct[439] = (unsigned char)0;
  correct[440] = (unsigned char)0;
  testStartReal("test_01234567", "Encode 01234567 in 1-M");
  stream = QRinput_new2(1, (QRecLevel )1);
  QRinput_append(stream, (QRencodeMode )0, 8, (unsigned char const   *)((unsigned char *)(num)));
  qrcode = QRcode_encodeInput(stream);
  i = 0;
  while (i < qrcode->width * qrcode->width) {
    if ((int )*(qrcode->data + i) != (int )correct[i]) {
      err ++;
    }
    i ++;
  }
  testEnd(err);
  QRinput_free(stream);
  QRcode_free(qrcode);
  return;
}
}
static void print_01234567(void) 
{ 
  QRinput *stream ;
  char num[9] ;
  QRcode *qrcode ;

  {
  num[0] = (char )'0';
  num[1] = (char )'1';
  num[2] = (char )'2';
  num[3] = (char )'3';
  num[4] = (char )'4';
  num[5] = (char )'5';
  num[6] = (char )'6';
  num[7] = (char )'7';
  num[8] = (char )'\000';
  puts("\nPrinting QR code of \'01234567\'.");
  stream = QRinput_new2(1, (QRecLevel )1);
  QRinput_append(stream, (QRencodeMode )0, 8, (unsigned char const   *)((unsigned char *)(num)));
  qrcode = QRcode_encodeInput(stream);
  printQRcode(qrcode);
  QRinput_free(stream);
  QRcode_free(qrcode);
  return;
}
}
static void test_invalid_input(void) 
{ 
  QRinput *input ;
  QRcode *code ;

  {
  testStartReal("test_invalid_input", "Testing invalid input.");
  input = QRinput_new();
  QRinput_append(input, (QRencodeMode )1, 5, (unsigned char const   *)((unsigned char *)"TEST1"));
  input->version = -1;
  input->level = (QRecLevel )0;
  code = QRcode_encodeInput(input);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"invalid version(-1)  was not checked.\n");
  }
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    QRcode_free(code);
  }
  input->version = 41;
  input->level = (QRecLevel )0;
  code = QRcode_encodeInput(input);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"invalid version(41) access was not checked.\n");
  }
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    QRcode_free(code);
  }
  input->version = 1;
  input->level = (QRecLevel )4;
  code = QRcode_encodeInput(input);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"invalid level(H+1) access was not checked.\n");
  }
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    QRcode_free(code);
  }
  input->version = 1;
  input->level = (QRecLevel )-1;
  code = QRcode_encodeInput(input);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"invalid level(-1) access was not checked.\n");
  }
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    QRcode_free(code);
  }
  QRinput_free(input);
  testFinish();
  return;
}
}
static void test_struct_semilong(void) 
{ 
  QRcode_List *codes ;
  QRcode_List *list ;
  char const   *str ;
  int num ;
  int size ;

  {
  str = "asdfasdfasdfasdfasdfASDFASDASDFASDFAsdfasdfasdfasdASDFASDFADSADadsfasdf";
  testStartReal("test_struct_semilong", "Testing semi-long structured-append symbols");
  codes = QRcode_encodeString8bitStructured(str, 1, (QRecLevel )0);
  list = codes;
  num = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    num ++;
    assertionNum ++;
    if (! ((list->code)->version == 1)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"version number is %d (1 expected)\n", (list->code)->version);
    }
    list = list->next;
  }
  size = QRcode_List_size(codes);
  assertionNum ++;
  if (! (num == size)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRcode_List_size returns wrong size?");
  }
  QRcode_List_free(codes);
  codes = QRcode_encodeStringStructured(str, 1, (QRecLevel )0, (QRencodeMode )2, 1);
  list = codes;
  num = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    num ++;
    assertionNum ++;
    if (! ((list->code)->version == 1)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"version number is %d (1 expected)\n", (list->code)->version);
    }
    list = list->next;
  }
  size = QRcode_List_size(codes);
  assertionNum ++;
  if (! (num == size)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRcode_List_size returns wrong size?");
  }
  QRcode_List_free(codes);
  testFinish();
  return;
}
}
static void test_struct_example(void) 
{ 
  QRcode_List *codes ;
  QRcode_List *list ;
  char const   *str ;
  int num ;

  {
  str = "an example of four Structured Append symbols,";
  testStartReal("test_struct_example", "Testing the example of structured-append symbols");
  codes = QRcode_encodeString8bitStructured(str, 1, (QRecLevel )1);
  list = codes;
  num = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    num ++;
    assertionNum ++;
    if (! ((list->code)->version == 1)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"version number is %d (1 expected)\n", (list->code)->version);
    }
    list = list->next;
  }
  assertionNum ++;
  if (! (num == 4)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"number of symbols is %d (4 expected).", num);
  }
  testFinish();
  QRcode_List_free(codes);
  return;
}
}
static void test_null_free(void) 
{ 


  {
  testStartReal("test_null_free", "Testing free NULL pointers");
  printf((char const   * __restrict  )"Check QRcode_free(NULL).\n");
  QRcode_free((QRcode *)((void *)0));
  printf((char const   * __restrict  )"Check QRcode_List_free(NULL).\n");
  QRcode_List_free((QRcode_List *)((void *)0));
  printf((char const   * __restrict  )"Check QRraw_free(NULL).\n");
  QRraw_free((QRRawCode *)((void *)0));
  testFinish();
  return;
}
}
static void test_encodeTooLongMQR(void) 
{ 
  QRcode *code ;
  char *data[4] ;
  int *tmp ;

  {
  data[0] = (char *)"012345";
  data[1] = (char *)"ABC0EFG";
  data[2] = (char *)"0123456789";
  data[3] = (char *)"0123456789ABCDEFG";
  testStartReal("test_encodeTooLongMQR", "Encode too large data for MQR.");
  code = QRcode_encodeStringMQR((char const   *)data[0], 1, (QRecLevel )0, (QRencodeMode )2,
                                0);
  assertionNum ++;
  if (! ((unsigned long )code != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"6 byte length numeric string should be accepted to version 2 or larger.\n");
  }
  assertionNum ++;
  if (! (code->version == 2)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"6 byte length numeric string should be accepted to version 2.\n");
  }
  code = QRcode_encodeStringMQR((char const   *)data[1], 2, (QRecLevel )0, (QRencodeMode )2,
                                0);
  assertionNum ++;
  if (! ((unsigned long )code != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"7 byte length alphanumeric string should be accepted to version 3 or larger.\n");
  }
  assertionNum ++;
  if (! (code->version == 3)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"7 byte length alphanumeric string should be accepted to version 3.\n");
  }
  code = QRcode_encodeString8bitMQR((char const   *)data[2], 3, (QRecLevel )0);
  assertionNum ++;
  if (! ((unsigned long )code != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"9 byte length 8bit string should be accepted to version 4.\n");
  }
  assertionNum ++;
  if (! (code->version == 4)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"9 byte length 8bit string should be accepted to version 4.\n");
  }
  code = QRcode_encodeString8bitMQR((char const   *)data[3], 4, (QRecLevel )0);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"16 byte length 8bit string was accepted to version 4.\n");
  }
  assertionNum ++;
  tmp = __errno_location();
  if (! (*tmp == 34)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"errno != ERANGE\n");
  }
  testFinish();
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    printQRcode(code);
    QRcode_free(code);
  }
  return;
}
}
static void test_mqrraw_new(void) 
{ 
  QRinput *stream ;
  char *num ;
  unsigned char datacode[3] ;
  MQRRawCode *raw ;
  int tmp ;

  {
  num = (char *)"01234";
  datacode[0] = (unsigned char)160;
  datacode[1] = (unsigned char)98;
  datacode[2] = (unsigned char)32;
  testStartReal("test_mqrraw_new", "Test MQRRaw_new()");
  stream = QRinput_newMQR(1, (QRecLevel )0);
  QRinput_append(stream, (QRencodeMode )0, 5, (unsigned char const   *)((unsigned char *)num));
  raw = MQRraw_new(stream);
  assertionNum ++;
  if (! ((unsigned long )raw != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Failed MQRraw_new().\n");
  }
  assertionNum ++;
  if (! (raw->count == 0)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"MQRraw.count = %d != 0\n", raw->count);
  }
  assertionNum ++;
  if (! (raw->version == 1)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"MQRraw.version was not as expected. (%d)\n",
           raw->version);
  }
  assertionNum ++;
  if (! (raw->dataLength == 3)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"MQRraw.dataLength was not as expected.\n");
  }
  assertionNum ++;
  if (! (raw->eccLength == 2)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"MQRraw.eccLength was not as expected.\n");
  }
  assertionNum ++;
  tmp = memcmp((void const   *)raw->datacode, (void const   *)(datacode), (size_t )3);
  if (! (tmp == 0)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Datacode doesn\'t match.\n");
  }
  QRinput_free(stream);
  MQRraw_free(raw);
  testFinish();
  return;
}
}
static void test_encodeData(void) 
{ 
  QRcode *qrcode ;

  {
  testStartReal("test_encodeData", "Test QRencode_encodeData.");
  qrcode = QRcode_encodeData(0, (unsigned char const   *)((void *)0), 0, (QRecLevel )3);
  assertionNum ++;
  if (! ((unsigned long )qrcode == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRcode_encodeData(NULL, 0) returned something.\n");
  }
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  qrcode = QRcode_encodeData(10, (unsigned char const   *)((unsigned char *)"test\000\000test"),
                             0, (QRecLevel )3);
  assertionNum ++;
  if (! ((unsigned long )qrcode != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"QRcode_encodeData() failed.\n");
  }
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  testFinish();
  return;
}
}
static void test_formatInfo(void) 
{ 
  QRcode *qrcode ;
  QRecLevel level ;
  int mask ;
  int ret ;

  {
  testStartReal("test_formatInfo", "Test format info in QR code.");
  qrcode = QRcode_encodeString("AC-42", 1, (QRecLevel )3, (QRencodeMode )2, 1);
  ret = QRcode_decodeFormat(qrcode, & level, & mask);
  assertionNum ++;
  if (! (ret == 0)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Failed to decode.\n");
  }
  assertionNum ++;
  if (! ((unsigned int )level == 3U)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Decoded format is wrong.\n");
  }
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  testFinish();
  return;
}
}
static void test_formatInfoMQR(void) 
{ 
  QRcode *qrcode ;
  QRecLevel level ;
  int version ;
  int mask ;
  int i ;
  int ret ;

  {
  testStartReal("test_formatInfoMQR", "Test format info in Micro QR code.");
  i = 0;
  while (i < 8) {
    qrcode = QRcode_encodeStringMQR("1", MQRformat[i].version, MQRformat[i].level,
                                    (QRencodeMode )2, 1);
    ret = QRcode_decodeFormatMQR(qrcode, & version, & level, & mask);
    assertionNum ++;
    if (! (ret == 0)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Failed to decode.\n");
    }
    assertionNum ++;
    if (! (MQRformat[i].version == version)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Decoded verion is wrong.\n");
    }
    assertionNum ++;
    if (! ((unsigned int )MQRformat[i].level == (unsigned int )level)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Decoded level is wrong.\n");
    }
    QRcode_free(qrcode);
    i ++;
  }
  testFinish();
  return;
}
}
static void test_decodeSimple(void) 
{ 
  char *str ;
  QRcode *qrcode ;
  QRdata *qrdata ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  str = (char *)"AC-42";
  testStartReal("test_decodeSimple", "Test code words.");
  qrcode = QRcode_encodeString((char const   *)str, 1, (QRecLevel )3, (QRencodeMode )2,
                               1);
  qrdata = QRcode_decode(qrcode);
  assertionNum ++;
  if (! ((unsigned long )qrdata != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Failed to decode.\n");
  }
  if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
    assertionNum ++;
    tmp___0 = strlen((char const   *)str);
    if (! (tmp___0 == (size_t )qrdata->size)) {
      assertionFailed ++;
      tmp = strlen((char const   *)str);
      printf((char const   * __restrict  )"Lengths of input/output mismatched: %d, expected %d.\n",
             qrdata->size, (int )tmp);
    }
    assertionNum ++;
    tmp___1 = strncmp((char const   *)str, (char const   *)((char *)qrdata->data),
                      (size_t )qrdata->size);
    if (! (tmp___1 == 0)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Decoded data %s is different from the original %s\n",
             qrdata->data, str);
    }
  }
  if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
    QRdata_free(qrdata);
  }
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  testFinish();
  return;
}
}
static void test_decodeLong(void) 
{ 
  char *str ;
  QRcode *qrcode ;
  QRdata *qrdata ;
  size_t tmp ;
  int tmp___0 ;

  {
  str = (char *)"12345678901234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ?????????????";
  testStartReal("test_decodeLong", "Test code words (long, splitted).");
  qrcode = QRcode_encodeString((char const   *)str, 0, (QRecLevel )3, (QRencodeMode )2,
                               1);
  qrdata = QRcode_decode(qrcode);
  assertionNum ++;
  if (! ((unsigned long )qrdata != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Failed to decode.\n");
  }
  if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
    assertionNum ++;
    tmp = strlen((char const   *)str);
    if (! (tmp == (size_t )qrdata->size)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Lengths of input/output mismatched.\n");
    }
    assertionNum ++;
    tmp___0 = strncmp((char const   *)str, (char const   *)((char *)qrdata->data),
                      (size_t )qrdata->size);
    if (! (tmp___0 == 0)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Decoded data %s is different from the original %s\n",
             qrdata->data, str);
    }
  }
  if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
    QRdata_free(qrdata);
  }
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  testFinish();
  return;
}
}
static void test_decodeVeryLong(void) 
{ 
  char str[4000] ;
  int i ;
  QRcode *qrcode ;
  QRdata *qrdata ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  testStartReal("test_decodeVeryLong", "Test code words (very long string).");
  i = 0;
  while (i < 3999) {
    tmp = rand();
    str[i] = (char )decodeAnTable___0[(int )(((double )45 * (double )tmp) / ((double )2147483647 + 1.0))];
    i ++;
  }
  str[3999] = (char )'\000';
  qrcode = QRcode_encodeString((char const   *)(str), 0, (QRecLevel )0, (QRencodeMode )2,
                               0);
  qrdata = QRcode_decode(qrcode);
  assertionNum ++;
  if (! ((unsigned long )qrdata != (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Failed to decode.\n");
  }
  if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
    assertionNum ++;
    tmp___0 = strlen((char const   *)(str));
    if (! (tmp___0 == (size_t )qrdata->size)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Lengths of input/output mismatched.\n");
    }
    assertionNum ++;
    tmp___1 = strncmp((char const   *)(str), (char const   *)((char *)qrdata->data),
                      (size_t )qrdata->size);
    if (! (tmp___1 == 0)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Decoded data %s is different from the original %s\n",
             qrdata->data, str);
    }
  }
  if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
    QRdata_free(qrdata);
  }
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    QRcode_free(qrcode);
  }
  testFinish();
  return;
}
}
static void test_decodeShortMQR(void) 
{ 
  char str[3] ;
  QRcode *qrcode ;
  QRdata *qrdata ;
  int i ;
  int tmp ;

  {
  str[0] = (char )'5';
  str[1] = (char )'5';
  str[2] = (char )'\000';
  testStartReal("test_decodeShortMQR", "Test code words (MQR).");
  i = 0;
  while (i < 8) {
    qrcode = QRcode_encodeStringMQR((char const   *)(str), MQRformat[i].version, MQRformat[i].level,
                                    (QRencodeMode )2, 1);
    qrdata = QRcode_decodeMQR(qrcode);
    assertionNum ++;
    if (! ((unsigned long )qrdata != (unsigned long )((void *)0))) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Failed to decode.\n");
    }
    assertionNum ++;
    tmp = strcmp((char const   *)((char *)qrdata->data), (char const   *)(str));
    if (! (tmp == 0)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Decoded data (%s) mismatched (%s)\n", (char *)qrdata->data,
             str);
    }
    if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
      QRdata_free(qrdata);
    }
    if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
      QRcode_free(qrcode);
    }
    i ++;
  }
  testFinish();
  return;
}
}
static void test_oddBitCalcMQR(void) 
{ 
  TestString tests___0[2] ;
  QRcode *qrcode ;
  QRdata *qrdata ;
  int i ;
  int tmp ;

  {
  tests___0[0].str = (char *)"46194";
  tests___0[0].version = 1;
  tests___0[0].level = (QRecLevel )0;
  tests___0[0].hint = (QRencodeMode )2;
  tests___0[0].casesensitive = 1;
  tests___0[1].str = (char *)"WBA5Y47YPQQ";
  tests___0[1].version = 3;
  tests___0[1].level = (QRecLevel )0;
  tests___0[1].hint = (QRencodeMode )2;
  tests___0[1].casesensitive = 1;
  testStartReal("test_oddBitCalcMQR", "Odd bits calculation bug checking (MQR).");
  i = 0;
  while ((unsigned long )i < sizeof(tests___0) / sizeof(tests___0[0])) {
    qrcode = QRcode_encodeStringMQR((char const   *)tests___0[i].str, tests___0[i].version,
                                    tests___0[i].level, tests___0[i].hint, tests___0[i].casesensitive);
    assertionNum ++;
    if (! ((unsigned long )qrcode != (unsigned long )((void *)0))) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Failed to encode: %s\n", tests___0[i].str);
    }
    if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    qrdata = QRcode_decodeMQR(qrcode);
    assertionNum ++;
    if (! ((unsigned long )qrdata != (unsigned long )((void *)0))) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Failed to decode.\n");
    }
    assertionNum ++;
    tmp = strcmp((char const   *)((char *)qrdata->data), (char const   *)tests___0[i].str);
    if (! (tmp == 0)) {
      assertionFailed ++;
      printf((char const   * __restrict  )"Decoded data (%s) mismatched (%s)\n", (char *)qrdata->data,
             tests___0[i].str);
    }
    if ((unsigned long )qrdata != (unsigned long )((void *)0)) {
      QRdata_free(qrdata);
    }
    QRcode_free(qrcode);
    __Cont: /* CIL Label */ 
    i ++;
  }
  testFinish();
  return;
}
}
static void test_invalid_inputMQR(void) 
{ 
  QRinput *input ;
  QRcode *code ;

  {
  testStartReal("test_invalid_inputMQR", "Testing invalid input (MQR).");
  input = QRinput_newMQR(1, (QRecLevel )0);
  QRinput_append(input, (QRencodeMode )1, 5, (unsigned char const   *)((unsigned char *)"TEST1"));
  input->version = -1;
  input->level = (QRecLevel )0;
  code = QRcode_encodeInput(input);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"invalid version(-1)  was not checked.\n");
  }
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    QRcode_free(code);
  }
  input->version = 5;
  input->level = (QRecLevel )0;
  code = QRcode_encodeInput(input);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"invalid version(5) access was not checked.\n");
  }
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    QRcode_free(code);
  }
  input->version = 1;
  input->level = (QRecLevel )3;
  code = QRcode_encodeInput(input);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"invalid level(H) access was not checked.\n");
  }
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    QRcode_free(code);
  }
  input->version = 1;
  input->level = (QRecLevel )-1;
  code = QRcode_encodeInput(input);
  assertionNum ++;
  if (! ((unsigned long )code == (unsigned long )((void *)0))) {
    assertionFailed ++;
    printf((char const   * __restrict  )"invalid level(-1) access was not checked.\n");
  }
  if ((unsigned long )code != (unsigned long )((void *)0)) {
    QRcode_free(code);
  }
  QRinput_free(input);
  testFinish();
  return;
}
}
static void test_mqrencode(void) 
{ 
  char *str ;
  char pattern[226] ;
  QRcode qrcode ;
  QRdata *qrdata ;
  unsigned char *frame ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  str = (char *)"MICROQR";
  pattern[0] = (char )'#';
  pattern[1] = (char )'#';
  pattern[2] = (char )'#';
  pattern[3] = (char )'#';
  pattern[4] = (char )'#';
  pattern[5] = (char )'#';
  pattern[6] = (char )'#';
  pattern[7] = (char )'_';
  pattern[8] = (char )'#';
  pattern[9] = (char )'_';
  pattern[10] = (char )'#';
  pattern[11] = (char )'_';
  pattern[12] = (char )'#';
  pattern[13] = (char )'_';
  pattern[14] = (char )'#';
  pattern[15] = (char )'#';
  pattern[16] = (char )'_';
  pattern[17] = (char )'_';
  pattern[18] = (char )'_';
  pattern[19] = (char )'_';
  pattern[20] = (char )'_';
  pattern[21] = (char )'#';
  pattern[22] = (char )'_';
  pattern[23] = (char )'#';
  pattern[24] = (char )'_';
  pattern[25] = (char )'_';
  pattern[26] = (char )'#';
  pattern[27] = (char )'#';
  pattern[28] = (char )'#';
  pattern[29] = (char )'#';
  pattern[30] = (char )'#';
  pattern[31] = (char )'_';
  pattern[32] = (char )'#';
  pattern[33] = (char )'#';
  pattern[34] = (char )'#';
  pattern[35] = (char )'_';
  pattern[36] = (char )'#';
  pattern[37] = (char )'_';
  pattern[38] = (char )'#';
  pattern[39] = (char )'_';
  pattern[40] = (char )'#';
  pattern[41] = (char )'#';
  pattern[42] = (char )'#';
  pattern[43] = (char )'#';
  pattern[44] = (char )'_';
  pattern[45] = (char )'#';
  pattern[46] = (char )'_';
  pattern[47] = (char )'#';
  pattern[48] = (char )'#';
  pattern[49] = (char )'#';
  pattern[50] = (char )'_';
  pattern[51] = (char )'#';
  pattern[52] = (char )'_';
  pattern[53] = (char )'#';
  pattern[54] = (char )'_';
  pattern[55] = (char )'_';
  pattern[56] = (char )'#';
  pattern[57] = (char )'#';
  pattern[58] = (char )'_';
  pattern[59] = (char )'#';
  pattern[60] = (char )'#';
  pattern[61] = (char )'_';
  pattern[62] = (char )'#';
  pattern[63] = (char )'#';
  pattern[64] = (char )'#';
  pattern[65] = (char )'_';
  pattern[66] = (char )'#';
  pattern[67] = (char )'_';
  pattern[68] = (char )'_';
  pattern[69] = (char )'_';
  pattern[70] = (char )'#';
  pattern[71] = (char )'_';
  pattern[72] = (char )'_';
  pattern[73] = (char )'#';
  pattern[74] = (char )'#';
  pattern[75] = (char )'#';
  pattern[76] = (char )'_';
  pattern[77] = (char )'_';
  pattern[78] = (char )'_';
  pattern[79] = (char )'_';
  pattern[80] = (char )'_';
  pattern[81] = (char )'#';
  pattern[82] = (char )'_';
  pattern[83] = (char )'_';
  pattern[84] = (char )'_';
  pattern[85] = (char )'_';
  pattern[86] = (char )'#';
  pattern[87] = (char )'_';
  pattern[88] = (char )'#';
  pattern[89] = (char )'_';
  pattern[90] = (char )'#';
  pattern[91] = (char )'#';
  pattern[92] = (char )'#';
  pattern[93] = (char )'#';
  pattern[94] = (char )'#';
  pattern[95] = (char )'#';
  pattern[96] = (char )'#';
  pattern[97] = (char )'_';
  pattern[98] = (char )'_';
  pattern[99] = (char )'#';
  pattern[100] = (char )'#';
  pattern[101] = (char )'_';
  pattern[102] = (char )'#';
  pattern[103] = (char )'_';
  pattern[104] = (char )'#';
  pattern[105] = (char )'_';
  pattern[106] = (char )'_';
  pattern[107] = (char )'_';
  pattern[108] = (char )'_';
  pattern[109] = (char )'_';
  pattern[110] = (char )'_';
  pattern[111] = (char )'_';
  pattern[112] = (char )'_';
  pattern[113] = (char )'_';
  pattern[114] = (char )'#';
  pattern[115] = (char )'_';
  pattern[116] = (char )'_';
  pattern[117] = (char )'#';
  pattern[118] = (char )'_';
  pattern[119] = (char )'_';
  pattern[120] = (char )'#';
  pattern[121] = (char )'_';
  pattern[122] = (char )'_';
  pattern[123] = (char )'_';
  pattern[124] = (char )'#';
  pattern[125] = (char )'_';
  pattern[126] = (char )'_';
  pattern[127] = (char )'#';
  pattern[128] = (char )'#';
  pattern[129] = (char )'#';
  pattern[130] = (char )'#';
  pattern[131] = (char )'_';
  pattern[132] = (char )'#';
  pattern[133] = (char )'_';
  pattern[134] = (char )'#';
  pattern[135] = (char )'_';
  pattern[136] = (char )'#';
  pattern[137] = (char )'#';
  pattern[138] = (char )'#';
  pattern[139] = (char )'#';
  pattern[140] = (char )'#';
  pattern[141] = (char )'#';
  pattern[142] = (char )'#';
  pattern[143] = (char )'_';
  pattern[144] = (char )'#';
  pattern[145] = (char )'_';
  pattern[146] = (char )'#';
  pattern[147] = (char )'#';
  pattern[148] = (char )'_';
  pattern[149] = (char )'#';
  pattern[150] = (char )'#';
  pattern[151] = (char )'#';
  pattern[152] = (char )'_';
  pattern[153] = (char )'_';
  pattern[154] = (char )'_';
  pattern[155] = (char )'#';
  pattern[156] = (char )'_';
  pattern[157] = (char )'#';
  pattern[158] = (char )'_';
  pattern[159] = (char )'_';
  pattern[160] = (char )'_';
  pattern[161] = (char )'_';
  pattern[162] = (char )'#';
  pattern[163] = (char )'_';
  pattern[164] = (char )'_';
  pattern[165] = (char )'_';
  pattern[166] = (char )'#';
  pattern[167] = (char )'#';
  pattern[168] = (char )'_';
  pattern[169] = (char )'#';
  pattern[170] = (char )'_';
  pattern[171] = (char )'#';
  pattern[172] = (char )'#';
  pattern[173] = (char )'#';
  pattern[174] = (char )'#';
  pattern[175] = (char )'_';
  pattern[176] = (char )'_';
  pattern[177] = (char )'_';
  pattern[178] = (char )'_';
  pattern[179] = (char )'#';
  pattern[180] = (char )'#';
  pattern[181] = (char )'_';
  pattern[182] = (char )'_';
  pattern[183] = (char )'#';
  pattern[184] = (char )'#';
  pattern[185] = (char )'#';
  pattern[186] = (char )'_';
  pattern[187] = (char )'_';
  pattern[188] = (char )'_';
  pattern[189] = (char )'#';
  pattern[190] = (char )'_';
  pattern[191] = (char )'_';
  pattern[192] = (char )'#';
  pattern[193] = (char )'#';
  pattern[194] = (char )'_';
  pattern[195] = (char )'_';
  pattern[196] = (char )'#';
  pattern[197] = (char )'#';
  pattern[198] = (char )'#';
  pattern[199] = (char )'_';
  pattern[200] = (char )'#';
  pattern[201] = (char )'_';
  pattern[202] = (char )'#';
  pattern[203] = (char )'#';
  pattern[204] = (char )'#';
  pattern[205] = (char )'_';
  pattern[206] = (char )'#';
  pattern[207] = (char )'_';
  pattern[208] = (char )'#';
  pattern[209] = (char )'_';
  pattern[210] = (char )'#';
  pattern[211] = (char )'#';
  pattern[212] = (char )'_';
  pattern[213] = (char )'_';
  pattern[214] = (char )'_';
  pattern[215] = (char )'_';
  pattern[216] = (char )'#';
  pattern[217] = (char )'#';
  pattern[218] = (char )'#';
  pattern[219] = (char )'#';
  pattern[220] = (char )'_';
  pattern[221] = (char )'#';
  pattern[222] = (char )'#';
  pattern[223] = (char )'#';
  pattern[224] = (char )'_';
  pattern[225] = (char )'\000';
  testStartReal("test_mqrencode", "Encoding test (MQR).");
  qrcode.width = 15;
  qrcode.version = 3;
  frame = MQRspec_newFrame(qrcode.version);
  i = 0;
  while (i < 225) {
    if ((int )pattern[i] == 35) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    *(frame + i) = (unsigned char )((int )*(frame + i) ^ tmp);
    i ++;
  }
  qrcode.data = frame;
  qrdata = QRcode_decodeMQR(& qrcode);
  assertionNum ++;
  if (! (qrdata->version == 3)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Format info decoder returns wrong version number: %d (%d expected)\n",
           qrdata->version, 3);
  }
  assertionNum ++;
  if (! ((unsigned int )qrdata->level == 1U)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Format info decoder returns wrong level: %d (%d expected)\n",
           (unsigned int )qrdata->level, 1);
  }
  assertionNum ++;
  tmp___0 = strcmp((char const   *)((char *)qrdata->data), (char const   *)str);
  if (! (tmp___0 == 0)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Decoded data (%s) mismatched (%s)\n", (char *)qrdata->data,
           str);
  }
  QRdata_free(qrdata);
  free((void *)frame);
  testFinish();
  return;
}
}
static void test_apiversion(void) 
{ 
  int major_version ;
  int minor_version ;
  int micro_version ;
  char *str ;
  char *str2 ;
  int tmp ;

  {
  testStartReal("test_apiversion", "API Version check");
  QRcode_APIVersion(& major_version, & minor_version, & micro_version);
  assertionNum ++;
  if (! (major_version == 4)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Major version number mismatched: %d (%d expected)\n",
           major_version, 4);
  }
  assertionNum ++;
  if (! (minor_version == 1)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Minor version number mismatched: %d (%d expected)\n",
           minor_version, 1);
  }
  assertionNum ++;
  if (! (micro_version == 1)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Micro version number mismatched: %d (%d expected)\n",
           micro_version, 1);
  }
  str = QRcode_APIVersionString();
  str2 = QRcode_APIVersionString();
  assertionNum ++;
  tmp = strcmp("4.1.1", (char const   *)str);
  if (! (tmp == 0)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Version string mismatched: %s (%s expected)\n",
           str, "4.1.1");
  }
  assertionNum ++;
  if (! ((unsigned long )str == (unsigned long )str2)) {
    assertionFailed ++;
    printf((char const   * __restrict  )"Version strings are not identical.");
  }
  testFinish();
  return;
}
}
int main(int argc , char **argv ) 
{ 
  int tests___0 ;

  {
  tests___0 = 33;
  testInit(tests___0);
  test_iterate();
  test_iterate2();
  test_filler();
  test_format();
  test_encode();
  test_encode2();
  test_encode3();
  test_encodeNull();
  test_encodeEmpty();
  test_encodeNull8();
  test_encodeEmpty8();
  test_encodeLongData();
  test_encodeVer26Num();
  test_01234567();
  test_invalid_input();
  test_struct_example();
  test_struct_semilong();
  test_null_free();
  test_qrraw_new();
  test_mqrraw_new();
  test_encodeData();
  test_formatInfo();
  test_decodeSimple();
  test_decodeLong();
  test_decodeVeryLong();
  test_fillerMQR();
  test_formatInfoMQR();
  test_encodeTooLongMQR();
  test_decodeShortMQR();
  test_oddBitCalcMQR();
  test_invalid_inputMQR();
  test_mqrencode();
  test_apiversion();
  testReport(tests___0);
  if (argc > 1) {
    print_filler();
    print_01234567();
    print_fillerMQR();
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-d11dXO6l.i","")
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
void QRinput_Struct_free(QRinput_Struct *s ) ;
QRinput_Struct *QRinput_splitQRinputToStruct(QRinput *input ) ;
QRcode *QRcode_encodeDataMQR(int size , unsigned char const   *data , int version ,
                             QRecLevel level ) ;
QRcode_List *QRcode_encodeInputStructured(QRinput_Struct *s ) ;
QRcode_List *QRcode_encodeDataStructured(int size , unsigned char const   *data ,
                                         int version , QRecLevel level ) ;
void QRcode_clearCache(void)  __attribute__((__deprecated__)) ;
int MQRspec_getDataLength(int version , QRecLevel level ) ;
unsigned char *QRinput_getByteStream(QRinput *input ) ;
int RSECC_encode(size_t data_length , size_t ecc_length , unsigned char const   *data ,
                 unsigned char *ecc ) ;
unsigned char *Mask_mask(int width , unsigned char *frame , QRecLevel level ) ;
unsigned char *MMask_mask(int version , unsigned char *frame , QRecLevel level ) ;
static void RSblock_initBlock(RSblock *block , int dl , unsigned char *data , int el ,
                              unsigned char *ecc ) 
{ 


  {
  block->dataLength = dl;
  block->data = data;
  block->eccLength = el;
  block->ecc = ecc;
  RSECC_encode((size_t )dl, (size_t )el, (unsigned char const   *)data, ecc);
  return;
}
}
static int RSblock_init(RSblock *blocks , int *spec , unsigned char *data , unsigned char *ecc ) 
{ 
  int i ;
  RSblock *block ;
  unsigned char *dp ;
  unsigned char *ep ;
  int el ;
  int dl ;

  {
  dl = *(spec + 1);
  el = *(spec + 2);
  block = blocks;
  dp = data;
  ep = ecc;
  i = 0;
  while (i < *(spec + 0)) {
    RSblock_initBlock(block, dl, dp, el, ep);
    dp += dl;
    ep += el;
    block ++;
    i ++;
  }
  if (*(spec + 3) == 0) {
    return (0);
  }
  dl = *(spec + 4);
  el = *(spec + 2);
  i = 0;
  while (i < *(spec + 3)) {
    RSblock_initBlock(block, dl, dp, el, ep);
    dp += dl;
    ep += el;
    block ++;
    i ++;
  }
  return (0);
}
}
QRRawCode *QRraw_new(QRinput *input ) 
{ 
  QRRawCode *raw ;
  int spec[5] ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = malloc(sizeof(QRRawCode ));
  raw = (QRRawCode *)tmp;
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    return ((QRRawCode *)((void *)0));
  }
  raw->datacode = QRinput_getByteStream(input);
  if ((unsigned long )raw->datacode == (unsigned long )((void *)0)) {
    free((void *)raw);
    return ((QRRawCode *)((void *)0));
  }
  QRspec_getEccSpec(input->version, input->level, (int *)(spec));
  raw->version = input->version;
  raw->b1 = spec[0];
  raw->dataLength = spec[0] * spec[1] + spec[3] * spec[4];
  raw->eccLength = (spec[0] + spec[3]) * spec[2];
  tmp___0 = malloc((size_t )raw->eccLength);
  raw->ecccode = (unsigned char *)tmp___0;
  if ((unsigned long )raw->ecccode == (unsigned long )((void *)0)) {
    free((void *)raw->datacode);
    free((void *)raw);
    return ((QRRawCode *)((void *)0));
  }
  raw->blocks = spec[0] + spec[3];
  tmp___1 = calloc((size_t )raw->blocks, sizeof(RSblock ));
  raw->rsblock = (RSblock *)tmp___1;
  if ((unsigned long )raw->rsblock == (unsigned long )((void *)0)) {
    QRraw_free(raw);
    return ((QRRawCode *)((void *)0));
  }
  ret = RSblock_init(raw->rsblock, (int *)(spec), raw->datacode, raw->ecccode);
  if (ret < 0) {
    QRraw_free(raw);
    return ((QRRawCode *)((void *)0));
  }
  raw->count = 0;
  return (raw);
}
}
unsigned char QRraw_getCode(QRRawCode *raw ) 
{ 
  int col ;
  int row ;
  unsigned char ret ;

  {
  if (raw->count < raw->dataLength) {
    row = raw->count % raw->blocks;
    col = raw->count / raw->blocks;
    if (col >= (raw->rsblock + 0)->dataLength) {
      row += raw->b1;
    }
    ret = *((raw->rsblock + row)->data + col);
  } else
  if (raw->count < raw->dataLength + raw->eccLength) {
    row = (raw->count - raw->dataLength) % raw->blocks;
    col = (raw->count - raw->dataLength) / raw->blocks;
    ret = *((raw->rsblock + row)->ecc + col);
  } else {
    return ((unsigned char)0);
  }
  (raw->count) ++;
  return (ret);
}
}
void QRraw_free(QRRawCode *raw ) 
{ 


  {
  if ((unsigned long )raw != (unsigned long )((void *)0)) {
    free((void *)raw->datacode);
    free((void *)raw->ecccode);
    free((void *)raw->rsblock);
    free((void *)raw);
  }
  return;
}
}
MQRRawCode *MQRraw_new(QRinput *input ) 
{ 
  MQRRawCode *raw ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = malloc(sizeof(MQRRawCode ));
  raw = (MQRRawCode *)tmp;
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    return ((MQRRawCode *)((void *)0));
  }
  raw->version = input->version;
  raw->dataLength = MQRspec_getDataLength(input->version, input->level);
  raw->eccLength = MQRspec_getECCLength(input->version, input->level);
  tmp___0 = MQRspec_getDataLengthBit(input->version, input->level);
  raw->oddbits = raw->dataLength * 8 - tmp___0;
  raw->datacode = QRinput_getByteStream(input);
  if ((unsigned long )raw->datacode == (unsigned long )((void *)0)) {
    free((void *)raw);
    return ((MQRRawCode *)((void *)0));
  }
  tmp___1 = malloc((size_t )raw->eccLength);
  raw->ecccode = (unsigned char *)tmp___1;
  if ((unsigned long )raw->ecccode == (unsigned long )((void *)0)) {
    free((void *)raw->datacode);
    free((void *)raw);
    return ((MQRRawCode *)((void *)0));
  }
  tmp___2 = calloc((size_t )1, sizeof(RSblock ));
  raw->rsblock = (RSblock *)tmp___2;
  if ((unsigned long )raw->rsblock == (unsigned long )((void *)0)) {
    MQRraw_free(raw);
    return ((MQRRawCode *)((void *)0));
  }
  RSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength,
                    raw->ecccode);
  raw->count = 0;
  return (raw);
}
}
unsigned char MQRraw_getCode(MQRRawCode *raw ) 
{ 
  unsigned char ret ;

  {
  if (raw->count < raw->dataLength) {
    ret = *(raw->datacode + raw->count);
  } else
  if (raw->count < raw->dataLength + raw->eccLength) {
    ret = *(raw->ecccode + (raw->count - raw->dataLength));
  } else {
    return ((unsigned char)0);
  }
  (raw->count) ++;
  return (ret);
}
}
void MQRraw_free(MQRRawCode *raw ) 
{ 


  {
  if ((unsigned long )raw != (unsigned long )((void *)0)) {
    free((void *)raw->datacode);
    free((void *)raw->ecccode);
    free((void *)raw->rsblock);
    free((void *)raw);
  }
  return;
}
}
static void FrameFiller_set(FrameFiller *filler , int width , unsigned char *frame ,
                            int mqr ) 
{ 


  {
  filler->width = width;
  filler->frame = frame;
  filler->x = width - 1;
  filler->y = width - 1;
  filler->dir = -1;
  filler->bit = -1;
  filler->mqr = mqr;
  return;
}
}
static unsigned char *FrameFiller_next___0(FrameFiller *filler ) 
{ 
  unsigned char *p ;
  int x ;
  int y ;
  int w ;
  unsigned char *tmp ;

  {
  if (filler->bit == -1) {
    filler->bit = 0;
    return ((filler->frame + filler->y * filler->width) + filler->x);
  }
  x = filler->x;
  y = filler->y;
  p = filler->frame;
  w = filler->width;
  if (filler->bit == 0) {
    x --;
    (filler->bit) ++;
  } else {
    x ++;
    y += filler->dir;
    (filler->bit) --;
  }
  if (filler->dir < 0) {
    if (y < 0) {
      y = 0;
      x -= 2;
      filler->dir = 1;
      if (! filler->mqr) {
        if (x == 6) {
          x --;
          y = 9;
        }
      }
    }
  } else
  if (y == w) {
    y = w - 1;
    x -= 2;
    filler->dir = -1;
    if (! filler->mqr) {
      if (x == 6) {
        x --;
        y -= 8;
      }
    }
  }
  if (x < 0) {
    return ((unsigned char *)((void *)0));
  } else
  if (y < 0) {
    return ((unsigned char *)((void *)0));
  }
  filler->x = x;
  filler->y = y;
  if ((int )*(p + (y * w + x)) & 128) {
    tmp = FrameFiller_next___0(filler);
    return (tmp);
  }
  return (p + (y * w + x));
}
}
unsigned char *FrameFiller_test(int version ) 
{ 
  int width ;
  unsigned char *frame ;
  unsigned char *p ;
  int i ;
  int length ;
  FrameFiller filler ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  width = QRspec_getWidth(version);
  frame = QRspec_newFrame(version);
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  FrameFiller_set(& filler, width, frame, 0);
  tmp = QRspec_getDataLength(version, (QRecLevel )0);
  tmp___0 = QRspec_getECCLength(version, (QRecLevel )0);
  tmp___1 = QRspec_getRemainder(version);
  length = (tmp * 8 + tmp___0 * 8) + tmp___1;
  i = 0;
  while (i < length) {
    p = FrameFiller_next___0(& filler);
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      free((void *)frame);
      return ((unsigned char *)((void *)0));
    }
    *p = (unsigned char )((int )((unsigned char )(i & 127)) | 128);
    i ++;
  }
  return (frame);
}
}
unsigned char *FrameFiller_testMQR(int version ) 
{ 
  int width ;
  unsigned char *frame ;
  unsigned char *p ;
  int i ;
  int length ;
  FrameFiller filler ;
  int tmp ;
  int tmp___0 ;

  {
  width = MQRspec_getWidth(version);
  frame = MQRspec_newFrame(version);
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  FrameFiller_set(& filler, width, frame, 1);
  tmp = MQRspec_getDataLengthBit(version, (QRecLevel )0);
  tmp___0 = MQRspec_getECCLength(version, (QRecLevel )0);
  length = tmp + tmp___0 * 8;
  i = 0;
  while (i < length) {
    p = FrameFiller_next___0(& filler);
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Frame filler run over the frame!\n");
      return (frame);
    }
    *p = (unsigned char )((int )((unsigned char )(i & 127)) | 128);
    i ++;
  }
  return (frame);
}
}
QRcode *QRcode_new(int version , int width , unsigned char *data ) 
{ 
  QRcode *qrcode ;
  void *tmp ;

  {
  tmp = malloc(sizeof(QRcode ));
  qrcode = (QRcode *)tmp;
  if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  qrcode->version = version;
  qrcode->width = width;
  qrcode->data = data;
  return (qrcode);
}
}
void QRcode_free(QRcode *qrcode ) 
{ 


  {
  if ((unsigned long )qrcode != (unsigned long )((void *)0)) {
    free((void *)qrcode->data);
    free((void *)qrcode);
  }
  return;
}
}
QRcode *QRcode_encodeMask(QRinput *input , int mask ) 
{ 
  int width ;
  int version ;
  QRRawCode *raw ;
  unsigned char *frame ;
  unsigned char *masked ;
  unsigned char *p ;
  unsigned char code ;
  unsigned char bit ;
  int i ;
  int j ;
  QRcode *qrcode ;
  FrameFiller filler ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;

  {
  qrcode = (QRcode *)((void *)0);
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if (input->version < 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((QRcode *)((void *)0));
  } else
  if (input->version > 40) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((QRcode *)((void *)0));
  }
  if ((unsigned int )input->level >= 0U) {
    if (! ((unsigned int )input->level <= 3U)) {
      tmp___1 = __errno_location();
      *tmp___1 = 22;
      return ((QRcode *)((void *)0));
    }
  } else {
    tmp___1 = __errno_location();
    *tmp___1 = 22;
    return ((QRcode *)((void *)0));
  }
  raw = QRraw_new(input);
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  version = raw->version;
  width = QRspec_getWidth(version);
  frame = QRspec_newFrame(version);
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    QRraw_free(raw);
    return ((QRcode *)((void *)0));
  }
  FrameFiller_set(& filler, width, frame, 0);
  i = 0;
  while (i < raw->dataLength) {
    code = QRraw_getCode(raw);
    bit = (unsigned char)128;
    j = 0;
    while (j < 8) {
      p = FrameFiller_next___0(& filler);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto EXIT;
      }
      *p = (unsigned char )(((int )bit & (int )code) != 0);
      bit = (unsigned char )((int )bit >> 1);
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < raw->eccLength) {
    code = QRraw_getCode(raw);
    bit = (unsigned char)128;
    j = 0;
    while (j < 8) {
      p = FrameFiller_next___0(& filler);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto EXIT;
      }
      *p = (unsigned char )(2 | (((int )bit & (int )code) != 0));
      bit = (unsigned char )((int )bit >> 1);
      j ++;
    }
    i ++;
  }
  QRraw_free(raw);
  raw = (QRRawCode *)((void *)0);
  j = QRspec_getRemainder(version);
  i = 0;
  while (i < j) {
    p = FrameFiller_next___0(& filler);
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      goto EXIT;
    }
    *p = (unsigned char)2;
    i ++;
  }
  if (mask == -2) {
    tmp___2 = malloc((size_t )(width * width));
    masked = (unsigned char *)tmp___2;
    memcpy((void * __restrict  )masked, (void const   * __restrict  )frame, (size_t )(width * width));
  } else
  if (mask < 0) {
    masked = Mask_mask(width, frame, input->level);
  } else {
    masked = Mask_makeMask(width, frame, mask, input->level);
  }
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    goto EXIT;
  }
  qrcode = QRcode_new(version, width, masked);
  if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
    free((void *)masked);
  }
  EXIT: 
  QRraw_free(raw);
  free((void *)frame);
  return (qrcode);
}
}
QRcode *QRcode_encodeMaskMQR(QRinput *input , int mask ) 
{ 
  int width ;
  int version ;
  MQRRawCode *raw ;
  unsigned char *frame ;
  unsigned char *masked ;
  unsigned char *p ;
  unsigned char code ;
  unsigned char bit ;
  int i ;
  int j ;
  int length ;
  QRcode *qrcode ;
  FrameFiller filler ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;

  {
  qrcode = (QRcode *)((void *)0);
  if (! input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if (input->version <= 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((QRcode *)((void *)0));
  } else
  if (input->version > 4) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return ((QRcode *)((void *)0));
  }
  if ((unsigned int )input->level >= 0U) {
    if (! ((unsigned int )input->level <= 2U)) {
      tmp___1 = __errno_location();
      *tmp___1 = 22;
      return ((QRcode *)((void *)0));
    }
  } else {
    tmp___1 = __errno_location();
    *tmp___1 = 22;
    return ((QRcode *)((void *)0));
  }
  raw = MQRraw_new(input);
  if ((unsigned long )raw == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  version = raw->version;
  width = MQRspec_getWidth(version);
  frame = MQRspec_newFrame(version);
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    MQRraw_free(raw);
    return ((QRcode *)((void *)0));
  }
  FrameFiller_set(& filler, width, frame, 1);
  i = 0;
  while (i < raw->dataLength) {
    code = MQRraw_getCode(raw);
    bit = (unsigned char)128;
    if (raw->oddbits) {
      if (i == raw->dataLength - 1) {
        length = raw->oddbits;
      } else {
        length = 8;
      }
    } else {
      length = 8;
    }
    j = 0;
    while (j < length) {
      p = FrameFiller_next___0(& filler);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto EXIT;
      }
      *p = (unsigned char )(((int )bit & (int )code) != 0);
      bit = (unsigned char )((int )bit >> 1);
      j ++;
    }
    i ++;
  }
  i = 0;
  while (i < raw->eccLength) {
    code = MQRraw_getCode(raw);
    bit = (unsigned char)128;
    length = 8;
    j = 0;
    while (j < length) {
      p = FrameFiller_next___0(& filler);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto EXIT;
      }
      *p = (unsigned char )(2 | (((int )bit & (int )code) != 0));
      bit = (unsigned char )((int )bit >> 1);
      j ++;
    }
    i ++;
  }
  MQRraw_free(raw);
  raw = (MQRRawCode *)((void *)0);
  if (mask == -2) {
    tmp___2 = malloc((size_t )(width * width));
    masked = (unsigned char *)tmp___2;
    memcpy((void * __restrict  )masked, (void const   * __restrict  )frame, (size_t )(width * width));
  } else
  if (mask < 0) {
    masked = MMask_mask(version, frame, input->level);
  } else {
    masked = MMask_makeMask(version, frame, mask, input->level);
  }
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    goto EXIT;
  }
  qrcode = QRcode_new(version, width, masked);
  if ((unsigned long )qrcode == (unsigned long )((void *)0)) {
    free((void *)masked);
  }
  EXIT: 
  MQRraw_free(raw);
  free((void *)frame);
  return (qrcode);
}
}
QRcode *QRcode_encodeInput(QRinput *input ) 
{ 
  QRcode *tmp ;
  QRcode *tmp___0 ;

  {
  if (input->mqr) {
    tmp = QRcode_encodeMaskMQR(input, -1);
    return (tmp);
  } else {
    tmp___0 = QRcode_encodeMask(input, -1);
    return (tmp___0);
  }
}
}
static QRcode *QRcode_encodeStringReal(char const   *string , int version , QRecLevel level ,
                                       int mqr , QRencodeMode hint , int casesensitive ) 
{ 
  QRinput *input ;
  QRcode *code ;
  int ret ;
  int *tmp ;
  int *tmp___0 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if ((int )hint != 2) {
    if ((int )hint != 3) {
      tmp___0 = __errno_location();
      *tmp___0 = 22;
      return ((QRcode *)((void *)0));
    }
  }
  if (mqr) {
    input = QRinput_newMQR(version, level);
  } else {
    input = QRinput_new2(version, level);
  }
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  ret = Split_splitStringToQRinput(string, input, hint, casesensitive);
  if (ret < 0) {
    QRinput_free(input);
    return ((QRcode *)((void *)0));
  }
  code = QRcode_encodeInput(input);
  QRinput_free(input);
  return (code);
}
}
QRcode *QRcode_encodeString(char const   *string , int version , QRecLevel level ,
                            QRencodeMode hint , int casesensitive ) 
{ 
  QRcode *tmp ;

  {
  tmp = QRcode_encodeStringReal(string, version, level, 0, hint, casesensitive);
  return (tmp);
}
}
QRcode *QRcode_encodeStringMQR(char const   *string , int version , QRecLevel level ,
                               QRencodeMode hint , int casesensitive ) 
{ 
  int i ;
  QRcode *code ;
  QRcode *tmp ;

  {
  if (version == 0) {
    version = 1;
  }
  i = version;
  while (i <= 4) {
    tmp = QRcode_encodeStringReal(string, i, level, 1, hint, casesensitive);
    code = tmp;
    if ((unsigned long )code != (unsigned long )((void *)0)) {
      return (code);
    }
    i ++;
  }
  return ((QRcode *)((void *)0));
}
}
static QRcode *QRcode_encodeDataReal(unsigned char const   *data , int length , int version ,
                                     QRecLevel level , int mqr ) 
{ 
  QRinput *input ;
  QRcode *code ;
  int ret ;
  int *tmp ;

  {
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  } else
  if (length == 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if (mqr) {
    input = QRinput_newMQR(version, level);
  } else {
    input = QRinput_new2(version, level);
  }
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRcode *)((void *)0));
  }
  ret = QRinput_append(input, (QRencodeMode )2, length, data);
  if (ret < 0) {
    QRinput_free(input);
    return ((QRcode *)((void *)0));
  }
  code = QRcode_encodeInput(input);
  QRinput_free(input);
  return (code);
}
}
QRcode *QRcode_encodeData(int size , unsigned char const   *data , int version , QRecLevel level ) 
{ 
  QRcode *tmp ;

  {
  tmp = QRcode_encodeDataReal(data, size, version, level, 0);
  return (tmp);
}
}
QRcode *QRcode_encodeString8bit(char const   *string , int version , QRecLevel level ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  QRcode *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  tmp___0 = strlen(string);
  tmp___1 = QRcode_encodeDataReal((unsigned char const   *)((unsigned char *)string),
                                  (int )tmp___0, version, level, 0);
  return (tmp___1);
}
}
QRcode *QRcode_encodeDataMQR(int size , unsigned char const   *data , int version ,
                             QRecLevel level ) 
{ 
  int i ;
  QRcode *code ;
  QRcode *tmp ;

  {
  if (version == 0) {
    version = 1;
  }
  i = version;
  while (i <= 4) {
    tmp = QRcode_encodeDataReal(data, size, i, level, 1);
    code = tmp;
    if ((unsigned long )code != (unsigned long )((void *)0)) {
      return (code);
    }
    i ++;
  }
  return ((QRcode *)((void *)0));
}
}
QRcode *QRcode_encodeString8bitMQR(char const   *string , int version , QRecLevel level ) 
{ 
  int i ;
  int *tmp ;
  QRcode *code ;
  size_t tmp___0 ;
  QRcode *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode *)((void *)0));
  }
  if (version == 0) {
    version = 1;
  }
  i = version;
  while (i <= 4) {
    tmp___0 = strlen(string);
    tmp___1 = QRcode_encodeDataReal((unsigned char const   *)((unsigned char *)string),
                                    (int )tmp___0, i, level, 1);
    code = tmp___1;
    if ((unsigned long )code != (unsigned long )((void *)0)) {
      return (code);
    }
    i ++;
  }
  return ((QRcode *)((void *)0));
}
}
static QRcode_List *QRcode_List_newEntry(void) 
{ 
  QRcode_List *entry ;
  void *tmp ;

  {
  tmp = malloc(sizeof(QRcode_List ));
  entry = (QRcode_List *)tmp;
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return ((QRcode_List *)((void *)0));
  }
  entry->next = (struct _QRcode_List *)((void *)0);
  entry->code = (QRcode *)((void *)0);
  return (entry);
}
}
static void QRcode_List_freeEntry(QRcode_List *entry ) 
{ 


  {
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    QRcode_free(entry->code);
    free((void *)entry);
  }
  return;
}
}
void QRcode_List_free(QRcode_List *qrlist ) 
{ 
  QRcode_List *list ;
  QRcode_List *next ;

  {
  list = qrlist;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    next = list->next;
    QRcode_List_freeEntry(list);
    list = next;
  }
  return;
}
}
int QRcode_List_size(QRcode_List *qrlist ) 
{ 
  QRcode_List *list ;
  int size ;

  {
  list = qrlist;
  size = 0;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    size ++;
    list = list->next;
  }
  return (size);
}
}
QRcode_List *QRcode_encodeInputStructured(QRinput_Struct *s ) 
{ 
  QRcode_List *head ;
  QRcode_List *tail ;
  QRcode_List *entry ;
  QRinput_InputList *list ;

  {
  head = (QRcode_List *)((void *)0);
  tail = (QRcode_List *)((void *)0);
  list = s->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    if ((unsigned long )head == (unsigned long )((void *)0)) {
      entry = QRcode_List_newEntry();
      if ((unsigned long )entry == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      head = entry;
      tail = head;
    } else {
      entry = QRcode_List_newEntry();
      if ((unsigned long )entry == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      tail->next = entry;
      tail = tail->next;
    }
    tail->code = QRcode_encodeInput(list->input);
    if ((unsigned long )tail->code == (unsigned long )((void *)0)) {
      goto ABORT;
    }
    list = list->next;
  }
  return (head);
  ABORT: 
  QRcode_List_free(head);
  return ((QRcode_List *)((void *)0));
}
}
static QRcode_List *QRcode_encodeInputToStructured(QRinput *input ) 
{ 
  QRinput_Struct *s ;
  QRcode_List *codes ;

  {
  s = QRinput_splitQRinputToStruct(input);
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return ((QRcode_List *)((void *)0));
  }
  codes = QRcode_encodeInputStructured(s);
  QRinput_Struct_free(s);
  return (codes);
}
}
static QRcode_List *QRcode_encodeDataStructuredReal(int size , unsigned char const   *data ,
                                                    int version , QRecLevel level ,
                                                    int eightbit , QRencodeMode hint ,
                                                    int casesensitive ) 
{ 
  QRinput *input ;
  QRcode_List *codes ;
  int ret ;
  int *tmp ;
  int *tmp___0 ;

  {
  if (version <= 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode_List *)((void *)0));
  }
  if (! eightbit) {
    if ((int )hint != 2) {
      if ((int )hint != 3) {
        tmp___0 = __errno_location();
        *tmp___0 = 22;
        return ((QRcode_List *)((void *)0));
      }
    }
  }
  input = QRinput_new2(version, level);
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRcode_List *)((void *)0));
  }
  if (eightbit) {
    ret = QRinput_append(input, (QRencodeMode )2, size, data);
  } else {
    ret = Split_splitStringToQRinput((char const   *)((char *)data), input, hint,
                                     casesensitive);
  }
  if (ret < 0) {
    QRinput_free(input);
    return ((QRcode_List *)((void *)0));
  }
  codes = QRcode_encodeInputToStructured(input);
  QRinput_free(input);
  return (codes);
}
}
QRcode_List *QRcode_encodeDataStructured(int size , unsigned char const   *data ,
                                         int version , QRecLevel level ) 
{ 
  QRcode_List *tmp ;

  {
  tmp = QRcode_encodeDataStructuredReal(size, data, version, level, 1, (QRencodeMode )-1,
                                        0);
  return (tmp);
}
}
QRcode_List *QRcode_encodeString8bitStructured(char const   *string , int version ,
                                               QRecLevel level ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  QRcode_List *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode_List *)((void *)0));
  }
  tmp___0 = strlen(string);
  tmp___1 = QRcode_encodeDataStructured((int )tmp___0, (unsigned char const   *)((unsigned char *)string),
                                        version, level);
  return (tmp___1);
}
}
QRcode_List *QRcode_encodeStringStructured(char const   *string , int version , QRecLevel level ,
                                           QRencodeMode hint , int casesensitive ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  QRcode_List *tmp___1 ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRcode_List *)((void *)0));
  }
  tmp___0 = strlen(string);
  tmp___1 = QRcode_encodeDataStructuredReal((int )tmp___0, (unsigned char const   *)((unsigned char *)string),
                                            version, level, 0, hint, casesensitive);
  return (tmp___1);
}
}
void QRcode_APIVersion(int *major_version , int *minor_version , int *micro_version ) 
{ 


  {
  if ((unsigned long )major_version != (unsigned long )((void *)0)) {
    *major_version = 4;
  }
  if ((unsigned long )minor_version != (unsigned long )((void *)0)) {
    *minor_version = 1;
  }
  if ((unsigned long )micro_version != (unsigned long )((void *)0)) {
    *micro_version = 1;
  }
  return;
}
}
char *QRcode_APIVersionString(void) 
{ 


  {
  return ((char *)"4.1.1");
}
}
void QRcode_clearCache(void)  __attribute__((__deprecated__)) ;
void QRcode_clearCache(void) 
{ 


  {
  return;
}
}
#pragma merger("0","/tmp/cil-LozhPUNp.i","")
int QRinput_appendECIheader(QRinput *input , unsigned int ecinum ) ;
int QRinput_getVersion(QRinput *input ) ;
QRecLevel QRinput_getErrorCorrectionLevel(QRinput *input ) ;
int QRinput_setVersionAndErrorCorrectionLevel(QRinput *input , int version , QRecLevel level ) ;
int QRinput_check(QRencodeMode mode , int size , unsigned char const   *data ) ;
QRinput_Struct *QRinput_Struct_new(void) ;
void QRinput_Struct_setParity(QRinput_Struct *s , unsigned char parity ) ;
int QRinput_Struct_appendInput(QRinput_Struct *s , QRinput *input ) ;
int QRinput_Struct_insertStructuredAppendHeaders(QRinput_Struct *s ) ;
int QRinput_setFNC1First(QRinput *input ) ;
int QRinput_setFNC1Second(QRinput *input , unsigned char appid ) ;
int QRspec_getMinimumVersion(int size , QRecLevel level ) ;
int QRspec_maximumWords(QRencodeMode mode , int version ) ;
int MQRspec_maximumWords(QRencodeMode mode , int version ) ;
int BitStream_appendNum(BitStream *bstream , size_t bits , unsigned int num ) ;
int BitStream_appendBytes(BitStream *bstream , size_t size , unsigned char *data ) ;
unsigned char *BitStream_toByte(BitStream *bstream ) ;
int QRinput_isSplittableMode(QRencodeMode mode ) ;
int QRinput_estimateBitsModeNum(int size ) ;
int QRinput_estimateBitsModeAn(int size ) ;
int QRinput_estimateBitsMode8(int size ) ;
int QRinput_estimateBitsModeKanji(int size ) ;
QRinput *QRinput_dup(QRinput *input ) ;
signed char const   QRinput_anTable[128] ;
int QRinput_getBitStream(QRinput *input , BitStream *bstream ) ;
int QRinput_estimateBitStreamSize(QRinput *input , int version ) ;
int QRinput_splitEntry(QRinput_List *entry , int bytes ) ;
int QRinput_estimateVersion(QRinput *input ) ;
int QRinput_lengthOfCode(QRencodeMode mode , int version , int bits ) ;
int QRinput_insertStructuredAppendHeader(QRinput *input , int size , int number ,
                                         unsigned char parity ) ;
int QRinput_isSplittableMode(QRencodeMode mode ) 
{ 
  int tmp ;

  {
  if ((int )mode >= 0) {
    if ((int )mode <= 3) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static QRinput_List *QRinput_List_newEntry(QRencodeMode mode , int size , unsigned char const   *data ) 
{ 
  QRinput_List *entry ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp___0 = QRinput_check(mode, size, data);
  if (tmp___0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput_List *)((void *)0));
  }
  tmp___1 = malloc(sizeof(QRinput_List ));
  entry = (QRinput_List *)tmp___1;
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return ((QRinput_List *)((void *)0));
  }
  entry->mode = mode;
  entry->size = size;
  entry->data = (unsigned char *)((void *)0);
  if (size > 0) {
    tmp___2 = malloc((size_t )size);
    entry->data = (unsigned char *)tmp___2;
    if ((unsigned long )entry->data == (unsigned long )((void *)0)) {
      free((void *)entry);
      return ((QRinput_List *)((void *)0));
    }
    memcpy((void * __restrict  )entry->data, (void const   * __restrict  )data, (size_t )size);
  }
  entry->bstream = (BitStream *)((void *)0);
  entry->next = (QRinput_List *)((void *)0);
  return (entry);
}
}
static void QRinput_List_freeEntry(QRinput_List *entry ) 
{ 


  {
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    free((void *)entry->data);
    BitStream_free(entry->bstream);
    free((void *)entry);
  }
  return;
}
}
static QRinput_List *QRinput_List_dup(QRinput_List *entry ) 
{ 
  QRinput_List *n ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = malloc(sizeof(QRinput_List ));
  n = (QRinput_List *)tmp;
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    return ((QRinput_List *)((void *)0));
  }
  n->mode = entry->mode;
  n->size = entry->size;
  tmp___0 = malloc((size_t )n->size);
  n->data = (unsigned char *)tmp___0;
  if ((unsigned long )n->data == (unsigned long )((void *)0)) {
    free((void *)n);
    return ((QRinput_List *)((void *)0));
  }
  memcpy((void * __restrict  )n->data, (void const   * __restrict  )entry->data, (size_t )entry->size);
  n->bstream = (BitStream *)((void *)0);
  n->next = (QRinput_List *)((void *)0);
  return (n);
}
}
QRinput *QRinput_new(void) 
{ 
  QRinput *tmp ;

  {
  tmp = QRinput_new2(0, (QRecLevel )0);
  return (tmp);
}
}
QRinput *QRinput_new2(int version , QRecLevel level ) 
{ 
  QRinput *input ;
  int *tmp ;
  void *tmp___0 ;

  {
  if (version < 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput *)((void *)0));
  } else
  if (version > 40) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput *)((void *)0));
  } else
  if ((unsigned int )level < 0U) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput *)((void *)0));
  } else
  if ((unsigned int )level > 3U) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput *)((void *)0));
  }
  tmp___0 = malloc(sizeof(QRinput ));
  input = (QRinput *)tmp___0;
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRinput *)((void *)0));
  }
  input->head = (QRinput_List *)((void *)0);
  input->tail = (QRinput_List *)((void *)0);
  input->version = version;
  input->level = level;
  input->mqr = 0;
  input->fnc1 = 0;
  return (input);
}
}
QRinput *QRinput_newMQR(int version , QRecLevel level ) 
{ 
  QRinput *input ;
  int tmp ;
  int *tmp___0 ;

  {
  if (version <= 0) {
    goto INVALID;
  } else
  if (version > 4) {
    goto INVALID;
  }
  tmp = MQRspec_getECCLength(version, level);
  if (tmp == 0) {
    goto INVALID;
  }
  input = QRinput_new2(version, level);
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    return ((QRinput *)((void *)0));
  }
  input->mqr = 1;
  return (input);
  INVALID: 
  tmp___0 = __errno_location();
  *tmp___0 = 22;
  return ((QRinput *)((void *)0));
}
}
int QRinput_getVersion(QRinput *input ) 
{ 


  {
  return (input->version);
}
}
int QRinput_setVersion(QRinput *input , int version ) 
{ 
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if (version < 0) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if (version > 40) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  input->version = version;
  return (0);
}
}
QRecLevel QRinput_getErrorCorrectionLevel(QRinput *input ) 
{ 


  {
  return (input->level);
}
}
int QRinput_setErrorCorrectionLevel(QRinput *input , QRecLevel level ) 
{ 
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if ((unsigned int )level > 3U) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  input->level = level;
  return (0);
}
}
int QRinput_setVersionAndErrorCorrectionLevel(QRinput *input , int version , QRecLevel level ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  if (input->mqr) {
    if (version <= 0) {
      goto INVALID;
    } else
    if (version > 4) {
      goto INVALID;
    }
    tmp = MQRspec_getECCLength(version, level);
    if (tmp == 0) {
      goto INVALID;
    }
  } else {
    if (version < 0) {
      goto INVALID;
    } else
    if (version > 40) {
      goto INVALID;
    }
    if ((unsigned int )level > 3U) {
      goto INVALID;
    }
  }
  input->version = version;
  input->level = level;
  return (0);
  INVALID: 
  tmp___0 = __errno_location();
  *tmp___0 = 22;
  return (-1);
}
}
static void QRinput_appendEntry(QRinput *input , QRinput_List *entry ) 
{ 


  {
  if ((unsigned long )input->tail == (unsigned long )((void *)0)) {
    input->head = entry;
    input->tail = entry;
  } else {
    (input->tail)->next = entry;
    input->tail = entry;
  }
  entry->next = (QRinput_List *)((void *)0);
  return;
}
}
int QRinput_append(QRinput *input , QRencodeMode mode , int size , unsigned char const   *data ) 
{ 
  QRinput_List *entry ;

  {
  entry = QRinput_List_newEntry(mode, size, data);
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return (-1);
  }
  QRinput_appendEntry(input, entry);
  return (0);
}
}
int QRinput_insertStructuredAppendHeader(QRinput *input , int size , int number ,
                                         unsigned char parity ) 
{ 
  QRinput_List *entry ;
  unsigned char buf[3] ;
  int *tmp ;
  int *tmp___0 ;

  {
  if (size > 16) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  if (number <= 0) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return (-1);
  } else
  if (number > size) {
    tmp___0 = __errno_location();
    *tmp___0 = 22;
    return (-1);
  }
  buf[0] = (unsigned char )size;
  buf[1] = (unsigned char )number;
  buf[2] = parity;
  entry = QRinput_List_newEntry((QRencodeMode )4, 3, (unsigned char const   *)(buf));
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return (-1);
  }
  entry->next = input->head;
  input->head = entry;
  return (0);
}
}
int QRinput_appendECIheader(QRinput *input , unsigned int ecinum ) 
{ 
  unsigned char data[4] ;
  int *tmp ;
  int tmp___0 ;

  {
  if (ecinum > 999999U) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  data[0] = (unsigned char )(ecinum & 255U);
  data[1] = (unsigned char )((ecinum >> 8) & 255U);
  data[2] = (unsigned char )((ecinum >> 16) & 255U);
  data[3] = (unsigned char )((ecinum >> 24) & 255U);
  tmp___0 = QRinput_append(input, (QRencodeMode )5, 4, (unsigned char const   *)(data));
  return (tmp___0);
}
}
void QRinput_free(QRinput *input ) 
{ 
  QRinput_List *list ;
  QRinput_List *next ;

  {
  if ((unsigned long )input != (unsigned long )((void *)0)) {
    list = input->head;
    while ((unsigned long )list != (unsigned long )((void *)0)) {
      next = list->next;
      QRinput_List_freeEntry(list);
      list = next;
    }
    free((void *)input);
  }
  return;
}
}
static unsigned char QRinput_calcParity(QRinput *input ) 
{ 
  unsigned char parity ;
  QRinput_List *list ;
  int i ;

  {
  parity = (unsigned char)0;
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    if ((int )list->mode != 4) {
      i = list->size - 1;
      while (i >= 0) {
        parity = (unsigned char )((int )parity ^ (int )*(list->data + i));
        i --;
      }
    }
    list = list->next;
  }
  return (parity);
}
}
QRinput *QRinput_dup(QRinput *input ) 
{ 
  QRinput *n ;
  QRinput_List *list ;
  QRinput_List *e ;

  {
  if (input->mqr) {
    n = QRinput_newMQR(input->version, input->level);
  } else {
    n = QRinput_new2(input->version, input->level);
  }
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    return ((QRinput *)((void *)0));
  }
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    e = QRinput_List_dup(list);
    if ((unsigned long )e == (unsigned long )((void *)0)) {
      QRinput_free(n);
      return ((QRinput *)((void *)0));
    }
    QRinput_appendEntry(n, e);
    list = list->next;
  }
  return (n);
}
}
static int QRinput_checkModeNum(int size , char const   *data ) 
{ 
  int i ;

  {
  i = 0;
  while (i < size) {
    if ((int const   )*(data + i) < 48) {
      return (-1);
    } else
    if ((int const   )*(data + i) > 57) {
      return (-1);
    }
    i ++;
  }
  return (0);
}
}
int QRinput_estimateBitsModeNum(int size ) 
{ 
  int w ;
  int bits ;

  {
  w = size / 3;
  bits = w * 10;
  switch (size - w * 3) {
  case 1: 
  bits += 4;
  break;
  case 2: 
  bits += 7;
  break;
  default: 
  break;
  }
  return (bits);
}
}
static int QRinput_encodeModeNum(QRinput_List *entry , BitStream *bstream , int version ,
                                 int mqr ) 
{ 
  int words ;
  int i ;
  int ret ;
  unsigned int val ;
  int tmp ;
  int tmp___0 ;

  {
  if (mqr) {
    if (version > 1) {
      ret = BitStream_appendNum(bstream, (size_t )(version - 1), 0U);
      if (ret < 0) {
        return (-1);
      }
    }
    tmp = MQRspec_lengthIndicator((QRencodeMode )0, version);
    ret = BitStream_appendNum(bstream, (size_t )tmp, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  } else {
    ret = BitStream_appendNum(bstream, (size_t )4, 1U);
    if (ret < 0) {
      return (-1);
    }
    tmp___0 = QRspec_lengthIndicator((QRencodeMode )0, version);
    ret = BitStream_appendNum(bstream, (size_t )tmp___0, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  }
  words = entry->size / 3;
  i = 0;
  while (i < words) {
    val = (unsigned int )((int )*(entry->data + i * 3) - 48) * 100U;
    val += (unsigned int )((int )*(entry->data + (i * 3 + 1)) - 48) * 10U;
    val += (unsigned int )((int )*(entry->data + (i * 3 + 2)) - 48);
    ret = BitStream_appendNum(bstream, (size_t )10, val);
    if (ret < 0) {
      return (-1);
    }
    i ++;
  }
  if (entry->size - words * 3 == 1) {
    val = (unsigned int )((int )*(entry->data + words * 3) - 48);
    ret = BitStream_appendNum(bstream, (size_t )4, val);
    if (ret < 0) {
      return (-1);
    }
  } else
  if (entry->size - words * 3 == 2) {
    val = (unsigned int )((int )*(entry->data + words * 3) - 48) * 10U;
    val += (unsigned int )((int )*(entry->data + (words * 3 + 1)) - 48);
    ret = BitStream_appendNum(bstream, (size_t )7, val);
    if (ret < 0) {
      return (-1);
    }
  }
  return (0);
}
}
signed char const   QRinput_anTable[128]  = 
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )36,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )-1,      (signed char const   )41,      (signed char const   )42,      (signed char const   )43, 
        (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )44,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )10,      (signed char const   )11,      (signed char const   )12, 
        (signed char const   )13,      (signed char const   )14,      (signed char const   )15,      (signed char const   )16, 
        (signed char const   )17,      (signed char const   )18,      (signed char const   )19,      (signed char const   )20, 
        (signed char const   )21,      (signed char const   )22,      (signed char const   )23,      (signed char const   )24, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
static int QRinput_checkModeAn(int size , char const   *data ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < size) {
    if ((int const   )*(data + i) & 128) {
      tmp = -1;
    } else {
      tmp = (int )QRinput_anTable[(int )*(data + i)];
    }
    if (tmp < 0) {
      return (-1);
    }
    i ++;
  }
  return (0);
}
}
int QRinput_estimateBitsModeAn(int size ) 
{ 
  int w ;
  int bits ;

  {
  w = size / 2;
  bits = w * 11;
  if (size & 1) {
    bits += 6;
  }
  return (bits);
}
}
static int QRinput_encodeModeAn(QRinput_List *entry , BitStream *bstream , int version ,
                                int mqr ) 
{ 
  int words ;
  int i ;
  int ret ;
  unsigned int val ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (mqr) {
    if (version < 2) {
      tmp = __errno_location();
      *tmp = 34;
      return (-1);
    }
    ret = BitStream_appendNum(bstream, (size_t )(version - 1), 1U);
    if (ret < 0) {
      return (-1);
    }
    tmp___0 = MQRspec_lengthIndicator((QRencodeMode )1, version);
    ret = BitStream_appendNum(bstream, (size_t )tmp___0, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  } else {
    ret = BitStream_appendNum(bstream, (size_t )4, 2U);
    if (ret < 0) {
      return (-1);
    }
    tmp___1 = QRspec_lengthIndicator((QRencodeMode )1, version);
    ret = BitStream_appendNum(bstream, (size_t )tmp___1, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  }
  words = entry->size / 2;
  i = 0;
  while (i < words) {
    if ((int )*(entry->data + i * 2) & 128) {
      tmp___2 = -1;
    } else {
      tmp___2 = (int )QRinput_anTable[(int )*(entry->data + i * 2)];
    }
    val = (unsigned int )tmp___2 * 45U;
    if ((int )*(entry->data + (i * 2 + 1)) & 128) {
      tmp___3 = -1;
    } else {
      tmp___3 = (int )QRinput_anTable[(int )*(entry->data + (i * 2 + 1))];
    }
    val += (unsigned int )tmp___3;
    ret = BitStream_appendNum(bstream, (size_t )11, val);
    if (ret < 0) {
      return (-1);
    }
    i ++;
  }
  if (entry->size & 1) {
    if ((int )*(entry->data + words * 2) & 128) {
      tmp___4 = -1;
    } else {
      tmp___4 = (int )QRinput_anTable[(int )*(entry->data + words * 2)];
    }
    val = (unsigned int )tmp___4;
    ret = BitStream_appendNum(bstream, (size_t )6, val);
    if (ret < 0) {
      return (-1);
    }
  }
  return (0);
}
}
int QRinput_estimateBitsMode8(int size ) 
{ 


  {
  return (size * 8);
}
}
static int QRinput_encodeMode8(QRinput_List *entry , BitStream *bstream , int version ,
                               int mqr ) 
{ 
  int ret ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (mqr) {
    if (version < 3) {
      tmp = __errno_location();
      *tmp = 34;
      return (-1);
    }
    ret = BitStream_appendNum(bstream, (size_t )(version - 1), 2U);
    if (ret < 0) {
      return (-1);
    }
    tmp___0 = MQRspec_lengthIndicator((QRencodeMode )2, version);
    ret = BitStream_appendNum(bstream, (size_t )tmp___0, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  } else {
    ret = BitStream_appendNum(bstream, (size_t )4, 4U);
    if (ret < 0) {
      return (-1);
    }
    tmp___1 = QRspec_lengthIndicator((QRencodeMode )2, version);
    ret = BitStream_appendNum(bstream, (size_t )tmp___1, (unsigned int )entry->size);
    if (ret < 0) {
      return (-1);
    }
  }
  ret = BitStream_appendBytes(bstream, (size_t )entry->size, entry->data);
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
int QRinput_estimateBitsModeKanji(int size ) 
{ 


  {
  return ((size / 2) * 13);
}
}
static int QRinput_checkModeKanji(int size , unsigned char const   *data ) 
{ 
  int i ;
  unsigned int val ;

  {
  if (size & 1) {
    return (-1);
  }
  i = 0;
  while (i < size) {
    val = ((unsigned int )*(data + i) << 8) | (unsigned int )*(data + (i + 1));
    if (val < 33088U) {
      return (-1);
    } else
    if (val > 40956U) {
      if (val < 57408U) {
        return (-1);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (val > 60351U) {
      return (-1);
    }
    i += 2;
  }
  return (0);
}
}
static int QRinput_encodeModeKanji(QRinput_List *entry , BitStream *bstream , int version ,
                                   int mqr ) 
{ 
  int ret ;
  int i ;
  unsigned int val ;
  unsigned int h ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (mqr) {
    if (version < 2) {
      tmp = __errno_location();
      *tmp = 34;
      return (-1);
    }
    ret = BitStream_appendNum(bstream, (size_t )(version - 1), 3U);
    if (ret < 0) {
      return (-1);
    }
    tmp___0 = MQRspec_lengthIndicator((QRencodeMode )3, version);
    ret = BitStream_appendNum(bstream, (size_t )tmp___0, (unsigned int )entry->size / 2U);
    if (ret < 0) {
      return (-1);
    }
  } else {
    ret = BitStream_appendNum(bstream, (size_t )4, 8U);
    if (ret < 0) {
      return (-1);
    }
    tmp___1 = QRspec_lengthIndicator((QRencodeMode )3, version);
    ret = BitStream_appendNum(bstream, (size_t )tmp___1, (unsigned int )entry->size / 2U);
    if (ret < 0) {
      return (-1);
    }
  }
  i = 0;
  while (i < entry->size) {
    val = ((unsigned int )*(entry->data + i) << 8) | (unsigned int )*(entry->data + (i + 1));
    if (val <= 40956U) {
      val -= 33088U;
    } else {
      val -= 49472U;
    }
    h = (val >> 8) * 192U;
    val = (val & 255U) + h;
    ret = BitStream_appendNum(bstream, (size_t )13, val);
    if (ret < 0) {
      return (-1);
    }
    i += 2;
  }
  return (0);
}
}
static int QRinput_encodeModeStructure(QRinput_List *entry , BitStream *bstream ,
                                       int mqr ) 
{ 
  int ret ;
  int *tmp ;

  {
  if (mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )4, 3U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )4, (unsigned int )*(entry->data + 1) - 1U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )4, (unsigned int )*(entry->data + 0) - 1U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )8, (unsigned int )*(entry->data + 2));
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
static int QRinput_checkModeFNC1Second(int size ) 
{ 


  {
  if (size != 1) {
    return (-1);
  }
  return (0);
}
}
static int QRinput_encodeModeFNC1Second(QRinput_List *entry , BitStream *bstream ) 
{ 
  int ret ;

  {
  ret = BitStream_appendNum(bstream, (size_t )4, 9U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendBytes(bstream, (size_t )1, entry->data);
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
static unsigned int QRinput_decodeECIfromByteArray(unsigned char *data ) 
{ 
  int i ;
  unsigned int ecinum ;

  {
  ecinum = 0U;
  i = 0;
  while (i < 4) {
    ecinum <<= 8;
    ecinum |= (unsigned int )*(data + (3 - i));
    i ++;
  }
  return (ecinum);
}
}
static int QRinput_estimateBitsModeECI(unsigned char *data ) 
{ 
  unsigned int ecinum ;

  {
  ecinum = QRinput_decodeECIfromByteArray(data);
  if (ecinum < 128U) {
    return (12);
  } else
  if (ecinum < 16384U) {
    return (20);
  } else {
    return (28);
  }
}
}
static int QRinput_encodeModeECI(QRinput_List *entry , BitStream *bstream ) 
{ 
  int ret ;
  int words ;
  unsigned int ecinum ;
  unsigned int code ;

  {
  ecinum = QRinput_decodeECIfromByteArray(entry->data);
  if (ecinum < 128U) {
    words = 1;
    code = ecinum;
  } else
  if (ecinum < 16384U) {
    words = 2;
    code = 32768U + ecinum;
  } else {
    words = 3;
    code = 786432U + ecinum;
  }
  ret = BitStream_appendNum(bstream, (size_t )4, 7U);
  if (ret < 0) {
    return (-1);
  }
  ret = BitStream_appendNum(bstream, (size_t )words * 8UL, code);
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
int QRinput_check(QRencodeMode mode , int size , unsigned char const   *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((int )mode == 6) {
    if (size < 0) {
      return (-1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (size <= 0) {
    return (-1);
  }
  switch ((int )mode) {
  case 0: 
  tmp = QRinput_checkModeNum(size, (char const   *)data);
  return (tmp);
  case 1: 
  tmp___0 = QRinput_checkModeAn(size, (char const   *)data);
  return (tmp___0);
  case 3: 
  tmp___1 = QRinput_checkModeKanji(size, data);
  return (tmp___1);
  case 2: 
  return (0);
  case 4: 
  return (0);
  case 5: 
  return (0);
  case 6: 
  return (0);
  case 7: 
  tmp___2 = QRinput_checkModeFNC1Second(size);
  return (tmp___2);
  case -1: 
  break;
  }
  return (-1);
}
}
static int QRinput_estimateBitStreamSizeOfEntry(QRinput_List *entry , int version ,
                                                int mqr ) 
{ 
  int bits ;
  int l ;
  int m ;
  int num ;

  {
  bits = 0;
  if (version == 0) {
    version = 1;
  }
  switch ((int )entry->mode) {
  case 0: 
  bits = QRinput_estimateBitsModeNum(entry->size);
  break;
  case 1: 
  bits = QRinput_estimateBitsModeAn(entry->size);
  break;
  case 2: 
  bits = QRinput_estimateBitsMode8(entry->size);
  break;
  case 3: 
  bits = QRinput_estimateBitsModeKanji(entry->size);
  break;
  case 4: 
  return (20);
  case 5: 
  bits = QRinput_estimateBitsModeECI(entry->data);
  break;
  case 6: 
  return (4);
  case 7: 
  return (12);
  default: 
  return (0);
  }
  if (mqr) {
    l = MQRspec_lengthIndicator(entry->mode, version);
    m = version - 1;
    bits += l + m;
  } else {
    l = QRspec_lengthIndicator(entry->mode, version);
    m = 1 << l;
    if ((int )entry->mode == 3) {
      num = ((entry->size / 2 + m) - 1) / m;
    } else {
      num = ((entry->size + m) - 1) / m;
    }
    bits += num * (4 + l);
  }
  return (bits);
}
}
int QRinput_estimateBitStreamSize(QRinput *input , int version ) 
{ 
  QRinput_List *list ;
  int bits ;
  int tmp ;

  {
  bits = 0;
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    tmp = QRinput_estimateBitStreamSizeOfEntry(list, version, input->mqr);
    bits += tmp;
    list = list->next;
  }
  return (bits);
}
}
int QRinput_estimateVersion(QRinput *input ) 
{ 
  int bits ;
  int version ;
  int prev ;

  {
  version = 0;
  while (1) {
    prev = version;
    bits = QRinput_estimateBitStreamSize(input, prev);
    version = QRspec_getMinimumVersion((bits + 7) / 8, input->level);
    if (prev == 0) {
      if (version > 1) {
        version --;
      }
    }
    if (! (version > prev)) {
      break;
    }
  }
  return (version);
}
}
int QRinput_lengthOfCode(QRencodeMode mode , int version , int bits ) 
{ 
  int payload ;
  int size ;
  int chunks ;
  int remain ;
  int maxsize ;
  int tmp ;

  {
  tmp = QRspec_lengthIndicator(mode, version);
  payload = (bits - 4) - tmp;
  switch ((int )mode) {
  case 0: 
  chunks = payload / 10;
  remain = payload - chunks * 10;
  size = chunks * 3;
  if (remain >= 7) {
    size += 2;
  } else
  if (remain >= 4) {
    size ++;
  }
  break;
  case 1: 
  chunks = payload / 11;
  remain = payload - chunks * 11;
  size = chunks * 2;
  if (remain >= 6) {
    size ++;
  }
  break;
  case 2: 
  size = payload / 8;
  break;
  case 3: 
  size = (payload / 13) * 2;
  break;
  case 4: 
  size = payload / 8;
  break;
  default: 
  size = 0;
  break;
  }
  maxsize = QRspec_maximumWords(mode, version);
  if (size < 0) {
    size = 0;
  }
  if (maxsize > 0) {
    if (size > maxsize) {
      size = maxsize;
    }
  }
  return (size);
}
}
static int QRinput_encodeBitStream(QRinput_List *entry , BitStream *bstream , int version ,
                                   int mqr ) 
{ 
  int words ;
  int ret ;
  QRinput_List *st1 ;
  QRinput_List *st2 ;
  int prevsize ;

  {
  st1 = (QRinput_List *)((void *)0);
  st2 = (QRinput_List *)((void *)0);
  prevsize = (int )bstream->length;
  if (mqr) {
    words = MQRspec_maximumWords(entry->mode, version);
  } else {
    words = QRspec_maximumWords(entry->mode, version);
  }
  if (words != 0) {
    if (entry->size > words) {
      st1 = QRinput_List_newEntry(entry->mode, words, (unsigned char const   *)entry->data);
      if ((unsigned long )st1 == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      st2 = QRinput_List_newEntry(entry->mode, entry->size - words, (unsigned char const   *)(entry->data + words));
      if ((unsigned long )st2 == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      ret = QRinput_encodeBitStream(st1, bstream, version, mqr);
      if (ret < 0) {
        goto ABORT;
      }
      ret = QRinput_encodeBitStream(st2, bstream, version, mqr);
      if (ret < 0) {
        goto ABORT;
      }
      QRinput_List_freeEntry(st1);
      QRinput_List_freeEntry(st2);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = 0;
    switch ((int )entry->mode) {
    case 0: 
    ret = QRinput_encodeModeNum(entry, bstream, version, mqr);
    break;
    case 1: 
    ret = QRinput_encodeModeAn(entry, bstream, version, mqr);
    break;
    case 2: 
    ret = QRinput_encodeMode8(entry, bstream, version, mqr);
    break;
    case 3: 
    ret = QRinput_encodeModeKanji(entry, bstream, version, mqr);
    break;
    case 4: 
    ret = QRinput_encodeModeStructure(entry, bstream, mqr);
    break;
    case 5: 
    ret = QRinput_encodeModeECI(entry, bstream);
    break;
    case 7: 
    ret = QRinput_encodeModeFNC1Second(entry, bstream);
    break;
    default: 
    break;
    }
    if (ret < 0) {
      return (-1);
    }
  }
  return ((int )bstream->length - prevsize);
  ABORT: 
  QRinput_List_freeEntry(st1);
  QRinput_List_freeEntry(st2);
  return (-1);
}
}
static int QRinput_createBitStream(QRinput *input , BitStream *bstream ) 
{ 
  QRinput_List *list ;
  int bits ;
  int total ;

  {
  total = 0;
  list = input->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    bits = QRinput_encodeBitStream(list, bstream, input->version, input->mqr);
    if (bits < 0) {
      return (-1);
    }
    total += bits;
    list = list->next;
  }
  return (total);
}
}
static int QRinput_convertData(QRinput *input , BitStream *bstream ) 
{ 
  int bits ;
  int ver ;
  int tmp ;
  int tmp___0 ;

  {
  ver = QRinput_estimateVersion(input);
  tmp = QRinput_getVersion(input);
  if (ver > tmp) {
    QRinput_setVersion(input, ver);
  }
  while (1) {
    bstream->length = (size_t )0;
    bits = QRinput_createBitStream(input, bstream);
    if (bits < 0) {
      return (-1);
    }
    ver = QRspec_getMinimumVersion((bits + 7) / 8, input->level);
    tmp___0 = QRinput_getVersion(input);
    if (ver > tmp___0) {
      QRinput_setVersion(input, ver);
    } else {
      break;
    }
  }
  return (0);
}
}
static int QRinput_appendPaddingBit(BitStream *bstream , QRinput *input ) 
{ 
  int bits ;
  int maxbits ;
  int words ;
  int maxwords ;
  int i ;
  int ret ;
  int padlen ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  bits = (int )bstream->length;
  maxwords = QRspec_getDataLength(input->version, input->level);
  maxbits = maxwords * 8;
  if (maxbits < bits) {
    tmp = __errno_location();
    *tmp = 34;
    return (-1);
  }
  if (maxbits == bits) {
    return (0);
  }
  if (maxbits - bits <= 4) {
    tmp___0 = BitStream_appendNum(bstream, (size_t )(maxbits - bits), 0U);
    return (tmp___0);
  }
  words = ((bits + 4) + 7) / 8;
  tmp___1 = BitStream_appendNum(bstream, (size_t )(words * 8 - bits), 0U);
  ret = tmp___1;
  if (ret < 0) {
    return (ret);
  }
  padlen = maxwords - words;
  if (padlen > 0) {
    i = 0;
    while (i < padlen) {
      if (i & 1) {
        tmp___2 = 17;
      } else {
        tmp___2 = 236;
      }
      tmp___3 = BitStream_appendNum(bstream, (size_t )8, (unsigned int )tmp___2);
      ret = tmp___3;
      if (ret < 0) {
        return (ret);
      }
      i ++;
    }
  }
  return (0);
}
}
static int QRinput_appendPaddingBitMQR(BitStream *bstream , QRinput *input ) 
{ 
  int bits ;
  int maxbits ;
  int words ;
  int maxwords ;
  int i ;
  int ret ;
  int termbits ;
  int padlen ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  bits = (int )bstream->length;
  maxbits = MQRspec_getDataLengthBit(input->version, input->level);
  maxwords = maxbits / 8;
  if (maxbits < bits) {
    tmp = __errno_location();
    *tmp = 34;
    return (-1);
  }
  if (maxbits == bits) {
    return (0);
  }
  termbits = input->version * 2 + 1;
  if (maxbits - bits <= termbits) {
    tmp___0 = BitStream_appendNum(bstream, (size_t )(maxbits - bits), 0U);
    return (tmp___0);
  }
  bits += termbits;
  words = (bits + 7) / 8;
  if (maxbits - words * 8 > 0) {
    termbits += words * 8 - bits;
    if (words == maxwords) {
      termbits += maxbits - words * 8;
    }
  } else {
    termbits += words * 8 - bits;
  }
  tmp___1 = BitStream_appendNum(bstream, (size_t )termbits, 0U);
  ret = tmp___1;
  if (ret < 0) {
    return (ret);
  }
  padlen = maxwords - words;
  if (padlen > 0) {
    i = 0;
    while (i < padlen) {
      if (i & 1) {
        tmp___2 = 17;
      } else {
        tmp___2 = 236;
      }
      tmp___3 = BitStream_appendNum(bstream, (size_t )8, (unsigned int )tmp___2);
      ret = tmp___3;
      if (ret < 0) {
        return (ret);
      }
      i ++;
    }
    termbits = maxbits - maxwords * 8;
    if (termbits > 0) {
      tmp___4 = BitStream_appendNum(bstream, (size_t )termbits, 0U);
      ret = tmp___4;
      if (ret < 0) {
        return (ret);
      }
    }
  }
  return (0);
}
}
static int QRinput_insertFNC1Header(QRinput *input ) 
{ 
  QRinput_List *entry ;

  {
  entry = (QRinput_List *)((void *)0);
  if (input->fnc1 == 1) {
    entry = QRinput_List_newEntry((QRencodeMode )6, 0, (unsigned char const   *)((void *)0));
  } else
  if (input->fnc1 == 2) {
    entry = QRinput_List_newEntry((QRencodeMode )7, 1, (unsigned char const   *)(& input->appid));
  }
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return (-1);
  }
  if ((int )(input->head)->mode != 4) {
    if ((int )(input->head)->mode != 5) {
      entry->next = input->head;
      input->head = entry;
    } else {
      entry->next = (input->head)->next;
      (input->head)->next = entry;
    }
  } else {
    entry->next = (input->head)->next;
    (input->head)->next = entry;
  }
  return (0);
}
}
int QRinput_mergeBitStream(QRinput *input , BitStream *bstream ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (input->mqr) {
    tmp = QRinput_createBitStream(input, bstream);
    if (tmp < 0) {
      return (-1);
    }
  } else {
    if (input->fnc1) {
      tmp___0 = QRinput_insertFNC1Header(input);
      if (tmp___0 < 0) {
        return (-1);
      }
    }
    tmp___1 = QRinput_convertData(input, bstream);
    if (tmp___1 < 0) {
      return (-1);
    }
  }
  return (0);
}
}
int QRinput_getBitStream(QRinput *input , BitStream *bstream ) 
{ 
  int ret ;

  {
  ret = QRinput_mergeBitStream(input, bstream);
  if (ret < 0) {
    return (-1);
  }
  if (input->mqr) {
    ret = QRinput_appendPaddingBitMQR(bstream, input);
  } else {
    ret = QRinput_appendPaddingBit(bstream, input);
  }
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
unsigned char *QRinput_getByteStream(QRinput *input ) 
{ 
  BitStream *bstream ;
  unsigned char *array ;
  int ret ;

  {
  bstream = BitStream_new();
  if ((unsigned long )bstream == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  ret = QRinput_getBitStream(input, bstream);
  if (ret < 0) {
    BitStream_free(bstream);
    return ((unsigned char *)((void *)0));
  }
  array = BitStream_toByte(bstream);
  BitStream_free(bstream);
  return (array);
}
}
static QRinput_InputList *QRinput_InputList_newEntry(QRinput *input ) 
{ 
  QRinput_InputList *entry ;
  void *tmp ;

  {
  tmp = malloc(sizeof(QRinput_InputList ));
  entry = (QRinput_InputList *)tmp;
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    return ((QRinput_InputList *)((void *)0));
  }
  entry->input = input;
  entry->next = (QRinput_InputList *)((void *)0);
  return (entry);
}
}
static void QRinput_InputList_freeEntry(QRinput_InputList *entry ) 
{ 


  {
  if ((unsigned long )entry != (unsigned long )((void *)0)) {
    QRinput_free(entry->input);
    free((void *)entry);
  }
  return;
}
}
QRinput_Struct *QRinput_Struct_new(void) 
{ 
  QRinput_Struct *s ;
  void *tmp ;

  {
  tmp = malloc(sizeof(QRinput_Struct ));
  s = (QRinput_Struct *)tmp;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return ((QRinput_Struct *)((void *)0));
  }
  s->size = 0;
  s->parity = -1;
  s->head = (QRinput_InputList *)((void *)0);
  s->tail = (QRinput_InputList *)((void *)0);
  return (s);
}
}
void QRinput_Struct_setParity(QRinput_Struct *s , unsigned char parity ) 
{ 


  {
  s->parity = (int )parity;
  return;
}
}
int QRinput_Struct_appendInput(QRinput_Struct *s , QRinput *input ) 
{ 
  QRinput_InputList *e ;
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  e = QRinput_InputList_newEntry(input);
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    return (-1);
  }
  (s->size) ++;
  if ((unsigned long )s->tail == (unsigned long )((void *)0)) {
    s->head = e;
    s->tail = e;
  } else {
    (s->tail)->next = e;
    s->tail = e;
  }
  return (s->size);
}
}
void QRinput_Struct_free(QRinput_Struct *s ) 
{ 
  QRinput_InputList *list ;
  QRinput_InputList *next ;

  {
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    list = s->head;
    while ((unsigned long )list != (unsigned long )((void *)0)) {
      next = list->next;
      QRinput_InputList_freeEntry(list);
      list = next;
    }
    free((void *)s);
  }
  return;
}
}
static unsigned char QRinput_Struct_calcParity(QRinput_Struct *s ) 
{ 
  QRinput_InputList *list ;
  unsigned char parity ;
  unsigned char tmp ;

  {
  parity = (unsigned char)0;
  list = s->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    tmp = QRinput_calcParity(list->input);
    parity = (unsigned char )((int )parity ^ (int )tmp);
    list = list->next;
  }
  QRinput_Struct_setParity(s, parity);
  return (parity);
}
}
static int QRinput_List_shrinkEntry(QRinput_List *entry , int bytes ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
  tmp = malloc((size_t )bytes);
  data = (unsigned char *)tmp;
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    return (-1);
  }
  memcpy((void * __restrict  )data, (void const   * __restrict  )entry->data, (size_t )bytes);
  free((void *)entry->data);
  entry->data = data;
  entry->size = bytes;
  return (0);
}
}
int QRinput_splitEntry(QRinput_List *entry , int bytes ) 
{ 
  QRinput_List *e ;
  int ret ;

  {
  e = QRinput_List_newEntry(entry->mode, entry->size - bytes, (unsigned char const   *)(entry->data + bytes));
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    return (-1);
  }
  ret = QRinput_List_shrinkEntry(entry, bytes);
  if (ret < 0) {
    QRinput_List_freeEntry(e);
    return (-1);
  }
  e->next = entry->next;
  entry->next = e;
  return (0);
}
}
QRinput_Struct *QRinput_splitQRinputToStruct(QRinput *input ) 
{ 
  QRinput *p ;
  QRinput_Struct *s ;
  int bits ;
  int maxbits ;
  int nextbits ;
  int bytes ;
  int ret ;
  QRinput_List *list ;
  QRinput_List *next ;
  QRinput_List *prev ;
  BitStream *bstream ;
  int *tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  p = (QRinput *)((void *)0);
  s = (QRinput_Struct *)((void *)0);
  bstream = (BitStream *)((void *)0);
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return ((QRinput_Struct *)((void *)0));
  }
  s = QRinput_Struct_new();
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return ((QRinput_Struct *)((void *)0));
  }
  input = QRinput_dup(input);
  if ((unsigned long )input == (unsigned long )((void *)0)) {
    QRinput_Struct_free(s);
    return ((QRinput_Struct *)((void *)0));
  }
  tmp___0 = QRinput_calcParity(input);
  QRinput_Struct_setParity(s, tmp___0);
  tmp___1 = QRspec_getDataLength(input->version, input->level);
  maxbits = tmp___1 * 8 - 20;
  if (maxbits <= 0) {
    goto ABORT;
  }
  bstream = BitStream_new();
  if ((unsigned long )bstream == (unsigned long )((void *)0)) {
    goto ABORT;
  }
  bits = 0;
  list = input->head;
  prev = (QRinput_List *)((void *)0);
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    nextbits = QRinput_estimateBitStreamSizeOfEntry(list, input->version, input->mqr);
    if (bits + nextbits <= maxbits) {
      bstream->length = (size_t )0;
      ret = QRinput_encodeBitStream(list, bstream, input->version, input->mqr);
      if (ret < 0) {
        goto ABORT;
      }
      bits += ret;
      prev = list;
      list = list->next;
    } else {
      bytes = QRinput_lengthOfCode(list->mode, input->version, maxbits - bits);
      p = QRinput_new2(input->version, input->level);
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        goto ABORT;
      }
      if (bytes > 0) {
        ret = QRinput_splitEntry(list, bytes);
        if (ret < 0) {
          QRinput_free(p);
          goto ABORT;
        }
        next = list->next;
        list->next = (QRinput_List *)((void *)0);
        p->head = next;
        p->tail = input->tail;
        input->tail = list;
        prev = list;
        list = next;
      } else {
        prev->next = (QRinput_List *)((void *)0);
        p->head = list;
        p->tail = input->tail;
        input->tail = prev;
      }
      ret = QRinput_Struct_appendInput(s, input);
      if (ret < 0) {
        QRinput_free(p);
        goto ABORT;
      }
      input = p;
      bits = 0;
    }
  }
  ret = QRinput_Struct_appendInput(s, input);
  if (ret < 0) {
    goto ABORT;
  }
  if (s->size > 16) {
    tmp___2 = __errno_location();
    *tmp___2 = 34;
    QRinput_Struct_free(s);
    BitStream_free(bstream);
    return ((QRinput_Struct *)((void *)0));
  }
  ret = QRinput_Struct_insertStructuredAppendHeaders(s);
  if (ret < 0) {
    QRinput_Struct_free(s);
    BitStream_free(bstream);
    return ((QRinput_Struct *)((void *)0));
  }
  BitStream_free(bstream);
  return (s);
  ABORT: 
  BitStream_free(bstream);
  QRinput_free(input);
  QRinput_Struct_free(s);
  return ((QRinput_Struct *)((void *)0));
}
}
int QRinput_Struct_insertStructuredAppendHeaders(QRinput_Struct *s ) 
{ 
  int i ;
  QRinput_InputList *list ;
  int tmp ;

  {
  if (s->size == 1) {
    return (0);
  }
  if (s->parity < 0) {
    QRinput_Struct_calcParity(s);
  }
  i = 1;
  list = s->head;
  while ((unsigned long )list != (unsigned long )((void *)0)) {
    tmp = QRinput_insertStructuredAppendHeader(list->input, s->size, i, (unsigned char )s->parity);
    if (tmp) {
      return (-1);
    }
    i ++;
    list = list->next;
  }
  return (0);
}
}
int QRinput_setFNC1First(QRinput *input ) 
{ 
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  input->fnc1 = 1;
  return (0);
}
}
int QRinput_setFNC1Second(QRinput *input , unsigned char appid ) 
{ 
  int *tmp ;

  {
  if (input->mqr) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  input->fnc1 = 2;
  input->appid = appid;
  return (0);
}
}
#pragma merger("0","/tmp/cil-yC3YYJ3H.i","")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
int BitStream_append(BitStream *bstream , BitStream *arg ) ;
BitStream *BitStream_new(void) 
{ 
  BitStream *bstream ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = malloc(sizeof(BitStream ));
  bstream = (BitStream *)tmp;
  if ((unsigned long )bstream == (unsigned long )((void *)0)) {
    return ((BitStream *)((void *)0));
  }
  bstream->length = (size_t )0;
  tmp___0 = malloc((size_t )128);
  bstream->data = (unsigned char *)tmp___0;
  if ((unsigned long )bstream->data == (unsigned long )((void *)0)) {
    free((void *)bstream);
    return ((BitStream *)((void *)0));
  }
  bstream->datasize = (size_t )128;
  return (bstream);
}
}
BitStream *BitStream_newWithBits(size_t size , unsigned char *bits ) 
{ 
  BitStream *bstream ;
  BitStream *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if (size == 0UL) {
    tmp = BitStream_new();
    return (tmp);
  }
  tmp___0 = malloc(sizeof(BitStream ));
  bstream = (BitStream *)tmp___0;
  if ((unsigned long )bstream == (unsigned long )((void *)0)) {
    return ((BitStream *)((void *)0));
  }
  tmp___1 = malloc(size);
  bstream->data = (unsigned char *)tmp___1;
  if ((unsigned long )bstream->data == (unsigned long )((void *)0)) {
    free((void *)bstream);
    return ((BitStream *)((void *)0));
  }
  bstream->length = size;
  bstream->datasize = size;
  memcpy((void * __restrict  )bstream->data, (void const   * __restrict  )bits, size);
  return (bstream);
}
}
static int BitStream_expand(BitStream *bstream ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
  tmp = realloc((void *)bstream->data, bstream->datasize * 2UL);
  data = (unsigned char *)tmp;
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    return (-1);
  }
  bstream->data = data;
  bstream->datasize *= 2UL;
  return (0);
}
}
static void BitStream_writeNum(unsigned char *dest , size_t bits , unsigned int num ) 
{ 
  unsigned int mask ;
  size_t i ;
  unsigned char *p ;

  {
  p = dest;
  mask = 1U << (bits - 1UL);
  i = (size_t )0;
  while (i < bits) {
    if (num & mask) {
      *p = (unsigned char)1;
    } else {
      *p = (unsigned char)0;
    }
    p ++;
    mask >>= 1;
    i ++;
  }
  return;
}
}
static void BitStream_writeBytes(unsigned char *dest , size_t size , unsigned char *data ) 
{ 
  unsigned char mask ;
  size_t i ;
  size_t j ;
  unsigned char *p ;

  {
  p = dest;
  i = (size_t )0;
  while (i < size) {
    mask = (unsigned char)128;
    j = (size_t )0;
    while (j < 8UL) {
      if ((int )*(data + i) & (int )mask) {
        *p = (unsigned char)1;
      } else {
        *p = (unsigned char)0;
      }
      p ++;
      mask = (unsigned char )((int )mask >> 1);
      j ++;
    }
    i ++;
  }
  return;
}
}
int BitStream_append(BitStream *bstream , BitStream *arg ) 
{ 
  int ret ;

  {
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (arg->length == 0UL) {
    return (0);
  }
  while (bstream->length + arg->length > bstream->datasize) {
    ret = BitStream_expand(bstream);
    if (ret < 0) {
      return (ret);
    }
  }
  memcpy((void * __restrict  )(bstream->data + bstream->length), (void const   * __restrict  )arg->data,
         arg->length);
  bstream->length += arg->length;
  return (0);
}
}
int BitStream_appendNum(BitStream *bstream , size_t bits , unsigned int num ) 
{ 
  int ret ;

  {
  if (bits == 0UL) {
    return (0);
  }
  while (bstream->datasize - bstream->length < bits) {
    ret = BitStream_expand(bstream);
    if (ret < 0) {
      return (ret);
    }
  }
  BitStream_writeNum(bstream->data + bstream->length, bits, num);
  bstream->length += bits;
  return (0);
}
}
int BitStream_appendBytes(BitStream *bstream , size_t size , unsigned char *data ) 
{ 
  int ret ;

  {
  if (size == 0UL) {
    return (0);
  }
  while (bstream->datasize - bstream->length < size * 8UL) {
    ret = BitStream_expand(bstream);
    if (ret < 0) {
      return (ret);
    }
  }
  BitStream_writeBytes(bstream->data + bstream->length, size, data);
  bstream->length += size * 8UL;
  return (0);
}
}
unsigned char *BitStream_toByte(BitStream *bstream ) 
{ 
  size_t i ;
  size_t j ;
  size_t size ;
  size_t bytes ;
  size_t oddbits ;
  unsigned char *data ;
  unsigned char v ;
  unsigned char *p ;
  void *tmp ;

  {
  size = bstream->length;
  if (size == 0UL) {
    return ((unsigned char *)((void *)0));
  }
  tmp = malloc((size + 7UL) / 8UL);
  data = (unsigned char *)tmp;
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  bytes = size / 8UL;
  p = bstream->data;
  i = (size_t )0;
  while (i < bytes) {
    v = (unsigned char)0;
    j = (size_t )0;
    while (j < 8UL) {
      v = (unsigned char )((int )v << 1);
      v = (unsigned char )((int )v | (int )*p);
      p ++;
      j ++;
    }
    *(data + i) = v;
    i ++;
  }
  oddbits = size & 7UL;
  if (oddbits > 0UL) {
    v = (unsigned char)0;
    j = (size_t )0;
    while (j < oddbits) {
      v = (unsigned char )((int )v << 1);
      v = (unsigned char )((int )v | (int )*p);
      p ++;
      j ++;
    }
    *(data + bytes) = (unsigned char )((int )v << (8UL - oddbits));
  }
  return (data);
}
}
void BitStream_free(BitStream *bstream ) 
{ 


  {
  if ((unsigned long )bstream != (unsigned long )((void *)0)) {
    free((void *)bstream->data);
    free((void *)bstream);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-nN8fGGqr.i","")
unsigned int QRspec_getVersionPattern(int version ) ;
static QRspec_Capacity const   qrspecCapacity[41]  = 
  {      {0, 0, 0, {0, 0, 0, 0}}, 
        {21, 26, 0, {7, 10, 13, 17}}, 
        {25, 44, 7, {10, 16, 22, 28}}, 
        {29, 70, 7, {15, 26, 36, 44}}, 
        {33, 100, 7, {20, 36, 52, 64}}, 
        {37, 134, 7, {26, 48, 72, 88}}, 
        {41, 172, 7, {36, 64, 96, 112}}, 
        {45, 196, 0, {40, 72, 108, 130}}, 
        {49, 242, 0, {48, 88, 132, 156}}, 
        {53, 292, 0, {60, 110, 160, 192}}, 
        {57, 346, 0, {72, 130, 192, 224}}, 
        {61, 404, 0, {80, 150, 224, 264}}, 
        {65, 466, 0, {96, 176, 260, 308}}, 
        {69, 532, 0, {104, 198, 288, 352}}, 
        {73, 581, 3, {120, 216, 320, 384}}, 
        {77, 655, 3, {132, 240, 360, 432}}, 
        {81, 733, 3, {144, 280, 408, 480}}, 
        {85, 815, 3, {168, 308, 448, 532}}, 
        {89, 901, 3, {180, 338, 504, 588}}, 
        {93, 991, 3, {196, 364, 546, 650}}, 
        {97, 1085, 3, {224, 416, 600, 700}}, 
        {101, 1156, 4, {224, 442, 644, 750}}, 
        {105, 1258, 4, {252, 476, 690, 816}}, 
        {109, 1364, 4, {270, 504, 750, 900}}, 
        {113, 1474, 4, {300, 560, 810, 960}}, 
        {117, 1588, 4, {312, 588, 870, 1050}}, 
        {121, 1706, 4, {336, 644, 952, 1110}}, 
        {125, 1828, 4, {360, 700, 1020, 1200}}, 
        {129, 1921, 3, {390, 728, 1050, 1260}}, 
        {133, 2051, 3, {420, 784, 1140, 1350}}, 
        {137, 2185, 3, {450, 812, 1200, 1440}}, 
        {141, 2323, 3, {480, 868, 1290, 1530}}, 
        {145, 2465, 3, {510, 924, 1350, 1620}}, 
        {149, 2611, 3, {540, 980, 1440, 1710}}, 
        {153, 2761, 3, {570, 1036, 1530, 1800}}, 
        {157, 2876, 0, {570, 1064, 1590, 1890}}, 
        {161, 3034, 0, {600, 1120, 1680, 1980}}, 
        {165, 3196, 0, {630, 1204, 1770, 2100}}, 
        {169, 3362, 0, {660, 1260, 1860, 2220}}, 
        {173, 3532, 0, {720, 1316, 1950, 2310}}, 
        {177, 3706, 0, {750, 1372, 2040, 2430}}};
int QRspec_getDataLength(int version , QRecLevel level ) 
{ 


  {
  return ((int )(qrspecCapacity[version].words - (int const   )qrspecCapacity[version].ec[level]));
}
}
int QRspec_getECCLength(int version , QRecLevel level ) 
{ 


  {
  return (qrspecCapacity[version].ec[level]);
}
}
int QRspec_getMinimumVersion(int size , QRecLevel level ) 
{ 
  int i ;
  int words ;

  {
  i = 1;
  while (i <= 40) {
    words = (int )(qrspecCapacity[i].words - (int const   )qrspecCapacity[i].ec[level]);
    if (words >= size) {
      return (i);
    }
    i ++;
  }
  return (40);
}
}
int QRspec_getWidth(int version ) 
{ 


  {
  return ((int )qrspecCapacity[version].width);
}
}
int QRspec_getRemainder(int version ) 
{ 


  {
  return ((int )qrspecCapacity[version].remainder);
}
}
static int const   lengthTableBits[4][3]  = { {        (int const   )10,        (int const   )12,        (int const   )14}, 
   {        (int const   )9,        (int const   )11,        (int const   )13}, 
   {        (int const   )8,        (int const   )16,        (int const   )16}, 
   {        (int const   )8,        (int const   )10,        (int const   )12}};
int QRspec_lengthIndicator(QRencodeMode mode , int version ) 
{ 
  int l ;
  int tmp ;

  {
  tmp = QRinput_isSplittableMode(mode);
  if (! tmp) {
    return (0);
  }
  if (version <= 9) {
    l = 0;
  } else
  if (version <= 26) {
    l = 1;
  } else {
    l = 2;
  }
  return ((int )lengthTableBits[mode][l]);
}
}
int QRspec_maximumWords(QRencodeMode mode , int version ) 
{ 
  int l ;
  int bits ;
  int words ;
  int tmp ;

  {
  tmp = QRinput_isSplittableMode(mode);
  if (! tmp) {
    return (0);
  }
  if (version <= 9) {
    l = 0;
  } else
  if (version <= 26) {
    l = 1;
  } else {
    l = 2;
  }
  bits = (int )lengthTableBits[mode][l];
  words = (1 << bits) - 1;
  if ((int )mode == 3) {
    words *= 2;
  }
  return (words);
}
}
static int const   eccTable[41][4][2]  = 
  { { {          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )0}, 
     {          (int const   )0,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )1,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}}, 
   { {          (int const   )1,          (int const   )0}, 
     {          (int const   )2,          (int const   )0}, 
     {          (int const   )2,          (int const   )2}, 
     {          (int const   )2,          (int const   )2}}, 
   { {          (int const   )2,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}}, 
   { {          (int const   )2,          (int const   )0}, 
     {          (int const   )4,          (int const   )0}, 
     {          (int const   )2,          (int const   )4}, 
     {          (int const   )4,          (int const   )1}}, 
   { {          (int const   )2,          (int const   )0}, 
     {          (int const   )2,          (int const   )2}, 
     {          (int const   )4,          (int const   )2}, 
     {          (int const   )4,          (int const   )2}}, 
   { {          (int const   )2,          (int const   )0}, 
     {          (int const   )3,          (int const   )2}, 
     {          (int const   )4,          (int const   )4}, 
     {          (int const   )4,          (int const   )4}}, 
   { {          (int const   )2,          (int const   )2}, 
     {          (int const   )4,          (int const   )1}, 
     {          (int const   )6,          (int const   )2}, 
     {          (int const   )6,          (int const   )2}}, 
   { {          (int const   )4,          (int const   )0}, 
     {          (int const   )1,          (int const   )4}, 
     {          (int const   )4,          (int const   )4}, 
     {          (int const   )3,          (int const   )8}}, 
   { {          (int const   )2,          (int const   )2}, 
     {          (int const   )6,          (int const   )2}, 
     {          (int const   )4,          (int const   )6}, 
     {          (int const   )7,          (int const   )4}}, 
   { {          (int const   )4,          (int const   )0}, 
     {          (int const   )8,          (int const   )1}, 
     {          (int const   )8,          (int const   )4}, 
     {          (int const   )12,          (int const   )4}}, 
   { {          (int const   )3,          (int const   )1}, 
     {          (int const   )4,          (int const   )5}, 
     {          (int const   )11,          (int const   )5}, 
     {          (int const   )11,          (int const   )5}}, 
   { {          (int const   )5,          (int const   )1}, 
     {          (int const   )5,          (int const   )5}, 
     {          (int const   )5,          (int const   )7}, 
     {          (int const   )11,          (int const   )7}}, 
   { {          (int const   )5,          (int const   )1}, 
     {          (int const   )7,          (int const   )3}, 
     {          (int const   )15,          (int const   )2}, 
     {          (int const   )3,          (int const   )13}}, 
   { {          (int const   )1,          (int const   )5}, 
     {          (int const   )10,          (int const   )1}, 
     {          (int const   )1,          (int const   )15}, 
     {          (int const   )2,          (int const   )17}}, 
   { {          (int const   )5,          (int const   )1}, 
     {          (int const   )9,          (int const   )4}, 
     {          (int const   )17,          (int const   )1}, 
     {          (int const   )2,          (int const   )19}}, 
   { {          (int const   )3,          (int const   )4}, 
     {          (int const   )3,          (int const   )11}, 
     {          (int const   )17,          (int const   )4}, 
     {          (int const   )9,          (int const   )16}}, 
   { {          (int const   )3,          (int const   )5}, 
     {          (int const   )3,          (int const   )13}, 
     {          (int const   )15,          (int const   )5}, 
     {          (int const   )15,          (int const   )10}}, 
   { {          (int const   )4,          (int const   )4}, 
     {          (int const   )17,          (int const   )0}, 
     {          (int const   )17,          (int const   )6}, 
     {          (int const   )19,          (int const   )6}}, 
   { {          (int const   )2,          (int const   )7}, 
     {          (int const   )17,          (int const   )0}, 
     {          (int const   )7,          (int const   )16}, 
     {          (int const   )34,          (int const   )0}}, 
   { {          (int const   )4,          (int const   )5}, 
     {          (int const   )4,          (int const   )14}, 
     {          (int const   )11,          (int const   )14}, 
     {          (int const   )16,          (int const   )14}}, 
   { {          (int const   )6,          (int const   )4}, 
     {          (int const   )6,          (int const   )14}, 
     {          (int const   )11,          (int const   )16}, 
     {          (int const   )30,          (int const   )2}}, 
   { {          (int const   )8,          (int const   )4}, 
     {          (int const   )8,          (int const   )13}, 
     {          (int const   )7,          (int const   )22}, 
     {          (int const   )22,          (int const   )13}}, 
   { {          (int const   )10,          (int const   )2}, 
     {          (int const   )19,          (int const   )4}, 
     {          (int const   )28,          (int const   )6}, 
     {          (int const   )33,          (int const   )4}}, 
   { {          (int const   )8,          (int const   )4}, 
     {          (int const   )22,          (int const   )3}, 
     {          (int const   )8,          (int const   )26}, 
     {          (int const   )12,          (int const   )28}}, 
   { {          (int const   )3,          (int const   )10}, 
     {          (int const   )3,          (int const   )23}, 
     {          (int const   )4,          (int const   )31}, 
     {          (int const   )11,          (int const   )31}}, 
   { {          (int const   )7,          (int const   )7}, 
     {          (int const   )21,          (int const   )7}, 
     {          (int const   )1,          (int const   )37}, 
     {          (int const   )19,          (int const   )26}}, 
   { {          (int const   )5,          (int const   )10}, 
     {          (int const   )19,          (int const   )10}, 
     {          (int const   )15,          (int const   )25}, 
     {          (int const   )23,          (int const   )25}}, 
   { {          (int const   )13,          (int const   )3}, 
     {          (int const   )2,          (int const   )29}, 
     {          (int const   )42,          (int const   )1}, 
     {          (int const   )23,          (int const   )28}}, 
   { {          (int const   )17,          (int const   )0}, 
     {          (int const   )10,          (int const   )23}, 
     {          (int const   )10,          (int const   )35}, 
     {          (int const   )19,          (int const   )35}}, 
   { {          (int const   )17,          (int const   )1}, 
     {          (int const   )14,          (int const   )21}, 
     {          (int const   )29,          (int const   )19}, 
     {          (int const   )11,          (int const   )46}}, 
   { {          (int const   )13,          (int const   )6}, 
     {          (int const   )14,          (int const   )23}, 
     {          (int const   )44,          (int const   )7}, 
     {          (int const   )59,          (int const   )1}}, 
   { {          (int const   )12,          (int const   )7}, 
     {          (int const   )12,          (int const   )26}, 
     {          (int const   )39,          (int const   )14}, 
     {          (int const   )22,          (int const   )41}}, 
   { {          (int const   )6,          (int const   )14}, 
     {          (int const   )6,          (int const   )34}, 
     {          (int const   )46,          (int const   )10}, 
     {          (int const   )2,          (int const   )64}}, 
   { {          (int const   )17,          (int const   )4}, 
     {          (int const   )29,          (int const   )14}, 
     {          (int const   )49,          (int const   )10}, 
     {          (int const   )24,          (int const   )46}}, 
   { {          (int const   )4,          (int const   )18}, 
     {          (int const   )13,          (int const   )32}, 
     {          (int const   )48,          (int const   )14}, 
     {          (int const   )42,          (int const   )32}}, 
   { {          (int const   )20,          (int const   )4}, 
     {          (int const   )40,          (int const   )7}, 
     {          (int const   )43,          (int const   )22}, 
     {          (int const   )10,          (int const   )67}}, 
   { {          (int const   )19,          (int const   )6}, 
     {          (int const   )18,          (int const   )31}, 
     {          (int const   )34,          (int const   )34}, 
     {          (int const   )20,          (int const   )61}}};
void QRspec_getEccSpec(int version , QRecLevel level , int *spec ) 
{ 
  int b1 ;
  int b2 ;
  int data ;
  int ecc ;
  int tmp ;

  {
  b1 = (int )eccTable[version][level][0];
  b2 = (int )eccTable[version][level][1];
  data = QRspec_getDataLength(version, level);
  ecc = QRspec_getECCLength(version, level);
  if (b2 == 0) {
    *(spec + 0) = b1;
    *(spec + 1) = data / b1;
    *(spec + 2) = ecc / b1;
    tmp = 0;
    *(spec + 4) = tmp;
    *(spec + 3) = tmp;
  } else {
    *(spec + 0) = b1;
    *(spec + 1) = data / (b1 + b2);
    *(spec + 2) = ecc / (b1 + b2);
    *(spec + 3) = b2;
    *(spec + 4) = *(spec + 1) + 1;
  }
  return;
}
}
static int const   alignmentPattern[41][2]  = 
  { {        (int const   )0,        (int const   )0}, 
   {        (int const   )0,        (int const   )0}, 
   {        (int const   )18,        (int const   )0}, 
   {        (int const   )22,        (int const   )0}, 
   {        (int const   )26,        (int const   )0}, 
   {        (int const   )30,        (int const   )0}, 
   {        (int const   )34,        (int const   )0}, 
   {        (int const   )22,        (int const   )38}, 
   {        (int const   )24,        (int const   )42}, 
   {        (int const   )26,        (int const   )46}, 
   {        (int const   )28,        (int const   )50}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )32,        (int const   )58}, 
   {        (int const   )34,        (int const   )62}, 
   {        (int const   )26,        (int const   )46}, 
   {        (int const   )26,        (int const   )48}, 
   {        (int const   )26,        (int const   )50}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )30,        (int const   )56}, 
   {        (int const   )30,        (int const   )58}, 
   {        (int const   )34,        (int const   )62}, 
   {        (int const   )28,        (int const   )50}, 
   {        (int const   )26,        (int const   )50}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )28,        (int const   )54}, 
   {        (int const   )32,        (int const   )58}, 
   {        (int const   )30,        (int const   )58}, 
   {        (int const   )34,        (int const   )62}, 
   {        (int const   )26,        (int const   )50}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )26,        (int const   )52}, 
   {        (int const   )30,        (int const   )56}, 
   {        (int const   )34,        (int const   )60}, 
   {        (int const   )30,        (int const   )58}, 
   {        (int const   )34,        (int const   )62}, 
   {        (int const   )30,        (int const   )54}, 
   {        (int const   )24,        (int const   )50}, 
   {        (int const   )28,        (int const   )54}, 
   {        (int const   )32,        (int const   )58}, 
   {        (int const   )26,        (int const   )54}, 
   {        (int const   )30,        (int const   )58}};
static void QRspec_putAlignmentMarker(unsigned char *frame , int width , int ox ,
                                      int oy ) ;
static unsigned char const   finder[25]  = 
  {      (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )161, 
        (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )160,      (unsigned char const   )160, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )160, 
        (unsigned char const   )161,      (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )161, 
        (unsigned char const   )160,      (unsigned char const   )160,      (unsigned char const   )160,      (unsigned char const   )161, 
        (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )161,      (unsigned char const   )161, 
        (unsigned char const   )161};
static void QRspec_putAlignmentMarker(unsigned char *frame , int width , int ox ,
                                      int oy ) 
{ 
  int x ;
  int y ;
  unsigned char const   *s ;

  {
  frame += ((oy - 2) * width + ox) - 2;
  s = finder;
  y = 0;
  while (y < 5) {
    x = 0;
    while (x < 5) {
      *(frame + x) = (unsigned char )*(s + x);
      x ++;
    }
    frame += width;
    s += 5;
    y ++;
  }
  return;
}
}
static void QRspec_putAlignmentPattern(int version , unsigned char *frame , int width ) 
{ 
  int d ;
  int w ;
  int x ;
  int y ;
  int cx ;
  int cy ;

  {
  if (version < 2) {
    return;
  }
  d = (int )(alignmentPattern[version][1] - alignmentPattern[version][0]);
  if (d < 0) {
    w = 2;
  } else {
    w = (width - (int )alignmentPattern[version][0]) / d + 2;
  }
  if (w * w - 3 == 1) {
    x = (int )alignmentPattern[version][0];
    y = (int )alignmentPattern[version][0];
    QRspec_putAlignmentMarker(frame, width, x, y);
    return;
  }
  cx = (int )alignmentPattern[version][0];
  x = 1;
  while (x < w - 1) {
    QRspec_putAlignmentMarker(frame, width, 6, cx);
    QRspec_putAlignmentMarker(frame, width, cx, 6);
    cx += d;
    x ++;
  }
  cy = (int )alignmentPattern[version][0];
  y = 0;
  while (y < w - 1) {
    cx = (int )alignmentPattern[version][0];
    x = 0;
    while (x < w - 1) {
      QRspec_putAlignmentMarker(frame, width, cx, cy);
      cx += d;
      x ++;
    }
    cy += d;
    y ++;
  }
  return;
}
}
static unsigned int const   versionPattern[34]  = 
  {      (unsigned int const   )31892,      (unsigned int const   )34236,      (unsigned int const   )39577,      (unsigned int const   )42195, 
        (unsigned int const   )48118,      (unsigned int const   )51042,      (unsigned int const   )55367,      (unsigned int const   )58893, 
        (unsigned int const   )63784,      (unsigned int const   )68472,      (unsigned int const   )70749,      (unsigned int const   )76311, 
        (unsigned int const   )79154,      (unsigned int const   )84390,      (unsigned int const   )87683,      (unsigned int const   )92361, 
        (unsigned int const   )96236,      (unsigned int const   )102084,      (unsigned int const   )102881,      (unsigned int const   )110507, 
        (unsigned int const   )110734,      (unsigned int const   )117786,      (unsigned int const   )119615,      (unsigned int const   )126325, 
        (unsigned int const   )127568,      (unsigned int const   )133589,      (unsigned int const   )136944,      (unsigned int const   )141498, 
        (unsigned int const   )145311,      (unsigned int const   )150283,      (unsigned int const   )152622,      (unsigned int const   )158308, 
        (unsigned int const   )161089,      (unsigned int const   )167017};
unsigned int QRspec_getVersionPattern(int version ) 
{ 


  {
  if (version < 7) {
    return (0U);
  } else
  if (version > 40) {
    return (0U);
  }
  return ((unsigned int )versionPattern[version - 7]);
}
}
static unsigned int const   formatInfo[4][8]  = { {        (unsigned int const   )30660,        (unsigned int const   )29427,        (unsigned int const   )32170,        (unsigned int const   )30877, 
            (unsigned int const   )26159,        (unsigned int const   )25368,        (unsigned int const   )27713,        (unsigned int const   )26998}, 
   {        (unsigned int const   )21522,        (unsigned int const   )20773,        (unsigned int const   )24188,        (unsigned int const   )23371, 
            (unsigned int const   )17913,        (unsigned int const   )16590,        (unsigned int const   )20375,        (unsigned int const   )19104}, 
   {        (unsigned int const   )13663,        (unsigned int const   )12392,        (unsigned int const   )16177,        (unsigned int const   )14854, 
            (unsigned int const   )9396,        (unsigned int const   )8579,        (unsigned int const   )11994,        (unsigned int const   )11245}, 
   {        (unsigned int const   )5769,        (unsigned int const   )5054,        (unsigned int const   )7399,        (unsigned int const   )6608, 
            (unsigned int const   )1890,        (unsigned int const   )597,        (unsigned int const   )3340,        (unsigned int const   )2107}};
unsigned int QRspec_getFormatInfo(int mask , QRecLevel level ) 
{ 


  {
  if (mask < 0) {
    return (0U);
  } else
  if (mask > 7) {
    return (0U);
  }
  return ((unsigned int )formatInfo[level][mask]);
}
}
static void putFinderPattern(unsigned char *frame , int width , int ox , int oy ) ;
static unsigned char const   finder___0[49]  = 
  {      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193};
static void putFinderPattern(unsigned char *frame , int width , int ox , int oy ) 
{ 
  int x ;
  int y ;
  unsigned char const   *s ;

  {
  frame += oy * width + ox;
  s = finder___0;
  y = 0;
  while (y < 7) {
    x = 0;
    while (x < 7) {
      *(frame + x) = (unsigned char )*(s + x);
      x ++;
    }
    frame += width;
    s += 7;
    y ++;
  }
  return;
}
}
static unsigned char *QRspec_createFrame(int version ) 
{ 
  unsigned char *frame ;
  unsigned char *p ;
  unsigned char *q ;
  int width ;
  int x ;
  int y ;
  unsigned int verinfo ;
  unsigned int v ;
  void *tmp ;

  {
  width = (int )qrspecCapacity[version].width;
  tmp = malloc((size_t )(width * width));
  frame = (unsigned char *)tmp;
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  memset((void *)frame, 0, (size_t )(width * width));
  putFinderPattern(frame, width, 0, 0);
  putFinderPattern(frame, width, width - 7, 0);
  putFinderPattern(frame, width, 0, width - 7);
  p = frame;
  q = frame + width * (width - 7);
  y = 0;
  while (y < 7) {
    *(p + 7) = (unsigned char)192;
    *(p + (width - 8)) = (unsigned char)192;
    *(q + 7) = (unsigned char)192;
    p += width;
    q += width;
    y ++;
  }
  memset((void *)(frame + width * 7), 192, (size_t )8);
  memset((void *)((frame + width * 8) - 8), 192, (size_t )8);
  memset((void *)(frame + width * (width - 8)), 192, (size_t )8);
  memset((void *)(frame + width * 8), 132, (size_t )9);
  memset((void *)((frame + width * 9) - 8), 132, (size_t )8);
  p = frame + 8;
  y = 0;
  while (y < 8) {
    *p = (unsigned char)132;
    p += width;
    y ++;
  }
  p = (frame + width * (width - 7)) + 8;
  y = 0;
  while (y < 7) {
    *p = (unsigned char)132;
    p += width;
    y ++;
  }
  p = (frame + width * 6) + 8;
  q = (frame + width * 8) + 6;
  x = 1;
  while (x < width - 15) {
    *p = (unsigned char )(144 | (x & 1));
    *q = (unsigned char )(144 | (x & 1));
    p ++;
    q += width;
    x ++;
  }
  QRspec_putAlignmentPattern(version, frame, width);
  if (version >= 7) {
    verinfo = QRspec_getVersionPattern(version);
    p = frame + width * (width - 11);
    v = verinfo;
    x = 0;
    while (x < 6) {
      y = 0;
      while (y < 3) {
        *(p + (width * y + x)) = (unsigned char )(136U | (v & 1U));
        v >>= 1;
        y ++;
      }
      x ++;
    }
    p = (frame + width) - 11;
    v = verinfo;
    y = 0;
    while (y < 6) {
      x = 0;
      while (x < 3) {
        *(p + x) = (unsigned char )(136U | (v & 1U));
        v >>= 1;
        x ++;
      }
      p += width;
      y ++;
    }
  }
  *(frame + (width * (width - 8) + 8)) = (unsigned char)129;
  return (frame);
}
}
unsigned char *QRspec_newFrame(int version ) 
{ 
  unsigned char *tmp ;

  {
  if (version < 1) {
    return ((unsigned char *)((void *)0));
  } else
  if (version > 40) {
    return ((unsigned char *)((void *)0));
  }
  tmp = QRspec_createFrame(version);
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-pMK5suya.i","")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
static pthread_mutex_t RSECC_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static int initialized  =    0;
static unsigned int const   proot  =    (unsigned int const   )285;
static unsigned char alpha[((1U << 8) - 1U) + 1U]  ;
static unsigned char aindex[((1U << 8) - 1U) + 1U]  ;
static unsigned char generator[29][31]  ;
static unsigned char generatorInitialized[29]  ;
static void RSECC_initLookupTable(void) 
{ 
  unsigned int i ;
  unsigned int b ;

  {
  alpha[(1U << 8) - 1U] = (unsigned char)0;
  aindex[0] = (unsigned char )((1U << 8) - 1U);
  b = 1U;
  i = 0U;
  while (i < (1U << 8) - 1U) {
    alpha[i] = (unsigned char )b;
    aindex[b] = (unsigned char )i;
    b <<= 1;
    if (b & (((1U << 8) - 1U) + 1U)) {
      b ^= (unsigned int )proot;
    }
    b &= (1U << 8) - 1U;
    i ++;
  }
  return;
}
}
static void RSECC_init(void) 
{ 


  {
  RSECC_initLookupTable();
  memset((void *)(generatorInitialized), 0, (size_t )29);
  initialized = 1;
  return;
}
}
static void generator_init(size_t length ) 
{ 
  size_t i ;
  size_t j ;
  int g[31] ;

  {
  g[0] = 1;
  i = (size_t )0;
  while (i < length) {
    g[i + 1UL] = 1;
    j = i;
    while (j > 0UL) {
      g[j] = g[j - 1UL] ^ (int )alpha[((size_t )aindex[g[j]] + i) % (unsigned long )((1U << 8) - 1U)];
      j --;
    }
    g[0] = (int )alpha[((size_t )aindex[g[0]] + i) % (unsigned long )((1U << 8) - 1U)];
    i ++;
  }
  i = (size_t )0;
  while (i <= length) {
    generator[length - 2UL][i] = aindex[g[i]];
    i ++;
  }
  generatorInitialized[length - 2UL] = (unsigned char)1;
  return;
}
}
int RSECC_encode(size_t data_length , size_t ecc_length , unsigned char const   *data ,
                 unsigned char *ecc ) 
{ 
  size_t i ;
  size_t j ;
  unsigned char feedback ;
  unsigned char *gen ;

  {
  pthread_mutex_lock(& RSECC_mutex);
  if (! initialized) {
    RSECC_init();
  }
  pthread_mutex_unlock(& RSECC_mutex);
  if (ecc_length > 30UL) {
    return (-1);
  }
  memset((void *)ecc, 0, ecc_length);
  pthread_mutex_lock(& RSECC_mutex);
  if (! generatorInitialized[ecc_length - 2UL]) {
    generator_init(ecc_length);
  }
  pthread_mutex_unlock(& RSECC_mutex);
  gen = generator[ecc_length - 2UL];
  i = (size_t )0;
  while (i < data_length) {
    feedback = aindex[(int const   )*(data + i) ^ (int const   )*(ecc + 0)];
    if ((unsigned int )feedback != (1U << 8) - 1U) {
      j = (size_t )1;
      while (j < ecc_length) {
        *(ecc + j) = (unsigned char )((int )*(ecc + j) ^ (int )alpha[(unsigned int )((int )feedback + (int )*(gen + (ecc_length - j))) % ((1U << 8) - 1U)]);
        j ++;
      }
    }
    memmove((void *)(ecc + 0), (void const   *)(ecc + 1), ecc_length - 1UL);
    if ((unsigned int )feedback != (1U << 8) - 1U) {
      *(ecc + (ecc_length - 1UL)) = alpha[(unsigned int )((int )feedback + (int )*(gen + 0)) % ((1U << 8) - 1U)];
    } else {
      *(ecc + (ecc_length - 1UL)) = (unsigned char)0;
    }
    i ++;
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-Dd2Tueg1.i","")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
static QRencodeMode Split_identifyMode(char const   *string , QRencodeMode hint ) 
{ 
  unsigned char c ;
  unsigned char d ;
  unsigned int word ;
  int tmp ;

  {
  c = (unsigned char )*(string + 0);
  if ((int )c == 0) {
    return ((QRencodeMode )-1);
  }
  if ((int )((unsigned char )((int )((signed char )c) - 48)) < 10) {
    return ((QRencodeMode )0);
  } else {
    if ((int )c & 128) {
      tmp = -1;
    } else {
      tmp = (int )QRinput_anTable[(int )c];
    }
    if (tmp >= 0) {
      return ((QRencodeMode )1);
    } else
    if ((int )hint == 3) {
      d = (unsigned char )*(string + 1);
      if ((int )d != 0) {
        word = ((unsigned int )c << 8) | (unsigned int )d;
        if (word >= 33088U) {
          if (word <= 40956U) {
            return ((QRencodeMode )3);
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (word >= 57408U) {
          if (word <= 60351U) {
            return ((QRencodeMode )3);
          }
        }
      }
    }
  }
  return ((QRencodeMode )2);
}
}
static int Split_eatAn(char const   *string , QRinput *input , QRencodeMode hint ) ;
static int Split_eat8(char const   *string , QRinput *input , QRencodeMode hint ) ;
static int Split_eatNum(char const   *string , QRinput *input , QRencodeMode hint ) 
{ 
  char const   *p ;
  int ret ;
  int run ;
  int dif ;
  int ln ;
  QRencodeMode mode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  ln = QRspec_lengthIndicator((QRencodeMode )0, input->version);
  p = string;
  while ((int )((unsigned char )((int )((signed char )*p) - 48)) < 10) {
    p ++;
  }
  run = (int )(p - string);
  mode = Split_identifyMode(p, hint);
  if ((int )mode == 2) {
    tmp = QRinput_estimateBitsModeNum(run);
    tmp___0 = QRinput_estimateBitsMode8(1);
    tmp___1 = QRinput_estimateBitsMode8(run + 1);
    dif = (((tmp + 4) + ln) + tmp___0) - tmp___1;
    if (dif > 0) {
      tmp___2 = Split_eat8(string, input, hint);
      return (tmp___2);
    }
  }
  if ((int )mode == 1) {
    tmp___3 = QRinput_estimateBitsModeNum(run);
    tmp___4 = QRinput_estimateBitsModeAn(1);
    tmp___5 = QRinput_estimateBitsModeAn(run + 1);
    dif = (((tmp___3 + 4) + ln) + tmp___4) - tmp___5;
    if (dif > 0) {
      tmp___6 = Split_eatAn(string, input, hint);
      return (tmp___6);
    }
  }
  ret = QRinput_append(input, (QRencodeMode )0, run, (unsigned char const   *)((unsigned char *)string));
  if (ret < 0) {
    return (-1);
  }
  return (run);
}
}
static int Split_eatAn(char const   *string , QRinput *input , QRencodeMode hint ) 
{ 
  char const   *p ;
  char const   *q ;
  int ret ;
  int run ;
  int dif ;
  int la ;
  int ln ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  la = QRspec_lengthIndicator((QRencodeMode )1, input->version);
  ln = QRspec_lengthIndicator((QRencodeMode )0, input->version);
  p = string;
  while (1) {
    if ((int const   )*p & 128) {
      tmp___5 = -1;
    } else {
      tmp___5 = (int )QRinput_anTable[(int )*p];
    }
    if (! (tmp___5 >= 0)) {
      break;
    }
    if ((int )((unsigned char )((int )((signed char )*p) - 48)) < 10) {
      q = p;
      while ((int )((unsigned char )((int )((signed char )*q) - 48)) < 10) {
        q ++;
      }
      tmp = QRinput_estimateBitsModeAn((int )(p - string));
      tmp___0 = QRinput_estimateBitsModeNum((int )(q - p));
      if ((int const   )*q & 128) {
        tmp___3 = -1;
      } else {
        tmp___3 = (int )QRinput_anTable[(int )*q];
      }
      if (tmp___3 >= 0) {
        tmp___2 = 4 + ln;
      } else {
        tmp___2 = 0;
      }
      tmp___4 = QRinput_estimateBitsModeAn((int )(q - string));
      dif = ((((tmp + tmp___0) + 4) + ln) + tmp___2) - tmp___4;
      if (dif < 0) {
        break;
      }
      p = q;
    } else {
      p ++;
    }
  }
  run = (int )(p - string);
  if (*p) {
    if ((int const   )*p & 128) {
      tmp___10 = -1;
    } else {
      tmp___10 = (int )QRinput_anTable[(int )*p];
    }
    if (! (tmp___10 >= 0)) {
      tmp___6 = QRinput_estimateBitsModeAn(run);
      tmp___7 = QRinput_estimateBitsMode8(1);
      tmp___8 = QRinput_estimateBitsMode8(run + 1);
      dif = (((tmp___6 + 4) + la) + tmp___7) - tmp___8;
      if (dif > 0) {
        tmp___9 = Split_eat8(string, input, hint);
        return (tmp___9);
      }
    }
  }
  ret = QRinput_append(input, (QRencodeMode )1, run, (unsigned char const   *)((unsigned char *)string));
  if (ret < 0) {
    return (-1);
  }
  return (run);
}
}
static int Split_eatKanji(char const   *string , QRinput *input , QRencodeMode hint ) 
{ 
  char const   *p ;
  int ret ;
  int run ;
  QRencodeMode tmp ;

  {
  p = string;
  while (1) {
    tmp = Split_identifyMode(p, hint);
    if (! ((int )tmp == 3)) {
      break;
    }
    p += 2;
  }
  run = (int )(p - string);
  ret = QRinput_append(input, (QRencodeMode )3, run, (unsigned char const   *)((unsigned char *)string));
  if (ret < 0) {
    return (-1);
  }
  return (run);
}
}
static int Split_eat8(char const   *string , QRinput *input , QRencodeMode hint ) 
{ 
  char const   *p ;
  char const   *q ;
  QRencodeMode mode ;
  int ret ;
  int run ;
  int dif ;
  int la ;
  int ln ;
  int l8 ;
  int swcost ;
  QRencodeMode tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  QRencodeMode tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  la = QRspec_lengthIndicator((QRencodeMode )1, input->version);
  ln = QRspec_lengthIndicator((QRencodeMode )0, input->version);
  l8 = QRspec_lengthIndicator((QRencodeMode )2, input->version);
  p = string + 1;
  while ((int const   )*p != 0) {
    mode = Split_identifyMode(p, hint);
    if ((int )mode == 3) {
      break;
    }
    if ((int )mode == 0) {
      q = p;
      while ((int )((unsigned char )((int )((signed char )*q) - 48)) < 10) {
        q ++;
      }
      tmp = Split_identifyMode(q, hint);
      if ((int )tmp == 2) {
        swcost = 4 + l8;
      } else {
        swcost = 0;
      }
      tmp___0 = QRinput_estimateBitsMode8((int )(p - string));
      tmp___1 = QRinput_estimateBitsModeNum((int )(q - p));
      tmp___2 = QRinput_estimateBitsMode8((int )(q - string));
      dif = ((((tmp___0 + tmp___1) + 4) + ln) + swcost) - tmp___2;
      if (dif < 0) {
        break;
      }
      p = q;
    } else
    if ((int )mode == 1) {
      q = p;
      while (1) {
        if ((int const   )*q & 128) {
          tmp___3 = -1;
        } else {
          tmp___3 = (int )QRinput_anTable[(int )*q];
        }
        if (! (tmp___3 >= 0)) {
          break;
        }
        q ++;
      }
      tmp___4 = Split_identifyMode(q, hint);
      if ((int )tmp___4 == 2) {
        swcost = 4 + l8;
      } else {
        swcost = 0;
      }
      tmp___5 = QRinput_estimateBitsMode8((int )(p - string));
      tmp___6 = QRinput_estimateBitsModeAn((int )(q - p));
      tmp___7 = QRinput_estimateBitsMode8((int )(q - string));
      dif = ((((tmp___5 + tmp___6) + 4) + la) + swcost) - tmp___7;
      if (dif < 0) {
        break;
      }
      p = q;
    } else {
      p ++;
    }
  }
  run = (int )(p - string);
  ret = QRinput_append(input, (QRencodeMode )2, run, (unsigned char const   *)((unsigned char *)string));
  if (ret < 0) {
    return (-1);
  }
  return (run);
}
}
static int Split_splitString(char const   *string , QRinput *input , QRencodeMode hint ) 
{ 
  int length ;
  QRencodeMode mode ;

  {
  while ((int const   )*string != 0) {
    mode = Split_identifyMode(string, hint);
    if ((int )mode == 0) {
      length = Split_eatNum(string, input, hint);
    } else
    if ((int )mode == 1) {
      length = Split_eatAn(string, input, hint);
    } else
    if ((int )mode == 3) {
      if ((int )hint == 3) {
        length = Split_eatKanji(string, input, hint);
      } else {
        length = Split_eat8(string, input, hint);
      }
    } else {
      length = Split_eat8(string, input, hint);
    }
    if (length == 0) {
      break;
    }
    if (length < 0) {
      return (-1);
    }
    string += length;
  }
  return (0);
}
}
static char *dupAndToUpper(char const   *str , QRencodeMode hint ) 
{ 
  char *newstr ;
  char *p ;
  QRencodeMode mode ;

  {
  newstr = strdup(str);
  if ((unsigned long )newstr == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  p = newstr;
  while ((int )*p != 0) {
    mode = Split_identifyMode((char const   *)p, hint);
    if ((int )mode == 3) {
      p += 2;
    } else {
      if ((int )*p >= 97) {
        if ((int )*p <= 122) {
          *p = (char )((int )*p - 32);
        }
      }
      p ++;
    }
  }
  return (newstr);
}
}
int Split_splitStringToQRinput(char const   *string , QRinput *input , QRencodeMode hint ,
                               int casesensitive ) 
{ 
  char *newstr ;
  int ret ;
  int *tmp ;

  {
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  } else
  if ((int const   )*string == 0) {
    tmp = __errno_location();
    *tmp = 22;
    return (-1);
  }
  if (! casesensitive) {
    newstr = dupAndToUpper(string, hint);
    if ((unsigned long )newstr == (unsigned long )((void *)0)) {
      return (-1);
    }
    ret = Split_splitString((char const   *)newstr, input, hint);
    free((void *)newstr);
  } else {
    ret = Split_splitString(string, input, hint);
  }
  return (ret);
}
}
#pragma merger("0","/tmp/cil-Tj2XdeA2.i","")
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
int Mask_calcN2(int width , unsigned char *frame ) ;
int Mask_calcN1N3(int length , int *runLength ) ;
int Mask_calcRunLengthH(int width , unsigned char *frame , int *runLength ) ;
int Mask_calcRunLengthV(int width , unsigned char *frame , int *runLength ) ;
int Mask_evaluateSymbol(int width , unsigned char *frame ) ;
unsigned char *Mask_makeMaskedFrame(int width , unsigned char *frame , int mask ) ;
int Mask_writeFormatInformation(int width , unsigned char *frame , int mask , QRecLevel level ) 
{ 
  unsigned int format ;
  unsigned char v ;
  int i ;
  int blacks ;

  {
  blacks = 0;
  format = QRspec_getFormatInfo(mask, level);
  i = 0;
  while (i < 8) {
    if (format & 1U) {
      blacks += 2;
      v = (unsigned char)133;
    } else {
      v = (unsigned char)132;
    }
    *(frame + (((width * 8 + width) - 1) - i)) = v;
    if (i < 6) {
      *(frame + (width * i + 8)) = v;
    } else {
      *(frame + (width * (i + 1) + 8)) = v;
    }
    format >>= 1;
    i ++;
  }
  i = 0;
  while (i < 7) {
    if (format & 1U) {
      blacks += 2;
      v = (unsigned char)133;
    } else {
      v = (unsigned char)132;
    }
    *(frame + (width * ((width - 7) + i) + 8)) = v;
    if (i == 0) {
      *(frame + (width * 8 + 7)) = v;
    } else {
      *(frame + ((width * 8 + 6) - i)) = v;
    }
    format >>= 1;
    i ++;
  }
  return (blacks);
}
}
static int Mask_mask0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(((x + y) & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask1(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((y & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask2(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(x % 3 == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask3(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((x + y) % 3 == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask4(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(((y / 2 + x / 3) & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask5(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((x * y & 1) + (x * y) % 3 == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask6(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((((x * y & 1) + (x * y) % 3) & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static int Mask_mask7(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;
  int b ;

  {
  b = 0;
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((((x * y) % 3 + ((x + y) & 1)) & 1) == 0));
      }
      b += (int )*d & 1;
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return (b);
}
}
static MaskMaker *maskMakers[8]  = 
  {      & Mask_mask0,      & Mask_mask1,      & Mask_mask2,      & Mask_mask3, 
        & Mask_mask4,      & Mask_mask5,      & Mask_mask6,      & Mask_mask7};
unsigned char *Mask_makeMaskedFrame(int width , unsigned char *frame , int mask ) 
{ 
  unsigned char *masked ;
  void *tmp ;

  {
  tmp = malloc((size_t )(width * width));
  masked = (unsigned char *)tmp;
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  (*(maskMakers[mask]))(width, (unsigned char const   *)frame, masked);
  return (masked);
}
}
unsigned char *Mask_makeMask(int width , unsigned char *frame , int mask , QRecLevel level ) 
{ 
  unsigned char *masked ;
  int *tmp ;
  void *tmp___0 ;

  {
  if (mask < 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((unsigned char *)((void *)0));
  } else
  if (mask >= 8) {
    tmp = __errno_location();
    *tmp = 22;
    return ((unsigned char *)((void *)0));
  }
  tmp___0 = malloc((size_t )(width * width));
  masked = (unsigned char *)tmp___0;
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  (*(maskMakers[mask]))(width, (unsigned char const   *)frame, masked);
  Mask_writeFormatInformation(width, masked, mask, level);
  return (masked);
}
}
int Mask_calcN1N3(int length , int *runLength ) 
{ 
  int i ;
  int demerit ;
  int fact ;

  {
  demerit = 0;
  i = 0;
  while (i < length) {
    if (*(runLength + i) >= 5) {
      demerit += 3 + (*(runLength + i) - 5);
    }
    if (i & 1) {
      if (i >= 3) {
        if (i < length - 2) {
          if (*(runLength + i) % 3 == 0) {
            fact = *(runLength + i) / 3;
            if (*(runLength + (i - 2)) == fact) {
              if (*(runLength + (i - 1)) == fact) {
                if (*(runLength + (i + 1)) == fact) {
                  if (*(runLength + (i + 2)) == fact) {
                    if (i == 3) {
                      demerit += 40;
                    } else
                    if (*(runLength + (i - 3)) >= 4 * fact) {
                      demerit += 40;
                    } else
                    if (i + 4 >= length) {
                      demerit += 40;
                    } else
                    if (*(runLength + (i + 3)) >= 4 * fact) {
                      demerit += 40;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    i ++;
  }
  return (demerit);
}
}
int Mask_calcN2(int width , unsigned char *frame ) 
{ 
  int x ;
  int y ;
  unsigned char *p ;
  unsigned char b22 ;
  unsigned char w22 ;
  int demerit ;

  {
  demerit = 0;
  p = (frame + width) + 1;
  y = 1;
  while (y < width) {
    x = 1;
    while (x < width) {
      b22 = (unsigned char )((((int )*(p + 0) & (int )*(p + -1)) & (int )*(p + - width)) & (int )*(p + (- width - 1)));
      w22 = (unsigned char )((((int )*(p + 0) | (int )*(p + -1)) | (int )*(p + - width)) | (int )*(p + (- width - 1)));
      if (((int )b22 | ((int )w22 ^ 1)) & 1) {
        demerit += 3;
      }
      p ++;
      x ++;
    }
    p ++;
    y ++;
  }
  return (demerit);
}
}
int Mask_calcRunLengthH(int width , unsigned char *frame , int *runLength ) 
{ 
  int head ;
  int i ;
  unsigned char prev ;

  {
  if ((int )*(frame + 0) & 1) {
    *(runLength + 0) = -1;
    head = 1;
  } else {
    head = 0;
  }
  *(runLength + head) = 1;
  prev = *(frame + 0);
  i = 1;
  while (i < width) {
    if (((int )*(frame + i) ^ (int )prev) & 1) {
      head ++;
      *(runLength + head) = 1;
      prev = *(frame + i);
    } else {
      (*(runLength + head)) ++;
    }
    i ++;
  }
  return (head + 1);
}
}
int Mask_calcRunLengthV(int width , unsigned char *frame , int *runLength ) 
{ 
  int head ;
  int i ;
  unsigned char prev ;

  {
  if ((int )*(frame + 0) & 1) {
    *(runLength + 0) = -1;
    head = 1;
  } else {
    head = 0;
  }
  *(runLength + head) = 1;
  prev = *(frame + 0);
  i = 1;
  while (i < width) {
    if (((int )*(frame + i * width) ^ (int )prev) & 1) {
      head ++;
      *(runLength + head) = 1;
      prev = *(frame + i * width);
    } else {
      (*(runLength + head)) ++;
    }
    i ++;
  }
  return (head + 1);
}
}
int Mask_evaluateSymbol(int width , unsigned char *frame ) 
{ 
  int x ;
  int y ;
  int demerit ;
  int runLength[178] ;
  int length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  demerit = 0;
  tmp = Mask_calcN2(width, frame);
  demerit += tmp;
  y = 0;
  while (y < width) {
    length = Mask_calcRunLengthH(width, frame + y * width, runLength);
    tmp___0 = Mask_calcN1N3(length, runLength);
    demerit += tmp___0;
    y ++;
  }
  x = 0;
  while (x < width) {
    length = Mask_calcRunLengthV(width, frame + x, runLength);
    tmp___1 = Mask_calcN1N3(length, runLength);
    demerit += tmp___1;
    x ++;
  }
  return (demerit);
}
}
unsigned char *Mask_mask(int width , unsigned char *frame , QRecLevel level ) 
{ 
  int i ;
  unsigned char *mask ;
  unsigned char *bestMask ;
  int minDemerit ;
  int blacks ;
  int bratio ;
  int demerit ;
  int w2 ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  minDemerit = 2147483647;
  w2 = width * width;
  tmp = malloc((size_t )w2);
  mask = (unsigned char *)tmp;
  if ((unsigned long )mask == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  tmp___0 = malloc((size_t )w2);
  bestMask = (unsigned char *)tmp___0;
  if ((unsigned long )bestMask == (unsigned long )((void *)0)) {
    free((void *)mask);
    return ((unsigned char *)((void *)0));
  }
  i = 0;
  while (i < 8) {
    demerit = 0;
    blacks = (*(maskMakers[i]))(width, (unsigned char const   *)frame, mask);
    tmp___1 = Mask_writeFormatInformation(width, mask, i, level);
    blacks += tmp___1;
    bratio = ((200 * blacks + w2) / w2) / 2;
    tmp___2 = abs(bratio - 50);
    demerit = (tmp___2 / 5) * 10;
    tmp___3 = Mask_evaluateSymbol(width, mask);
    demerit += tmp___3;
    if (demerit < minDemerit) {
      minDemerit = demerit;
      memcpy((void * __restrict  )bestMask, (void const   * __restrict  )mask, (size_t )w2);
    }
    i ++;
  }
  free((void *)mask);
  return (bestMask);
}
}
#pragma merger("0","/tmp/cil-a051TrjL.i","")
unsigned int MQRspec_getFormatInfo(int mask , int version , QRecLevel level ) ;
static MQRspec_Capacity const   mqrspecCapacity[5]  = {      {0, {0, 0, 0, 0}}, 
        {11, {2, 0, 0, 0}}, 
        {13, {5, 6, 0, 0}}, 
        {15, {6, 8, 0, 0}}, 
        {17, {8, 10, 14, 0}}};
int MQRspec_getDataLengthBit(int version , QRecLevel level ) 
{ 
  int w ;
  int ecc ;

  {
  w = (int )(mqrspecCapacity[version].width - 1);
  ecc = mqrspecCapacity[version].ec[level];
  if (ecc == 0) {
    return (0);
  }
  return ((w * w - 64) - ecc * 8);
}
}
int MQRspec_getDataLength(int version , QRecLevel level ) 
{ 
  int tmp ;

  {
  tmp = MQRspec_getDataLengthBit(version, level);
  return ((tmp + 4) / 8);
}
}
int MQRspec_getECCLength(int version , QRecLevel level ) 
{ 


  {
  return (mqrspecCapacity[version].ec[level]);
}
}
int MQRspec_getWidth(int version ) 
{ 


  {
  return ((int )mqrspecCapacity[version].width);
}
}
static int const   lengthTableBits___0[4][4]  = { {        (int const   )3,        (int const   )4,        (int const   )5,        (int const   )6}, 
   {        (int const   )0,        (int const   )3,        (int const   )4,        (int const   )5}, 
   {        (int const   )0,        (int const   )0,        (int const   )4,        (int const   )5}, 
   {        (int const   )0,        (int const   )0,        (int const   )3,        (int const   )4}};
int MQRspec_lengthIndicator(QRencodeMode mode , int version ) 
{ 


  {
  return ((int )lengthTableBits___0[mode][version - 1]);
}
}
int MQRspec_maximumWords(QRencodeMode mode , int version ) 
{ 
  int bits ;
  int words ;

  {
  bits = (int )lengthTableBits___0[mode][version - 1];
  words = (1 << bits) - 1;
  if ((int )mode == 3) {
    words *= 2;
  }
  return (words);
}
}
static unsigned int const   formatInfo___0[4][8]  = { {        (unsigned int const   )17477,        (unsigned int const   )21934,        (unsigned int const   )26515,        (unsigned int const   )30328, 
            (unsigned int const   )1758,        (unsigned int const   )5941,        (unsigned int const   )9480,        (unsigned int const   )13539}, 
   {        (unsigned int const   )16754,        (unsigned int const   )20633,        (unsigned int const   )25252,        (unsigned int const   )29519, 
            (unsigned int const   )1001,        (unsigned int const   )4610,        (unsigned int const   )8255,        (unsigned int const   )12756}, 
   {        (unsigned int const   )20011,        (unsigned int const   )24512,        (unsigned int const   )28157,        (unsigned int const   )31766, 
            (unsigned int const   )3248,        (unsigned int const   )7515,        (unsigned int const   )12134,        (unsigned int const   )16013}, 
   {        (unsigned int const   )19228,        (unsigned int const   )23287,        (unsigned int const   )26826,        (unsigned int const   )31009, 
            (unsigned int const   )2439,        (unsigned int const   )6252,        (unsigned int const   )10833,        (unsigned int const   )15290}};
static int const   typeTable[5][3]  = { {        (int const   )-1,        (int const   )-1,        (int const   )-1}, 
   {        (int const   )0,        (int const   )-1,        (int const   )-1}, 
   {        (int const   )1,        (int const   )2,        (int const   )-1}, 
   {        (int const   )3,        (int const   )4,        (int const   )-1}, 
   {        (int const   )5,        (int const   )6,        (int const   )7}};
unsigned int MQRspec_getFormatInfo(int mask , int version , QRecLevel level ) 
{ 
  int type ;

  {
  if (mask < 0) {
    return (0U);
  } else
  if (mask > 3) {
    return (0U);
  }
  if (version <= 0) {
    return (0U);
  } else
  if (version > 4) {
    return (0U);
  }
  if ((unsigned int )level == 3U) {
    return (0U);
  }
  type = (int )typeTable[version][level];
  if (type < 0) {
    return (0U);
  }
  return ((unsigned int )formatInfo___0[mask][type]);
}
}
static void putFinderPattern___0(unsigned char *frame , int width , int ox , int oy ) ;
static unsigned char const   finder___1[49]  = 
  {      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192,      (unsigned char const   )192, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193,      (unsigned char const   )193, 
        (unsigned char const   )193};
static void putFinderPattern___0(unsigned char *frame , int width , int ox , int oy ) 
{ 
  int x ;
  int y ;
  unsigned char const   *s ;

  {
  frame += oy * width + ox;
  s = finder___1;
  y = 0;
  while (y < 7) {
    x = 0;
    while (x < 7) {
      *(frame + x) = (unsigned char )*(s + x);
      x ++;
    }
    frame += width;
    s += 7;
    y ++;
  }
  return;
}
}
static unsigned char *MQRspec_createFrame(int version ) 
{ 
  unsigned char *frame ;
  unsigned char *p ;
  unsigned char *q ;
  int width ;
  int x ;
  int y ;
  void *tmp ;

  {
  width = (int )mqrspecCapacity[version].width;
  tmp = malloc((size_t )(width * width));
  frame = (unsigned char *)tmp;
  if ((unsigned long )frame == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  memset((void *)frame, 0, (size_t )(width * width));
  putFinderPattern___0(frame, width, 0, 0);
  p = frame;
  y = 0;
  while (y < 7) {
    *(p + 7) = (unsigned char)192;
    p += width;
    y ++;
  }
  memset((void *)(frame + width * 7), 192, (size_t )8);
  memset((void *)((frame + width * 8) + 1), 132, (size_t )8);
  p = (frame + width) + 8;
  y = 0;
  while (y < 7) {
    *p = (unsigned char)132;
    p += width;
    y ++;
  }
  p = frame + 8;
  q = frame + width * 8;
  x = 1;
  while (x < width - 7) {
    *p = (unsigned char )(144 | (x & 1));
    *q = (unsigned char )(144 | (x & 1));
    p ++;
    q += width;
    x ++;
  }
  return (frame);
}
}
unsigned char *MQRspec_newFrame(int version ) 
{ 
  unsigned char *tmp ;

  {
  if (version < 1) {
    return ((unsigned char *)((void *)0));
  } else
  if (version > 4) {
    return ((unsigned char *)((void *)0));
  }
  tmp = MQRspec_createFrame(version);
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-odvBEJWH.i","")
int MMask_evaluateSymbol(int width , unsigned char *frame ) ;
void MMask_writeFormatInformation(int version , int width , unsigned char *frame ,
                                  int mask , QRecLevel level ) ;
unsigned char *MMask_makeMaskedFrame(int width , unsigned char *frame , int mask ) ;
void MMask_writeFormatInformation(int version , int width , unsigned char *frame ,
                                  int mask , QRecLevel level ) 
{ 
  unsigned int format ;
  unsigned char v ;
  int i ;

  {
  format = MQRspec_getFormatInfo(mask, version, level);
  i = 0;
  while (i < 8) {
    v = (unsigned char )(132U | (format & 1U));
    *(frame + (width * (i + 1) + 8)) = v;
    format >>= 1;
    i ++;
  }
  i = 0;
  while (i < 7) {
    v = (unsigned char )(132U | (format & 1U));
    *(frame + ((width * 8 + 7) - i)) = v;
    format >>= 1;
    i ++;
  }
  return;
}
}
static void Mask_mask0___0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((y & 1) == 0));
      }
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return;
}
}
static void Mask_mask1___0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(((y / 2 + x / 3) & 1) == 0));
      }
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return;
}
}
static void Mask_mask2___0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )((((x * y & 1) + (x * y) % 3) & 1) == 0));
      }
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return;
}
}
static void Mask_mask3___0(int width , unsigned char const   *s , unsigned char *d ) 
{ 
  int x ;
  int y ;

  {
  y = 0;
  while (y < width) {
    x = 0;
    while (x < width) {
      if ((int const   )*s & 128) {
        *d = (unsigned char )*s;
      } else {
        *d = (unsigned char )((int const   )*s ^ (int const   )(((((x + y) & 1) + (x * y) % 3) & 1) == 0));
      }
      s ++;
      d ++;
      x ++;
    }
    y ++;
  }
  return;
}
}
static MaskMaker___0 *maskMakers___0[4]  = {      & Mask_mask0___0,      & Mask_mask1___0,      & Mask_mask2___0,      & Mask_mask3___0};
unsigned char *MMask_makeMaskedFrame(int width , unsigned char *frame , int mask ) 
{ 
  unsigned char *masked ;
  void *tmp ;

  {
  tmp = malloc((size_t )(width * width));
  masked = (unsigned char *)tmp;
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  (*(maskMakers___0[mask]))(width, (unsigned char const   *)frame, masked);
  return (masked);
}
}
unsigned char *MMask_makeMask(int version , unsigned char *frame , int mask , QRecLevel level ) 
{ 
  unsigned char *masked ;
  int width ;
  int *tmp ;
  void *tmp___0 ;

  {
  if (mask < 0) {
    tmp = __errno_location();
    *tmp = 22;
    return ((unsigned char *)((void *)0));
  } else
  if (mask >= 4) {
    tmp = __errno_location();
    *tmp = 22;
    return ((unsigned char *)((void *)0));
  }
  width = MQRspec_getWidth(version);
  tmp___0 = malloc((size_t )(width * width));
  masked = (unsigned char *)tmp___0;
  if ((unsigned long )masked == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  (*(maskMakers___0[mask]))(width, (unsigned char const   *)frame, masked);
  MMask_writeFormatInformation(version, width, masked, mask, level);
  return (masked);
}
}
int MMask_evaluateSymbol(int width , unsigned char *frame ) 
{ 
  int x ;
  int y ;
  unsigned char *p ;
  int sum1 ;
  int sum2 ;
  int tmp ;

  {
  sum1 = 0;
  sum2 = 0;
  p = frame + width * (width - 1);
  x = 1;
  while (x < width) {
    sum1 += (int )*(p + x) & 1;
    x ++;
  }
  p = (frame + width * 2) - 1;
  y = 1;
  while (y < width) {
    sum2 += (int )*p & 1;
    p += width;
    y ++;
  }
  if (sum1 <= sum2) {
    tmp = sum1 * 16 + sum2;
  } else {
    tmp = sum2 * 16 + sum1;
  }
  return (tmp);
}
}
unsigned char *MMask_mask(int version , unsigned char *frame , QRecLevel level ) 
{ 
  int i ;
  unsigned char *mask ;
  unsigned char *bestMask ;
  int maxScore ;
  int score ;
  int width ;
  void *tmp ;
  void *tmp___0 ;

  {
  maxScore = 0;
  width = MQRspec_getWidth(version);
  tmp = malloc((size_t )(width * width));
  mask = (unsigned char *)tmp;
  if ((unsigned long )mask == (unsigned long )((void *)0)) {
    return ((unsigned char *)((void *)0));
  }
  bestMask = (unsigned char *)((void *)0);
  i = 0;
  while (i < 4) {
    score = 0;
    (*(maskMakers___0[i]))(width, (unsigned char const   *)frame, mask);
    MMask_writeFormatInformation(version, width, mask, i, level);
    score = MMask_evaluateSymbol(width, mask);
    if (score > maxScore) {
      maxScore = score;
      free((void *)bestMask);
      bestMask = mask;
      tmp___0 = malloc((size_t )(width * width));
      mask = (unsigned char *)tmp___0;
      if ((unsigned long )mask == (unsigned long )((void *)0)) {
        break;
      }
    }
    i ++;
  }
  free((void *)mask);
  return (bestMask);
}
}
